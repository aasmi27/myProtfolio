/*! For license information please see main.9ae18fe7.js.LICENSE.txt */
(() => { var __webpack_modules__ = { 115: function (e, t, n) { e.exports = function () { "use strict"; var e = "undefined" != typeof window ? window : "undefined" != typeof n.g ? n.g : "undefined" != typeof self ? self : {}, t = "Expected a function", r = NaN, i = "[object Symbol]", a = /^\s+|\s+$/g, s = /^[-+]0x[0-9a-f]+$/i, o = /^0b[01]+$/i, l = /^0o[0-7]+$/i, c = parseInt, u = "object" == typeof e && e && e.Object === Object && e, d = "object" == typeof self && self && self.Object === Object && self, h = u || d || Function("return this")(), f = Object.prototype.toString, p = Math.max, m = Math.min, g = function () { return h.Date.now() }; function v(e, n, r) { var i, a, s, o, l, c, u = 0, d = !1, h = !1, f = !0; if ("function" != typeof e) throw new TypeError(t); function v(t) { var n = i, r = a; return i = a = void 0, u = t, o = e.apply(r, n) } function w(e) { var t = e - c; return void 0 === c || t >= n || t < 0 || h && e - u >= s } function x() { var e = g(); if (w(e)) return _(e); l = setTimeout(x, function (e) { var t = n - (e - c); return h ? m(t, s - (e - u)) : t }(e)) } function _(e) { return l = void 0, f && i ? v(e) : (i = a = void 0, o) } function k() { var e = g(), t = w(e); if (i = arguments, a = this, c = e, t) { if (void 0 === l) return function (e) { return u = e, l = setTimeout(x, n), d ? v(e) : o }(c); if (h) return l = setTimeout(x, n), v(c) } return void 0 === l && (l = setTimeout(x, n)), o } return n = y(n) || 0, b(r) && (d = !!r.leading, s = (h = "maxWait" in r) ? p(y(r.maxWait) || 0, n) : s, f = "trailing" in r ? !!r.trailing : f), k.cancel = function () { void 0 !== l && clearTimeout(l), u = 0, i = c = a = l = void 0 }, k.flush = function () { return void 0 === l ? o : _(g()) }, k } function b(e) { var t = typeof e; return !!e && ("object" == t || "function" == t) } function y(e) { if ("number" == typeof e) return e; if (function (e) { return "symbol" == typeof e || function (e) { return !!e && "object" == typeof e }(e) && f.call(e) == i }(e)) return r; if (b(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = b(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(a, ""); var n = o.test(e); return n || l.test(e) ? c(e.slice(2), n ? 2 : 8) : s.test(e) ? r : +e } var w = function (e, n, r) { var i = !0, a = !0; if ("function" != typeof e) throw new TypeError(t); return b(r) && (i = "leading" in r ? !!r.leading : i, a = "trailing" in r ? !!r.trailing : a), v(e, n, { leading: i, maxWait: n, trailing: a }) }, x = "Expected a function", _ = NaN, k = "[object Symbol]", S = /^\s+|\s+$/g, A = /^[-+]0x[0-9a-f]+$/i, E = /^0b[01]+$/i, C = /^0o[0-7]+$/i, M = parseInt, T = "object" == typeof e && e && e.Object === Object && e, P = "object" == typeof self && self && self.Object === Object && self, R = T || P || Function("return this")(), N = Object.prototype.toString, L = Math.max, I = Math.min, D = function () { return R.Date.now() }; function O(e) { var t = typeof e; return !!e && ("object" == t || "function" == t) } function j(e) { if ("number" == typeof e) return e; if (function (e) { return "symbol" == typeof e || function (e) { return !!e && "object" == typeof e }(e) && N.call(e) == k }(e)) return _; if (O(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = O(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(S, ""); var n = E.test(e); return n || C.test(e) ? M(e.slice(2), n ? 2 : 8) : A.test(e) ? _ : +e } var F = function (e, t, n) { var r, i, a, s, o, l, c = 0, u = !1, d = !1, h = !0; if ("function" != typeof e) throw new TypeError(x); function f(t) { var n = r, a = i; return r = i = void 0, c = t, s = e.apply(a, n) } function p(e) { var n = e - l; return void 0 === l || n >= t || n < 0 || d && e - c >= a } function m() { var e = D(); if (p(e)) return g(e); o = setTimeout(m, function (e) { var n = t - (e - l); return d ? I(n, a - (e - c)) : n }(e)) } function g(e) { return o = void 0, h && r ? f(e) : (r = i = void 0, s) } function v() { var e = D(), n = p(e); if (r = arguments, i = this, l = e, n) { if (void 0 === o) return function (e) { return c = e, o = setTimeout(m, t), u ? f(e) : s }(l); if (d) return o = setTimeout(m, t), f(l) } return void 0 === o && (o = setTimeout(m, t)), s } return t = j(t) || 0, O(n) && (u = !!n.leading, a = (d = "maxWait" in n) ? L(j(n.maxWait) || 0, t) : a, h = "trailing" in n ? !!n.trailing : h), v.cancel = function () { void 0 !== o && clearTimeout(o), c = 0, r = l = i = o = void 0 }, v.flush = function () { return void 0 === o ? s : g(D()) }, v }, z = function () { }; function W(e) { e && e.forEach((function (e) { var t = Array.prototype.slice.call(e.addedNodes), n = Array.prototype.slice.call(e.removedNodes); if (function e(t) { var n = void 0, r = void 0; for (n = 0; n < t.length; n += 1) { if ((r = t[n]).dataset && r.dataset.aos) return !0; if (r.children && e(r.children)) return !0 } return !1 }(t.concat(n))) return z() })) } function B() { return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver } var H = { isSupported: function () { return !!B() }, ready: function (e, t) { var n = window.document, r = new (B())(W); z = t, r.observe(n.documentElement, { childList: !0, subtree: !0, removedNodes: !0 }) } }, U = function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }, V = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(), q = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, G = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, X = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, Y = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i, K = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i; function Q() { return navigator.userAgent || navigator.vendor || window.opera || "" } var $ = new (function () { function e() { U(this, e) } return V(e, [{ key: "phone", value: function () { var e = Q(); return !(!G.test(e) && !X.test(e.substr(0, 4))) } }, { key: "mobile", value: function () { var e = Q(); return !(!Y.test(e) && !K.test(e.substr(0, 4))) } }, { key: "tablet", value: function () { return this.mobile() && !this.phone() } }, { key: "ie11", value: function () { return "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style } }]), e }()), J = function (e, t) { var n = void 0; return $.ie11() ? (n = document.createEvent("CustomEvent")).initCustomEvent(e, !0, !0, { detail: t }) : n = new CustomEvent(e, { detail: t }), document.dispatchEvent(n) }, Z = function (e) { return e.forEach((function (e, t) { return function (e, t) { var n = e.options, r = e.position, i = e.node, a = (e.data, function () { e.animated && (function (e, t) { t && t.forEach((function (t) { return e.classList.remove(t) })) }(i, n.animatedClassNames), J("aos:out", i), e.options.id && J("aos:in:" + e.options.id, i), e.animated = !1) }); n.mirror && t >= r.out && !n.once ? a() : t >= r.in ? e.animated || (function (e, t) { t && t.forEach((function (t) { return e.classList.add(t) })) }(i, n.animatedClassNames), J("aos:in", i), e.options.id && J("aos:in:" + e.options.id, i), e.animated = !0) : e.animated && !n.once && a() }(e, window.pageYOffset) })) }, ee = function (e) { for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);)t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent; return { top: n, left: t } }, te = function (e, t, n) { var r = e.getAttribute("data-aos-" + t); if (void 0 !== r) { if ("true" === r) return !0; if ("false" === r) return !1 } return r || n }, ne = function (e, t) { return e.forEach((function (e, n) { var r = te(e.node, "mirror", t.mirror), i = te(e.node, "once", t.once), a = te(e.node, "id"), s = t.useClassNames && e.node.getAttribute("data-aos"), o = [t.animatedClassName].concat(s ? s.split(" ") : []).filter((function (e) { return "string" == typeof e })); t.initClassName && e.node.classList.add(t.initClassName), e.position = { in: function (e, t, n) { var r = window.innerHeight, i = te(e, "anchor"), a = te(e, "anchor-placement"), s = Number(te(e, "offset", a ? 0 : t)), o = a || n, l = e; i && document.querySelectorAll(i) && (l = document.querySelectorAll(i)[0]); var c = ee(l).top - r; switch (o) { case "top-bottom": break; case "center-bottom": c += l.offsetHeight / 2; break; case "bottom-bottom": c += l.offsetHeight; break; case "top-center": c += r / 2; break; case "center-center": c += r / 2 + l.offsetHeight / 2; break; case "bottom-center": c += r / 2 + l.offsetHeight; break; case "top-top": c += r; break; case "bottom-top": c += r + l.offsetHeight; break; case "center-top": c += r + l.offsetHeight / 2 }return c + s }(e.node, t.offset, t.anchorPlacement), out: r && function (e, t) { window.innerHeight; var n = te(e, "anchor"), r = te(e, "offset", t), i = e; return n && document.querySelectorAll(n) && (i = document.querySelectorAll(n)[0]), ee(i).top + i.offsetHeight - r }(e.node, t.offset) }, e.options = { once: i, mirror: r, animatedClassNames: o, id: a } })), e }, re = function () { var e = document.querySelectorAll("[data-aos]"); return Array.prototype.map.call(e, (function (e) { return { node: e } })) }, ie = [], ae = !1, se = { offset: 120, delay: 0, easing: "ease", duration: 400, disable: !1, once: !1, mirror: !1, anchorPlacement: "top-bottom", startEvent: "DOMContentLoaded", animatedClassName: "aos-animate", initClassName: "aos-init", useClassNames: !1, disableMutationObserver: !1, throttleDelay: 99, debounceDelay: 50 }, oe = function () { return document.all && !window.atob }, le = function () { arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (ae = !0), ae && (ie = ne(ie, se), Z(ie), window.addEventListener("scroll", w((function () { Z(ie, se.once) }), se.throttleDelay))) }, ce = function () { if (ie = re(), de(se.disable) || oe()) return ue(); le() }, ue = function () { ie.forEach((function (e, t) { e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay"), se.initClassName && e.node.classList.remove(se.initClassName), se.animatedClassName && e.node.classList.remove(se.animatedClassName) })) }, de = function (e) { return !0 === e || "mobile" === e && $.mobile() || "phone" === e && $.phone() || "tablet" === e && $.tablet() || "function" == typeof e && !0 === e() }; return { init: function (e) { return se = q(se, e), ie = re(), se.disableMutationObserver || H.isSupported() || (console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '), se.disableMutationObserver = !0), se.disableMutationObserver || H.ready("[data-aos]", ce), de(se.disable) || oe() ? ue() : (document.querySelector("body").setAttribute("data-aos-easing", se.easing), document.querySelector("body").setAttribute("data-aos-duration", se.duration), document.querySelector("body").setAttribute("data-aos-delay", se.delay), -1 === ["DOMContentLoaded", "load"].indexOf(se.startEvent) ? document.addEventListener(se.startEvent, (function () { le(!0) })) : window.addEventListener("load", (function () { le(!0) })), "DOMContentLoaded" === se.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 && le(!0), window.addEventListener("resize", F(le, se.debounceDelay, !0)), window.addEventListener("orientationchange", F(le, se.debounceDelay, !0)), ie) }, refresh: le, refreshHard: ce } }() }, 730: (e, t, n) => { "use strict"; var r = n(43), i = n(853); function a(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, o = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (o[e] = t, e = 0; e < t.length; e++)s.add(t[e]) } var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, p = {}; function m(e, t, n, r, i, a, s) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = a, this.removeEmptyString = s } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var v = /[\-:]([a-z])/g; function b(e) { return e[1].toUpperCase() } function y(e, t, n, r) { var i = g.hasOwnProperty(t) ? g[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null === t || "undefined" === typeof t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!d.call(p, e) || !d.call(f, e) && (h.test(e) ? p[e] = !0 : (f[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(v, b); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(v, b); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(v, b); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, x = Symbol.for("react.element"), _ = Symbol.for("react.portal"), k = Symbol.for("react.fragment"), S = Symbol.for("react.strict_mode"), A = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), C = Symbol.for("react.context"), M = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), P = Symbol.for("react.suspense_list"), R = Symbol.for("react.memo"), N = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var L = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var I = Symbol.iterator; function D(e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = I && e[I] || e["@@iterator"]) ? e : null } var O, j = Object.assign; function F(e) { if (void 0 === O) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); O = t && t[1] || "" } return "\n" + O + e } var z = !1; function W(e, t) { if (!e || z) return ""; z = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" === typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) { if (c && r && "string" === typeof c.stack) { for (var i = c.stack.split("\n"), a = r.stack.split("\n"), s = i.length - 1, o = a.length - 1; 1 <= s && 0 <= o && i[s] !== a[o];)o--; for (; 1 <= s && 0 <= o; s--, o--)if (i[s] !== a[o]) { if (1 !== s || 1 !== o) do { if (s--, 0 > --o || i[s] !== a[o]) { var l = "\n" + i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= s && 0 <= o); break } } } finally { z = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? F(e) : "" } function B(e) { switch (e.tag) { case 5: return F(e.type); case 16: return F("Lazy"); case 13: return F("Suspense"); case 19: return F("SuspenseList"); case 0: case 2: case 15: return e = W(e.type, !1); case 11: return e = W(e.type.render, !1); case 1: return e = W(e.type, !0); default: return "" } } function H(e) { if (null == e) return null; if ("function" === typeof e) return e.displayName || e.name || null; if ("string" === typeof e) return e; switch (e) { case k: return "Fragment"; case _: return "Portal"; case A: return "Profiler"; case S: return "StrictMode"; case T: return "Suspense"; case P: return "SuspenseList" }if ("object" === typeof e) switch (e.$$typeof) { case C: return (e.displayName || "Context") + ".Consumer"; case E: return (e._context.displayName || "Context") + ".Provider"; case M: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case R: return null !== (t = e.displayName || null) ? t : H(e.type) || "Memo"; case N: t = e._payload, e = e._init; try { return H(e(t)) } catch (n) { } }return null } function U(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return H(t); case 8: return t === S ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" === typeof t) return t.displayName || t.name || null; if ("string" === typeof t) return t }return null } function V(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function q(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function G(e) { e._valueTracker || (e._valueTracker = function (e) { var t = q(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) { var i = n.get, a = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, a.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function X(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = q(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function Y(e) { if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function K(e, t) { var n = t.checked; return j({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function Q(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = V(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function $(e, t) { null != (t = t.checked) && y(e, "checked", t, !1) } function J(e, t) { $(e, t); var n = V(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, V(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function Z(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && Y(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + V(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(a(91)); return j({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(a(92)); if (te(n)) { if (1 < n.length) throw Error(a(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: V(n) } } function ae(e, t) { var n = V(t.value), r = V(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function se(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function oe(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? oe(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function he(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var fe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = me(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(fe).forEach((function (e) { pe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e] })) })); var ve = j({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function be(e, t) { if (t) { if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(a(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(a(60)); if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(a(61)) } if (null != t.style && "object" !== typeof t.style) throw Error(a(62)) } } function ye(e, t) { if (-1 === e.indexOf("-")) return "string" === typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var we = null; function xe(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var _e = null, ke = null, Se = null; function Ae(e) { if (e = yi(e)) { if ("function" !== typeof _e) throw Error(a(280)); var t = e.stateNode; t && (t = xi(t), _e(e.stateNode, e.type, t)) } } function Ee(e) { ke ? Se ? Se.push(e) : Se = [e] : ke = e } function Ce() { if (ke) { var e = ke, t = Se; if (Se = ke = null, Ae(e), t) for (e = 0; e < t.length; e++)Ae(t[e]) } } function Me(e, t) { return e(t) } function Te() { } var Pe = !1; function Re(e, t, n) { if (Pe) return e(t, n); Pe = !0; try { return Me(e, t, n) } finally { Pe = !1, (null !== ke || null !== Se) && (Te(), Ce()) } } function Ne(e, t) { var n = e.stateNode; if (null === n) return null; var r = xi(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" !== typeof n) throw Error(a(231, t, typeof n)); return n } var Le = !1; if (u) try { var Ie = {}; Object.defineProperty(Ie, "passive", { get: function () { Le = !0 } }), window.addEventListener("test", Ie, Ie), window.removeEventListener("test", Ie, Ie) } catch (ue) { Le = !1 } function De(e, t, n, r, i, a, s, o, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var Oe = !1, je = null, Fe = !1, ze = null, We = { onError: function (e) { Oe = !0, je = e } }; function Be(e, t, n, r, i, a, s, o, l) { Oe = !1, je = null, De.apply(We, arguments) } function He(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function Ue(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated } return null } function Ve(e) { if (He(e) !== e) throw Error(a(188)) } function qe(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = He(e))) throw Error(a(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var s = i.alternate; if (null === s) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === n) return Ve(i), e; if (s === r) return Ve(i), t; s = s.sibling } throw Error(a(188)) } if (n.return !== r.return) n = i, r = s; else { for (var o = !1, l = i.child; l;) { if (l === n) { o = !0, n = i, r = s; break } if (l === r) { o = !0, r = i, n = s; break } l = l.sibling } if (!o) { for (l = s.child; l;) { if (l === n) { o = !0, n = s, r = i; break } if (l === r) { o = !0, r = s, n = i; break } l = l.sibling } if (!o) throw Error(a(189)) } } if (n.alternate !== r) throw Error(a(190)) } if (3 !== n.tag) throw Error(a(188)); return n.stateNode.current === n ? e : t }(e)) ? Ge(e) : null } function Ge(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Ge(e); if (null !== t) return t; e = e.sibling } return null } var Xe = i.unstable_scheduleCallback, Ye = i.unstable_cancelCallback, Ke = i.unstable_shouldYield, Qe = i.unstable_requestPaint, $e = i.unstable_now, Je = i.unstable_getCurrentPriorityLevel, Ze = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, at = null; var st = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, 0 === e ? 32 : 31 - (ot(e) / lt | 0) | 0 }, ot = Math.log, lt = Math.LN2; var ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ht(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, a = e.pingedLanes, s = 268435455 & n; if (0 !== s) { var o = s & ~i; 0 !== o ? r = dt(o) : 0 !== (a &= s) && (r = dt(a)) } else 0 !== (s = n & ~i) ? r = dt(s) : 0 !== a && (r = dt(a)); if (0 === r) return 0; if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (a = t & -t) || 16 === i && 0 !== (4194240 & a))) return t; if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - st(t)), r |= e[n], t &= ~i; return r } function ft(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function pt(e) { return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function vt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - st(t)] = n } function bt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - st(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var yt = 0; function wt(e) { return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1 } var xt, _t, kt, St, At, Et = !1, Ct = [], Mt = null, Tt = null, Pt = null, Rt = new Map, Nt = new Map, Lt = [], It = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Dt(e, t) { switch (e) { case "focusin": case "focusout": Mt = null; break; case "dragenter": case "dragleave": Tt = null; break; case "mouseover": case "mouseout": Pt = null; break; case "pointerover": case "pointerout": Rt.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Nt.delete(t.pointerId) } } function Ot(e, t, n, r, i, a) { return null === e || e.nativeEvent !== a ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: a, targetContainers: [i] }, null !== t && (null !== (t = yi(t)) && _t(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function jt(e) { var t = bi(e.target); if (null !== t) { var n = He(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = Ue(n))) return e.blockedOn = t, void At(e.priority, (function () { kt(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function Ft(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Kt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = yi(n)) && _t(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); we = r, n.target.dispatchEvent(r), we = null, t.shift() } return !0 } function zt(e, t, n) { Ft(e) && n.delete(t) } function Wt() { Et = !1, null !== Mt && Ft(Mt) && (Mt = null), null !== Tt && Ft(Tt) && (Tt = null), null !== Pt && Ft(Pt) && (Pt = null), Rt.forEach(zt), Nt.forEach(zt) } function Bt(e, t) { e.blockedOn === t && (e.blockedOn = null, Et || (Et = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Wt))) } function Ht(e) { function t(t) { return Bt(t, e) } if (0 < Ct.length) { Bt(Ct[0], e); for (var n = 1; n < Ct.length; n++) { var r = Ct[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== Mt && Bt(Mt, e), null !== Tt && Bt(Tt, e), null !== Pt && Bt(Pt, e), Rt.forEach(t), Nt.forEach(t), n = 0; n < Lt.length; n++)(r = Lt[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Lt.length && null === (n = Lt[0]).blockedOn;)jt(n), null === n.blockedOn && Lt.shift() } var Ut = w.ReactCurrentBatchConfig, Vt = !0; function qt(e, t, n, r) { var i = yt, a = Ut.transition; Ut.transition = null; try { yt = 1, Xt(e, t, n, r) } finally { yt = i, Ut.transition = a } } function Gt(e, t, n, r) { var i = yt, a = Ut.transition; Ut.transition = null; try { yt = 4, Xt(e, t, n, r) } finally { yt = i, Ut.transition = a } } function Xt(e, t, n, r) { if (Vt) { var i = Kt(e, t, n, r); if (null === i) Vr(e, t, r, Yt, n), Dt(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return Mt = Ot(Mt, e, t, n, r, i), !0; case "dragenter": return Tt = Ot(Tt, e, t, n, r, i), !0; case "mouseover": return Pt = Ot(Pt, e, t, n, r, i), !0; case "pointerover": var a = i.pointerId; return Rt.set(a, Ot(Rt.get(a) || null, e, t, n, r, i)), !0; case "gotpointercapture": return a = i.pointerId, Nt.set(a, Ot(Nt.get(a) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (Dt(e, r), 4 & t && -1 < It.indexOf(e)) { for (; null !== i;) { var a = yi(i); if (null !== a && xt(a), null === (a = Kt(e, t, n, r)) && Vr(e, t, r, Yt, n), a === i) break; i = a } null !== i && r.stopPropagation() } else Vr(e, t, r, null, n) } } var Yt = null; function Kt(e, t, n, r) { if (Yt = null, null !== (e = bi(e = xe(r)))) if (null === (t = He(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = Ue(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Yt = e, null } function Qt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Je()) { case Ze: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var $t = null, Jt = null, Zt = null; function en() { if (Zt) return Zt; var e, t, n = Jt, r = n.length, i = "value" in $t ? $t.value : $t.textContent, a = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var s = r - e; for (t = 1; t <= s && n[r - t] === i[a - t]; t++); return Zt = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function an(e) { function t(t, n, r, i, a) { for (var s in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = a, this.currentTarget = null, e) e.hasOwnProperty(s) && (t = e[s], this[s] = t ? t(i) : i[s]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return j(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var sn, on, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = an(cn), dn = j({}, cn, { view: 0, detail: 0 }), hn = an(dn), fn = j({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: An, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (sn = e.screenX - ln.screenX, on = e.screenY - ln.screenY) : on = sn = 0, ln = e), sn) }, movementY: function (e) { return "movementY" in e ? e.movementY : on } }), pn = an(fn), mn = an(j({}, fn, { dataTransfer: 0 })), gn = an(j({}, dn, { relatedTarget: 0 })), vn = an(j({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), bn = j({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), yn = an(bn), wn = an(j({}, cn, { data: 0 })), xn = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, _n = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, kn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Sn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = kn[e]) && !!t[e] } function An() { return Sn } var En = j({}, dn, { key: function (e) { if (e.key) { var t = xn[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? _n[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: An, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), Cn = an(En), Mn = an(j({}, fn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Tn = an(j({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: An })), Pn = an(j({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), Rn = j({}, fn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Nn = an(Rn), Ln = [9, 13, 27, 32], In = u && "CompositionEvent" in window, Dn = null; u && "documentMode" in document && (Dn = document.documentMode); var On = u && "TextEvent" in window && !Dn, jn = u && (!In || Dn && 8 < Dn && 11 >= Dn), Fn = String.fromCharCode(32), zn = !1; function Wn(e, t) { switch (e) { case "keyup": return -1 !== Ln.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Bn(e) { return "object" === typeof (e = e.detail) && "data" in e ? e.data : null } var Hn = !1; var Un = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Vn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!Un[e.type] : "textarea" === t } function qn(e, t, n, r) { Ee(r), 0 < (t = Gr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Gn = null, Xn = null; function Yn(e) { Fr(e, 0) } function Kn(e) { if (X(wi(e))) return e } function Qn(e, t) { if ("change" === e) return t } var $n = !1; if (u) { var Jn; if (u) { var Zn = "oninput" in document; if (!Zn) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), Zn = "function" === typeof er.oninput } Jn = Zn } else Jn = !1; $n = Jn && (!document.documentMode || 9 < document.documentMode) } function tr() { Gn && (Gn.detachEvent("onpropertychange", nr), Xn = Gn = null) } function nr(e) { if ("value" === e.propertyName && Kn(Xn)) { var t = []; qn(t, Xn, e, xe(e)), Re(Yn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), Xn = n, (Gn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Kn(Xn) } function ar(e, t) { if ("click" === e) return Kn(t) } function sr(e, t) { if ("input" === e || "change" === e) return Kn(t) } var or = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }; function lr(e, t) { if (or(e, t)) return !0; if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!d.call(t, i) || !or(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function dr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hr() { for (var e = window, t = Y(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" === typeof t.contentWindow.location.href } catch (r) { n = !1 } if (!n) break; t = Y((e = t.contentWindow).document) } return t } function fr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function pr(e) { var t = hr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) { if (null !== r && fr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, a = Math.min(r.start, i); r = void 0 === r.end ? a : Math.min(r.end, i), !e.extend && a > r && (i = r, r = a, a = i), i = ur(n, a); var s = ur(n, r); i && s && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), a > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, vr = null, br = null, yr = !1; function wr(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; yr || null == gr || gr !== Y(r) || ("selectionStart" in (r = gr) && fr(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : r = { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, br && lr(br, r) || (br = r, 0 < (r = Gr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = gr))) } function xr(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var _r = { animationend: xr("Animation", "AnimationEnd"), animationiteration: xr("Animation", "AnimationIteration"), animationstart: xr("Animation", "AnimationStart"), transitionend: xr("Transition", "TransitionEnd") }, kr = {}, Sr = {}; function Ar(e) { if (kr[e]) return kr[e]; if (!_r[e]) return e; var t, n = _r[e]; for (t in n) if (n.hasOwnProperty(t) && t in Sr) return kr[e] = n[t]; return e } u && (Sr = document.createElement("div").style, "AnimationEvent" in window || (delete _r.animationend.animation, delete _r.animationiteration.animation, delete _r.animationstart.animation), "TransitionEvent" in window || delete _r.transitionend.transition); var Er = Ar("animationend"), Cr = Ar("animationiteration"), Mr = Ar("animationstart"), Tr = Ar("transitionend"), Pr = new Map, Rr = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Nr(e, t) { Pr.set(e, t), l(t, [e]) } for (var Lr = 0; Lr < Rr.length; Lr++) { var Ir = Rr[Lr]; Nr(Ir.toLowerCase(), "on" + (Ir[0].toUpperCase() + Ir.slice(1))) } Nr(Er, "onAnimationEnd"), Nr(Cr, "onAnimationIteration"), Nr(Mr, "onAnimationStart"), Nr("dblclick", "onDoubleClick"), Nr("focusin", "onFocus"), Nr("focusout", "onBlur"), Nr(Tr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Dr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Or = new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr)); function jr(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, s, o, l, c) { if (Be.apply(this, arguments), Oe) { if (!Oe) throw Error(a(198)); var u = je; Oe = !1, je = null, Fe || (Fe = !0, ze = u) } }(r, t, void 0, e), e.currentTarget = null } function Fr(e, t) { t = 0 !== (4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var a = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var o = r[s], l = o.instance, c = o.currentTarget; if (o = o.listener, l !== a && i.isPropagationStopped()) break e; jr(i, o, c), a = l } else for (s = 0; s < r.length; s++) { if (l = (o = r[s]).instance, c = o.currentTarget, o = o.listener, l !== a && i.isPropagationStopped()) break e; jr(i, o, c), a = l } } } if (Fe) throw e = ze, Fe = !1, ze = null, e } function zr(e, t) { var n = t[mi]; void 0 === n && (n = t[mi] = new Set); var r = e + "__bubble"; n.has(r) || (Ur(t, e, 2, !1), n.add(r)) } function Wr(e, t, n) { var r = 0; t && (r |= 4), Ur(n, e, r, t) } var Br = "_reactListening" + Math.random().toString(36).slice(2); function Hr(e) { if (!e[Br]) { e[Br] = !0, s.forEach((function (t) { "selectionchange" !== t && (Or.has(t) || Wr(t, !1, e), Wr(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Br] || (t[Br] = !0, Wr("selectionchange", !1, t)) } } function Ur(e, t, n, r) { switch (Qt(t)) { case 1: var i = qt; break; case 4: i = Gt; break; default: i = Xt }n = i.bind(null, t, n, e), i = void 0, !Le || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Vr(e, t, n, r, i) { var a = r; if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (; ;) { if (null === r) return; var s = r.tag; if (3 === s || 4 === s) { var o = r.stateNode.containerInfo; if (o === i || 8 === o.nodeType && o.parentNode === i) break; if (4 === s) for (s = r.return; null !== s;) { var l = s.tag; if ((3 === l || 4 === l) && ((l = s.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; s = s.return } for (; null !== o;) { if (null === (s = bi(o))) return; if (5 === (l = s.tag) || 6 === l) { r = a = s; continue e } o = o.parentNode } } r = r.return } Re((function () { var r = a, i = xe(n), s = []; e: { var o = Pr.get(e); if (void 0 !== o) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = Cn; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = pn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = Tn; break; case Er: case Cr: case Mr: l = vn; break; case Tr: l = Pn; break; case "scroll": l = hn; break; case "wheel": l = Nn; break; case "copy": case "cut": case "paste": l = yn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = Mn }var u = 0 !== (4 & t), d = !u && "scroll" === e, h = u ? null !== o ? o + "Capture" : null : o; u = []; for (var f, p = r; null !== p;) { var m = (f = p).stateNode; if (5 === f.tag && null !== m && (f = m, null !== h && (null != (m = Ne(p, h)) && u.push(qr(p, m, f)))), d) break; p = p.return } 0 < u.length && (o = new l(o, c, null, n, i), s.push({ event: o, listeners: u })) } } if (0 === (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(o = "mouseover" === e || "pointerover" === e) || n === we || !(c = n.relatedTarget || n.fromElement) || !bi(c) && !c[pi]) && (l || o) && (o = i.window === i ? i : (o = i.ownerDocument) ? o.defaultView || o.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? bi(c) : null) && (c !== (d = He(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = pn, m = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Mn, m = "onPointerLeave", h = "onPointerEnter", p = "pointer"), d = null == l ? o : wi(l), f = null == c ? o : wi(c), (o = new u(m, p + "leave", l, n, i)).target = d, o.relatedTarget = f, m = null, bi(i) === r && ((u = new u(h, p + "enter", c, n, i)).target = f, u.relatedTarget = d, m = u), d = m, l && c) e: { for (h = c, p = 0, f = u = l; f; f = Xr(f))p++; for (f = 0, m = h; m; m = Xr(m))f++; for (; 0 < p - f;)u = Xr(u), p--; for (; 0 < f - p;)h = Xr(h), f--; for (; p--;) { if (u === h || null !== h && u === h.alternate) break e; u = Xr(u), h = Xr(h) } u = null } else u = null; null !== l && Yr(s, o, l, u, !1), null !== c && null !== d && Yr(s, d, c, u, !0) } if ("select" === (l = (o = r ? wi(r) : window).nodeName && o.nodeName.toLowerCase()) || "input" === l && "file" === o.type) var g = Qn; else if (Vn(o)) if ($n) g = sr; else { g = ir; var v = rr } else (l = o.nodeName) && "input" === l.toLowerCase() && ("checkbox" === o.type || "radio" === o.type) && (g = ar); switch (g && (g = g(e, r)) ? qn(s, g, n, i) : (v && v(e, o, r), "focusout" === e && (v = o._wrapperState) && v.controlled && "number" === o.type && ee(o, "number", o.value)), v = r ? wi(r) : window, e) { case "focusin": (Vn(v) || "true" === v.contentEditable) && (gr = v, vr = r, br = null); break; case "focusout": br = vr = gr = null; break; case "mousedown": yr = !0; break; case "contextmenu": case "mouseup": case "dragend": yr = !1, wr(s, n, i); break; case "selectionchange": if (mr) break; case "keydown": case "keyup": wr(s, n, i) }var b; if (In) e: { switch (e) { case "compositionstart": var y = "onCompositionStart"; break e; case "compositionend": y = "onCompositionEnd"; break e; case "compositionupdate": y = "onCompositionUpdate"; break e }y = void 0 } else Hn ? Wn(e, n) && (y = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (y = "onCompositionStart"); y && (jn && "ko" !== n.locale && (Hn || "onCompositionStart" !== y ? "onCompositionEnd" === y && Hn && (b = en()) : (Jt = "value" in ($t = i) ? $t.value : $t.textContent, Hn = !0)), 0 < (v = Gr(r, y)).length && (y = new wn(y, e, null, n, i), s.push({ event: y, listeners: v }), b ? y.data = b : null !== (b = Bn(n)) && (y.data = b))), (b = On ? function (e, t) { switch (e) { case "compositionend": return Bn(t); case "keypress": return 32 !== t.which ? null : (zn = !0, Fn); case "textInput": return (e = t.data) === Fn && zn ? null : e; default: return null } }(e, n) : function (e, t) { if (Hn) return "compositionend" === e || !In && Wn(e, t) ? (e = en(), Zt = Jt = $t = null, Hn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return jn && "ko" !== t.locale ? null : t.data } }(e, n)) && (0 < (r = Gr(r, "onBeforeInput")).length && (i = new wn("onBeforeInput", "beforeinput", null, n, i), s.push({ event: i, listeners: r }), i.data = b)) } Fr(s, t) })) } function qr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Gr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, a = i.stateNode; 5 === i.tag && null !== a && (i = a, null != (a = Ne(e, n)) && r.unshift(qr(e, a, i)), null != (a = Ne(e, t)) && r.push(qr(e, a, i))), e = e.return } return r } function Xr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Yr(e, t, n, r, i) { for (var a = t._reactName, s = []; null !== n && n !== r;) { var o = n, l = o.alternate, c = o.stateNode; if (null !== l && l === r) break; 5 === o.tag && null !== c && (o = c, i ? null != (l = Ne(n, a)) && s.unshift(qr(n, l, o)) : i || null != (l = Ne(n, a)) && s.push(qr(n, l, o))), n = n.return } 0 !== s.length && e.push({ event: t, listeners: s }) } var Kr = /\r\n?/g, Qr = /\u0000|\uFFFD/g; function $r(e) { return ("string" === typeof e ? e : "" + e).replace(Kr, "\n").replace(Qr, "") } function Jr(e, t, n) { if (t = $r(t), $r(e) !== t && n) throw Error(a(425)) } function Zr() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" === typeof setTimeout ? setTimeout : void 0, ii = "function" === typeof clearTimeout ? clearTimeout : void 0, ai = "function" === typeof Promise ? Promise : void 0, si = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof ai ? function (e) { return ai.resolve(null).then(e).catch(oi) } : ri; function oi(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void Ht(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); Ht(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var di = Math.random().toString(36).slice(2), hi = "__reactFiber$" + di, fi = "__reactProps$" + di, pi = "__reactContainer$" + di, mi = "__reactEvents$" + di, gi = "__reactListeners$" + di, vi = "__reactHandles$" + di; function bi(e) { var t = e[hi]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[pi] || n[hi]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[hi]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function yi(e) { return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function wi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(a(33)) } function xi(e) { return e[fi] || null } var _i = [], ki = -1; function Si(e) { return { current: e } } function Ai(e) { 0 > ki || (e.current = _i[ki], _i[ki] = null, ki--) } function Ei(e, t) { ki++, _i[ki] = e.current, e.current = t } var Ci = {}, Mi = Si(Ci), Ti = Si(!1), Pi = Ci; function Ri(e, t) { var n = e.type.contextTypes; if (!n) return Ci; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, a = {}; for (i in n) a[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = a), a } function Ni(e) { return null !== (e = e.childContextTypes) && void 0 !== e } function Li() { Ai(Ti), Ai(Mi) } function Ii(e, t, n) { if (Mi.current !== Ci) throw Error(a(168)); Ei(Mi, t), Ei(Ti, n) } function Di(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(a(108, U(e) || "Unknown", i)); return j({}, n, r) } function Oi(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ci, Pi = Mi.current, Ei(Mi, e), Ei(Ti, Ti.current), !0 } function ji(e, t, n) { var r = e.stateNode; if (!r) throw Error(a(169)); n ? (e = Di(e, t, Pi), r.__reactInternalMemoizedMergedChildContext = e, Ai(Ti), Ai(Mi), Ei(Mi, e)) : Ai(Ti), Ei(Ti, n) } var Fi = null, zi = !1, Wi = !1; function Bi(e) { null === Fi ? Fi = [e] : Fi.push(e) } function Hi() { if (!Wi && null !== Fi) { Wi = !0; var e = 0, t = yt; try { var n = Fi; for (yt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Fi = null, zi = !1 } catch (i) { throw null !== Fi && (Fi = Fi.slice(e + 1)), Xe(Ze, Hi), i } finally { yt = t, Wi = !1 } } return null } var Ui = [], Vi = 0, qi = null, Gi = 0, Xi = [], Yi = 0, Ki = null, Qi = 1, $i = ""; function Ji(e, t) { Ui[Vi++] = Gi, Ui[Vi++] = qi, qi = e, Gi = t } function Zi(e, t, n) { Xi[Yi++] = Qi, Xi[Yi++] = $i, Xi[Yi++] = Ki, Ki = e; var r = Qi; e = $i; var i = 32 - st(r) - 1; r &= ~(1 << i), n += 1; var a = 32 - st(t) + i; if (30 < a) { var s = i - i % 5; a = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Qi = 1 << 32 - st(t) + i | n << i | r, $i = a + e } else Qi = 1 << a | n << i | r, $i = e } function ea(e) { null !== e.return && (Ji(e, 1), Zi(e, 1, 0)) } function ta(e) { for (; e === qi;)qi = Ui[--Vi], Ui[Vi] = null, Gi = Ui[--Vi], Ui[Vi] = null; for (; e === Ki;)Ki = Xi[--Yi], Xi[Yi] = null, $i = Xi[--Yi], Xi[Yi] = null, Qi = Xi[--Yi], Xi[Yi] = null } var na = null, ra = null, ia = !1, aa = null; function sa(e, t) { var n = Rc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function oa(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, na = e, ra = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, na = e, ra = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Ki ? { id: Qi, overflow: $i } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Rc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, na = e, ra = null, !0); default: return !1 } } function la(e) { return 0 !== (1 & e.mode) && 0 === (128 & e.flags) } function ca(e) { if (ia) { var t = ra; if (t) { var n = t; if (!oa(e, t)) { if (la(e)) throw Error(a(418)); t = ci(n.nextSibling); var r = na; t && oa(e, t) ? sa(r, n) : (e.flags = -4097 & e.flags | 2, ia = !1, na = e) } } else { if (la(e)) throw Error(a(418)); e.flags = -4097 & e.flags | 2, ia = !1, na = e } } } function ua(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; na = e } function da(e) { if (e !== na) return !1; if (!ia) return ua(e), ia = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ra)) { if (la(e)) throw ha(), Error(a(418)); for (; t;)sa(e, t), t = ci(t.nextSibling) } if (ua(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(a(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { ra = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } ra = null } } else ra = na ? ci(e.stateNode.nextSibling) : null; return !0 } function ha() { for (var e = ra; e;)e = ci(e.nextSibling) } function fa() { ra = na = null, ia = !1 } function pa(e) { null === aa ? aa = [e] : aa.push(e) } var ma = w.ReactCurrentBatchConfig; function ga(e, t, n) { if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(a(309)); var r = n.stateNode } if (!r) throw Error(a(147, e)); var i = r, s = "" + e; return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === s ? t.ref : (t = function (e) { var t = i.refs; null === e ? delete t[s] : t[s] = e }, t._stringRef = s, t) } if ("string" !== typeof e) throw Error(a(284)); if (!n._owner) throw Error(a(290, e)) } return e } function va(e, t) { throw e = Object.prototype.toString.call(t), Error(a(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function ba(e) { return (0, e._init)(e._payload) } function ya(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Lc(e, t)).index = 0, e.sibling = null, e } function s(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function o(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = jc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var a = n.type; return a === k ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === a || "object" === typeof a && null !== a && a.$$typeof === N && ba(a) === t.type) ? ((r = i(t, n.props)).ref = ga(e, t, n), r.return = e, r) : ((r = Ic(n.type, n.key, n.props, null, e.mode, r)).ref = ga(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Fc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function d(e, t, n, r, a) { return null === t || 7 !== t.tag ? ((t = Dc(n, e.mode, r, a)).return = e, t) : ((t = i(t, n)).return = e, t) } function h(e, t, n) { if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = jc("" + t, e.mode, n)).return = e, t; if ("object" === typeof t && null !== t) { switch (t.$$typeof) { case x: return (n = Ic(t.type, t.key, t.props, null, e.mode, n)).ref = ga(e, null, t), n.return = e, n; case _: return (t = Fc(t, e.mode, n)).return = e, t; case N: return h(e, (0, t._init)(t._payload), n) }if (te(t) || D(t)) return (t = Dc(t, e.mode, n, null)).return = e, t; va(e, t) } return null } function f(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" === typeof n && null !== n) { switch (n.$$typeof) { case x: return n.key === i ? c(e, t, n, r) : null; case _: return n.key === i ? u(e, t, n, r) : null; case N: return f(e, t, (i = n._init)(n._payload), r) }if (te(n) || D(n)) return null !== i ? null : d(e, t, n, r, null); va(e, n) } return null } function p(e, t, n, r, i) { if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" === typeof r && null !== r) { switch (r.$$typeof) { case x: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case _: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case N: return p(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || D(r)) return d(t, e = e.get(n) || null, r, i, null); va(t, r) } return null } function m(i, a, o, l) { for (var c = null, u = null, d = a, m = a = 0, g = null; null !== d && m < o.length; m++) { d.index > m ? (g = d, d = null) : g = d.sibling; var v = f(i, d, o[m], l); if (null === v) { null === d && (d = g); break } e && d && null === v.alternate && t(i, d), a = s(v, a, m), null === u ? c = v : u.sibling = v, u = v, d = g } if (m === o.length) return n(i, d), ia && Ji(i, m), c; if (null === d) { for (; m < o.length; m++)null !== (d = h(i, o[m], l)) && (a = s(d, a, m), null === u ? c = d : u.sibling = d, u = d); return ia && Ji(i, m), c } for (d = r(i, d); m < o.length; m++)null !== (g = p(d, i, m, o[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), a = s(g, a, m), null === u ? c = g : u.sibling = g, u = g); return e && d.forEach((function (e) { return t(i, e) })), ia && Ji(i, m), c } function g(i, o, l, c) { var u = D(l); if ("function" !== typeof u) throw Error(a(150)); if (null == (l = u.call(l))) throw Error(a(151)); for (var d = u = null, m = o, g = o = 0, v = null, b = l.next(); null !== m && !b.done; g++, b = l.next()) { m.index > g ? (v = m, m = null) : v = m.sibling; var y = f(i, m, b.value, c); if (null === y) { null === m && (m = v); break } e && m && null === y.alternate && t(i, m), o = s(y, o, g), null === d ? u = y : d.sibling = y, d = y, m = v } if (b.done) return n(i, m), ia && Ji(i, g), u; if (null === m) { for (; !b.done; g++, b = l.next())null !== (b = h(i, b.value, c)) && (o = s(b, o, g), null === d ? u = b : d.sibling = b, d = b); return ia && Ji(i, g), u } for (m = r(i, m); !b.done; g++, b = l.next())null !== (b = p(m, i, g, b.value, c)) && (e && null !== b.alternate && m.delete(null === b.key ? g : b.key), o = s(b, o, g), null === d ? u = b : d.sibling = b, d = b); return e && m.forEach((function (e) { return t(i, e) })), ia && Ji(i, g), u } return function e(r, a, s, l) { if ("object" === typeof s && null !== s && s.type === k && null === s.key && (s = s.props.children), "object" === typeof s && null !== s) { switch (s.$$typeof) { case x: e: { for (var c = s.key, u = a; null !== u;) { if (u.key === c) { if ((c = s.type) === k) { if (7 === u.tag) { n(r, u.sibling), (a = i(u, s.props.children)).return = r, r = a; break e } } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === N && ba(c) === u.type) { n(r, u.sibling), (a = i(u, s.props)).ref = ga(r, u, s), a.return = r, r = a; break e } n(r, u); break } t(r, u), u = u.sibling } s.type === k ? ((a = Dc(s.props.children, r.mode, l, s.key)).return = r, r = a) : ((l = Ic(s.type, s.key, s.props, null, r.mode, l)).ref = ga(r, a, s), l.return = r, r = l) } return o(r); case _: e: { for (u = s.key; null !== a;) { if (a.key === u) { if (4 === a.tag && a.stateNode.containerInfo === s.containerInfo && a.stateNode.implementation === s.implementation) { n(r, a.sibling), (a = i(a, s.children || [])).return = r, r = a; break e } n(r, a); break } t(r, a), a = a.sibling } (a = Fc(s, r.mode, l)).return = r, r = a } return o(r); case N: return e(r, a, (u = s._init)(s._payload), l) }if (te(s)) return m(r, a, s, l); if (D(s)) return g(r, a, s, l); va(r, s) } return "string" === typeof s && "" !== s || "number" === typeof s ? (s = "" + s, null !== a && 6 === a.tag ? (n(r, a.sibling), (a = i(a, s)).return = r, r = a) : (n(r, a), (a = jc(s, r.mode, l)).return = r, r = a), o(r)) : n(r, a) } } var wa = ya(!0), xa = ya(!1), _a = Si(null), ka = null, Sa = null, Aa = null; function Ea() { Aa = Sa = ka = null } function Ca(e) { var t = _a.current; Ai(_a), e._currentValue = t } function Ma(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Ta(e, t) { ka = e, Aa = Sa = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (yo = !0), e.firstContext = null) } function Pa(e) { var t = e._currentValue; if (Aa !== e) if (e = { context: e, memoizedValue: t, next: null }, null === Sa) { if (null === ka) throw Error(a(308)); Sa = e, ka.dependencies = { lanes: 0, firstContext: e } } else Sa = Sa.next = e; return t } var Ra = null; function Na(e) { null === Ra ? Ra = [e] : Ra.push(e) } function La(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, Na(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ia(e, r) } function Ia(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var Da = !1; function Oa(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function ja(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Fa(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function za(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 !== (2 & Ml)) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ia(e, n) } return null === (i = r.interleaved) ? (t.next = t, Na(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ia(e, n) } function Wa(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, bt(e, n) } } function Ba(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, a = null; if (null !== (n = n.firstBaseUpdate)) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === a ? i = a = s : a = a.next = s, n = n.next } while (null !== n); null === a ? i = a = t : a = a.next = t } else i = a = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: a, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Ha(e, t, n, r) { var i = e.updateQueue; Da = !1; var a = i.firstBaseUpdate, s = i.lastBaseUpdate, o = i.shared.pending; if (null !== o) { i.shared.pending = null; var l = o, c = l.next; l.next = null, null === s ? a = c : s.next = c, s = l; var u = e.alternate; null !== u && ((o = (u = u.updateQueue).lastBaseUpdate) !== s && (null === o ? u.firstBaseUpdate = c : o.next = c, u.lastBaseUpdate = l)) } if (null !== a) { var d = i.baseState; for (s = 0, u = c = l = null, o = a; ;) { var h = o.lane, f = o.eventTime; if ((r & h) === h) { null !== u && (u = u.next = { eventTime: f, lane: 0, tag: o.tag, payload: o.payload, callback: o.callback, next: null }); e: { var p = e, m = o; switch (h = t, f = n, m.tag) { case 1: if ("function" === typeof (p = m.payload)) { d = p.call(f, d, h); break e } d = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if (null === (h = "function" === typeof (p = m.payload) ? p.call(f, d, h) : p) || void 0 === h) break e; d = j({}, d, h); break e; case 2: Da = !0 } } null !== o.callback && 0 !== o.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [o] : h.push(o)) } else f = { eventTime: f, lane: h, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, null === u ? (c = u = f, l = d) : u = u.next = f, s |= h; if (null === (o = o.next)) { if (null === (o = i.shared.pending)) break; o = (h = o).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { s |= i.lane, i = i.next } while (i !== t) } else null === a && (i.shared.lanes = 0); Ol |= s, e.lanes = s, e.memoizedState = d } } function Ua(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" !== typeof i) throw Error(a(191, i)); i.call(r) } } } var Va = {}, qa = Si(Va), Ga = Si(Va), Xa = Si(Va); function Ya(e) { if (e === Va) throw Error(a(174)); return e } function Ka(e, t) { switch (Ei(Xa, t), Ei(Ga, e), Ei(qa, Va), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }Ai(qa), Ei(qa, t) } function Qa() { Ai(qa), Ai(Ga), Ai(Xa) } function $a(e) { Ya(Xa.current); var t = Ya(qa.current), n = le(t, e.type); t !== n && (Ei(Ga, e), Ei(qa, n)) } function Ja(e) { Ga.current === e && (Ai(qa), Ai(Ga)) } var Za = Si(0); function es(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 !== (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ts = []; function ns() { for (var e = 0; e < ts.length; e++)ts[e]._workInProgressVersionPrimary = null; ts.length = 0 } var rs = w.ReactCurrentDispatcher, is = w.ReactCurrentBatchConfig, as = 0, ss = null, os = null, ls = null, cs = !1, us = !1, ds = 0, hs = 0; function fs() { throw Error(a(321)) } function ps(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!or(e[n], t[n])) return !1; return !0 } function ms(e, t, n, r, i, s) { if (as = s, ss = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, rs.current = null === e || null === e.memoizedState ? Js : Zs, e = n(r, i), us) { s = 0; do { if (us = !1, ds = 0, 25 <= s) throw Error(a(301)); s += 1, ls = os = null, t.updateQueue = null, rs.current = eo, e = n(r, i) } while (us) } if (rs.current = $s, t = null !== os && null !== os.next, as = 0, ls = os = ss = null, cs = !1, t) throw Error(a(300)); return e } function gs() { var e = 0 !== ds; return ds = 0, e } function vs() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === ls ? ss.memoizedState = ls = e : ls = ls.next = e, ls } function bs() { if (null === os) { var e = ss.alternate; e = null !== e ? e.memoizedState : null } else e = os.next; var t = null === ls ? ss.memoizedState : ls.next; if (null !== t) ls = t, os = e; else { if (null === e) throw Error(a(310)); e = { memoizedState: (os = e).memoizedState, baseState: os.baseState, baseQueue: os.baseQueue, queue: os.queue, next: null }, null === ls ? ss.memoizedState = ls = e : ls = ls.next = e } return ls } function ys(e, t) { return "function" === typeof t ? t(e) : t } function ws(e) { var t = bs(), n = t.queue; if (null === n) throw Error(a(311)); n.lastRenderedReducer = e; var r = os, i = r.baseQueue, s = n.pending; if (null !== s) { if (null !== i) { var o = i.next; i.next = s.next, s.next = o } r.baseQueue = i = s, n.pending = null } if (null !== i) { s = i.next, r = r.baseState; var l = o = null, c = null, u = s; do { var d = u.lane; if ((as & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, o = r) : c = c.next = h, ss.lanes |= d, Ol |= d } u = u.next } while (null !== u && u !== s); null === c ? o = r : c.next = l, or(r, t.memoizedState) || (yo = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { s = i.lane, ss.lanes |= s, Ol |= s, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function xs(e) { var t = bs(), n = t.queue; if (null === n) throw Error(a(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, s = t.memoizedState; if (null !== i) { n.pending = null; var o = i = i.next; do { s = e(s, o.action), o = o.next } while (o !== i); or(s, t.memoizedState) || (yo = !0), t.memoizedState = s, null === t.baseQueue && (t.baseState = s), n.lastRenderedState = s } return [s, r] } function _s() { } function ks(e, t) { var n = ss, r = bs(), i = t(), s = !or(r.memoizedState, i); if (s && (r.memoizedState = i, yo = !0), r = r.queue, Ds(Es.bind(null, n, r, e), [e]), r.getSnapshot !== t || s || null !== ls && 1 & ls.memoizedState.tag) { if (n.flags |= 2048, Ps(9, As.bind(null, n, r, i, t), void 0, null), null === Tl) throw Error(a(349)); 0 !== (30 & as) || Ss(n, t, i) } return i } function Ss(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = ss.updateQueue) ? (t = { lastEffect: null, stores: null }, ss.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function As(e, t, n, r) { t.value = n, t.getSnapshot = r, Cs(t) && Ms(e) } function Es(e, t, n) { return n((function () { Cs(t) && Ms(e) })) } function Cs(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !or(e, n) } catch (r) { return !0 } } function Ms(e) { var t = Ia(e, 1); null !== t && nc(t, e, 1, -1) } function Ts(e) { var t = vs(); return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ys, lastRenderedState: e }, t.queue = e, e = e.dispatch = Xs.bind(null, ss, e), [t.memoizedState, e] } function Ps(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = ss.updateQueue) ? (t = { lastEffect: null, stores: null }, ss.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function Rs() { return bs().memoizedState } function Ns(e, t, n, r) { var i = vs(); ss.flags |= e, i.memoizedState = Ps(1 | t, n, void 0, void 0 === r ? null : r) } function Ls(e, t, n, r) { var i = bs(); r = void 0 === r ? null : r; var a = void 0; if (null !== os) { var s = os.memoizedState; if (a = s.destroy, null !== r && ps(r, s.deps)) return void (i.memoizedState = Ps(t, n, a, r)) } ss.flags |= e, i.memoizedState = Ps(1 | t, n, a, r) } function Is(e, t) { return Ns(8390656, 8, e, t) } function Ds(e, t) { return Ls(2048, 8, e, t) } function Os(e, t) { return Ls(4, 2, e, t) } function js(e, t) { return Ls(4, 4, e, t) } function Fs(e, t) { return "function" === typeof t ? (e = e(), t(e), function () { t(null) }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function zs(e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Ls(4, 4, Fs.bind(null, t, e), n) } function Ws() { } function Bs(e, t) { var n = bs(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && ps(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Hs(e, t) { var n = bs(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && ps(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Us(e, t, n) { return 0 === (21 & as) ? (e.baseState && (e.baseState = !1, yo = !0), e.memoizedState = n) : (or(n, t) || (n = mt(), ss.lanes |= n, Ol |= n, e.baseState = !0), t) } function Vs(e, t) { var n = yt; yt = 0 !== n && 4 > n ? n : 4, e(!0); var r = is.transition; is.transition = {}; try { e(!1), t() } finally { yt = n, is.transition = r } } function qs() { return bs().memoizedState } function Gs(e, t, n) { var r = tc(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Ys(e)) Ks(t, n); else if (null !== (n = La(e, t, n, r))) { nc(n, e, r, ec()), Qs(n, t, r) } } function Xs(e, t, n) { var r = tc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Ys(e)) Ks(t, i); else { var a = e.alternate; if (0 === e.lanes && (null === a || 0 === a.lanes) && null !== (a = t.lastRenderedReducer)) try { var s = t.lastRenderedState, o = a(s, n); if (i.hasEagerState = !0, i.eagerState = o, or(o, s)) { var l = t.interleaved; return null === l ? (i.next = i, Na(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (c) { } null !== (n = La(e, t, i, r)) && (nc(n, e, r, i = ec()), Qs(n, t, r)) } } function Ys(e) { var t = e.alternate; return e === ss || null !== t && t === ss } function Ks(e, t) { us = cs = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Qs(e, t, n) { if (0 !== (4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, bt(e, n) } } var $s = { readContext: Pa, useCallback: fs, useContext: fs, useEffect: fs, useImperativeHandle: fs, useInsertionEffect: fs, useLayoutEffect: fs, useMemo: fs, useReducer: fs, useRef: fs, useState: fs, useDebugValue: fs, useDeferredValue: fs, useTransition: fs, useMutableSource: fs, useSyncExternalStore: fs, useId: fs, unstable_isNewReconciler: !1 }, Js = { readContext: Pa, useCallback: function (e, t) { return vs().memoizedState = [e, void 0 === t ? null : t], e }, useContext: Pa, useEffect: Is, useImperativeHandle: function (e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Ns(4194308, 4, Fs.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Ns(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Ns(4, 2, e, t) }, useMemo: function (e, t) { var n = vs(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = vs(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = Gs.bind(null, ss, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, vs().memoizedState = e }, useState: Ts, useDebugValue: Ws, useDeferredValue: function (e) { return vs().memoizedState = e }, useTransition: function () { var e = Ts(!1), t = e[0]; return e = Vs.bind(null, e[1]), vs().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ss, i = vs(); if (ia) { if (void 0 === n) throw Error(a(407)); n = n() } else { if (n = t(), null === Tl) throw Error(a(349)); 0 !== (30 & as) || Ss(r, t, n) } i.memoizedState = n; var s = { value: n, getSnapshot: t }; return i.queue = s, Is(Es.bind(null, r, s, e), [e]), r.flags |= 2048, Ps(9, As.bind(null, r, s, n, t), void 0, null), n }, useId: function () { var e = vs(), t = Tl.identifierPrefix; if (ia) { var n = $i; t = ":" + t + "R" + (n = (Qi & ~(1 << 32 - st(Qi) - 1)).toString(32) + n), 0 < (n = ds++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = hs++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Zs = { readContext: Pa, useCallback: Bs, useContext: Pa, useEffect: Ds, useImperativeHandle: zs, useInsertionEffect: Os, useLayoutEffect: js, useMemo: Hs, useReducer: ws, useRef: Rs, useState: function () { return ws(ys) }, useDebugValue: Ws, useDeferredValue: function (e) { return Us(bs(), os.memoizedState, e) }, useTransition: function () { return [ws(ys)[0], bs().memoizedState] }, useMutableSource: _s, useSyncExternalStore: ks, useId: qs, unstable_isNewReconciler: !1 }, eo = { readContext: Pa, useCallback: Bs, useContext: Pa, useEffect: Ds, useImperativeHandle: zs, useInsertionEffect: Os, useLayoutEffect: js, useMemo: Hs, useReducer: xs, useRef: Rs, useState: function () { return xs(ys) }, useDebugValue: Ws, useDeferredValue: function (e) { var t = bs(); return null === os ? t.memoizedState = e : Us(t, os.memoizedState, e) }, useTransition: function () { return [xs(ys)[0], bs().memoizedState] }, useMutableSource: _s, useSyncExternalStore: ks, useId: qs, unstable_isNewReconciler: !1 }; function to(e, t) { if (e && e.defaultProps) { for (var n in t = j({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } function no(e, t, n, r) { n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : j({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var ro = { isMounted: function (e) { return !!(e = e._reactInternals) && He(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = ec(), i = tc(e), a = Fa(r, i); a.payload = t, void 0 !== n && null !== n && (a.callback = n), null !== (t = za(e, a, i)) && (nc(t, e, i, r), Wa(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = ec(), i = tc(e), a = Fa(r, i); a.tag = 1, a.payload = t, void 0 !== n && null !== n && (a.callback = n), null !== (t = za(e, a, i)) && (nc(t, e, i, r), Wa(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = ec(), r = tc(e), i = Fa(n, r); i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = za(e, i, r)) && (nc(t, e, r, n), Wa(t, e, r)) } }; function io(e, t, n, r, i, a, s) { return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, a, s) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, a)) } function ao(e, t, n) { var r = !1, i = Ci, a = t.contextType; return "object" === typeof a && null !== a ? a = Pa(a) : (i = Ni(t) ? Pi : Mi.current, a = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ri(e, i) : Ci), t = new t(n, a), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = ro, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = a), t } function so(e, t, n, r) { e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && ro.enqueueReplaceState(t, t.state, null) } function oo(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = {}, Oa(e); var a = t.contextType; "object" === typeof a && null !== a ? i.context = Pa(a) : (a = Ni(t) ? Pi : Mi.current, i.context = Ri(e, a)), i.state = e.memoizedState, "function" === typeof (a = t.getDerivedStateFromProps) && (no(e, t, a, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && ro.enqueueReplaceState(i, i.state, null), Ha(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308) } function lo(e, t) { try { var n = "", r = t; do { n += B(r), r = r.return } while (r); var i = n } catch (a) { i = "\nError generating stack: " + a.message + "\n" + a.stack } return { value: e, source: t, stack: i, digest: null } } function co(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function uo(e, t) { try { console.error(t.value) } catch (n) { setTimeout((function () { throw n })) } } var ho = "function" === typeof WeakMap ? WeakMap : Map; function fo(e, t, n) { (n = Fa(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Vl || (Vl = !0, ql = r), uo(0, t) }, n } function po(e, t, n) { (n = Fa(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" === typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { uo(0, t) } } var a = e.stateNode; return null !== a && "function" === typeof a.componentDidCatch && (n.callback = function () { uo(0, t), "function" !== typeof r && (null === Gl ? Gl = new Set([this]) : Gl.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function mo(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new ho; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Ac.bind(null, e, t, n), t.then(e, e)) } function go(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function vo(e, t, n, r, i) { return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Fa(-1, 1)).tag = 2, za(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e) } var bo = w.ReactCurrentOwner, yo = !1; function wo(e, t, n, r) { t.child = null === e ? xa(t, null, n, r) : wa(t, e.child, n, r) } function xo(e, t, n, r, i) { n = n.render; var a = t.ref; return Ta(t, i), r = ms(e, t, n, r, a, i), n = gs(), null === e || yo ? (ia && n && ea(t), t.flags |= 1, wo(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Vo(e, t, i)) } function _o(e, t, n, r, i) { if (null === e) { var a = n.type; return "function" !== typeof a || Nc(a) || void 0 !== a.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Ic(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = a, ko(e, t, a, r, i)) } if (a = e.child, 0 === (e.lanes & i)) { var s = a.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(s, r) && e.ref === t.ref) return Vo(e, t, i) } return t.flags |= 1, (e = Lc(a, r)).ref = t.ref, e.return = t, t.child = e } function ko(e, t, n, r, i) { if (null !== e) { var a = e.memoizedProps; if (lr(a, r) && e.ref === t.ref) { if (yo = !1, t.pendingProps = r = a, 0 === (e.lanes & i)) return t.lanes = e.lanes, Vo(e, t, i); 0 !== (131072 & e.flags) && (yo = !0) } } return Eo(e, t, n, r, i) } function So(e, t, n) { var r = t.pendingProps, i = r.children, a = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (0 === (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ei(Ll, Nl), Nl |= n; else { if (0 === (1073741824 & n)) return e = null !== a ? a.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ei(Ll, Nl), Nl |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== a ? a.baseLanes : n, Ei(Ll, Nl), Nl |= r } else null !== a ? (r = a.baseLanes | n, t.memoizedState = null) : r = n, Ei(Ll, Nl), Nl |= r; return wo(e, t, i, n), t.child } function Ao(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Eo(e, t, n, r, i) { var a = Ni(n) ? Pi : Mi.current; return a = Ri(t, a), Ta(t, i), n = ms(e, t, n, r, a, i), r = gs(), null === e || yo ? (ia && r && ea(t), t.flags |= 1, wo(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Vo(e, t, i)) } function Co(e, t, n, r, i) { if (Ni(n)) { var a = !0; Oi(t) } else a = !1; if (Ta(t, i), null === t.stateNode) Uo(e, t), ao(t, n, r), oo(t, n, r, i), r = !0; else if (null === e) { var s = t.stateNode, o = t.memoizedProps; s.props = o; var l = s.context, c = n.contextType; "object" === typeof c && null !== c ? c = Pa(c) : c = Ri(t, c = Ni(n) ? Pi : Mi.current); var u = n.getDerivedStateFromProps, d = "function" === typeof u || "function" === typeof s.getSnapshotBeforeUpdate; d || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (o !== r || l !== c) && so(t, s, r, c), Da = !1; var h = t.memoizedState; s.state = h, Ha(t, r, s, i), l = t.memoizedState, o !== r || h !== l || Ti.current || Da ? ("function" === typeof u && (no(t, n, u, r), l = t.memoizedState), (o = Da || io(t, n, o, r, h, l, c)) ? (d || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || ("function" === typeof s.componentWillMount && s.componentWillMount(), "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" === typeof s.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = c, r = o) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, ja(e, t), o = t.memoizedProps, c = t.type === t.elementType ? o : to(t.type, o), s.props = c, d = t.pendingProps, h = s.context, "object" === typeof (l = n.contextType) && null !== l ? l = Pa(l) : l = Ri(t, l = Ni(n) ? Pi : Mi.current); var f = n.getDerivedStateFromProps; (u = "function" === typeof f || "function" === typeof s.getSnapshotBeforeUpdate) || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (o !== d || h !== l) && so(t, s, r, l), Da = !1, h = t.memoizedState, s.state = h, Ha(t, r, s, i); var p = t.memoizedState; o !== d || h !== p || Ti.current || Da ? ("function" === typeof f && (no(t, n, f, r), p = t.memoizedState), (c = Da || io(t, n, c, r, h, p, l) || !1) ? (u || "function" !== typeof s.UNSAFE_componentWillUpdate && "function" !== typeof s.componentWillUpdate || ("function" === typeof s.componentWillUpdate && s.componentWillUpdate(r, p, l), "function" === typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, p, l)), "function" === typeof s.componentDidUpdate && (t.flags |= 4), "function" === typeof s.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof s.componentDidUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), s.props = r, s.state = p, s.context = l, r = c) : ("function" !== typeof s.componentDidUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return Mo(e, t, n, r, a, i) } function Mo(e, t, n, r, i, a) { Ao(e, t); var s = 0 !== (128 & t.flags); if (!r && !s) return i && ji(t, n, !1), Vo(e, t, a); r = t.stateNode, bo.current = t; var o = s && "function" !== typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && s ? (t.child = wa(t, e.child, null, a), t.child = wa(t, null, o, a)) : wo(e, t, o, a), t.memoizedState = r.state, i && ji(t, n, !0), t.child } function To(e) { var t = e.stateNode; t.pendingContext ? Ii(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Ii(0, t.context, !1), Ka(e, t.containerInfo) } function Po(e, t, n, r, i) { return fa(), pa(i), t.flags |= 256, wo(e, t, n, r), t.child } var Ro, No, Lo, Io, Do = { dehydrated: null, treeContext: null, retryLane: 0 }; function Oo(e) { return { baseLanes: e, cachePool: null, transitions: null } } function jo(e, t, n) { var r, i = t.pendingProps, s = Za.current, o = !1, l = 0 !== (128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & s)), r ? (o = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (s |= 1), Ei(Za, 1 & s), null === e) return ca(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, o ? (i = t.mode, o = t.child, l = { mode: "hidden", children: l }, 0 === (1 & i) && null !== o ? (o.childLanes = 0, o.pendingProps = l) : o = Oc(l, i, 0, null), e = Dc(e, i, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = Oo(n), t.memoizedState = Do, e) : Fo(t, l)); if (null !== (s = e.memoizedState) && null !== (r = s.dehydrated)) return function (e, t, n, r, i, s, o) { if (n) return 256 & t.flags ? (t.flags &= -257, zo(e, t, o, r = co(Error(a(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (s = r.fallback, i = t.mode, r = Oc({ mode: "visible", children: r.children }, i, 0, null), (s = Dc(s, i, o, null)).flags |= 2, r.return = t, s.return = t, r.sibling = s, t.child = r, 0 !== (1 & t.mode) && wa(t, e.child, null, o), t.child.memoizedState = Oo(o), t.memoizedState = Do, s); if (0 === (1 & t.mode)) return zo(e, t, o, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, zo(e, t, o, r = co(s = Error(a(419)), r, void 0)) } if (l = 0 !== (o & e.childLanes), yo || l) { if (null !== (r = Tl)) { switch (o & -o) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = 0 !== (i & (r.suspendedLanes | o)) ? 0 : i) && i !== s.retryLane && (s.retryLane = i, Ia(e, i), nc(r, e, i, -1)) } return mc(), zo(e, t, o, r = co(Error(a(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Cc.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, ra = ci(i.nextSibling), na = t, ia = !0, aa = null, null !== e && (Xi[Yi++] = Qi, Xi[Yi++] = $i, Xi[Yi++] = Ki, Qi = e.id, $i = e.overflow, Ki = t), t = Fo(t, r.children), t.flags |= 4096, t) }(e, t, l, i, r, s, n); if (o) { o = i.fallback, l = t.mode, r = (s = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 0 === (1 & l) && t.child !== s ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Lc(s, c)).subtreeFlags = 14680064 & s.subtreeFlags, null !== r ? o = Lc(r, o) : (o = Dc(o, l, n, null)).flags |= 2, o.return = t, i.return = t, i.sibling = o, t.child = i, i = o, o = t.child, l = null === (l = e.child.memoizedState) ? Oo(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, o.memoizedState = l, o.childLanes = e.childLanes & ~n, t.memoizedState = Do, i } return e = (o = e.child).sibling, i = Lc(o, { mode: "visible", children: i.children }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Fo(e, t) { return (t = Oc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function zo(e, t, n, r) { return null !== r && pa(r), wa(t, e.child, null, n), (e = Fo(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Wo(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), Ma(e.return, t, n) } function Bo(e, t, n, r, i) { var a = e.memoizedState; null === a ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (a.isBackwards = t, a.rendering = null, a.renderingStartTime = 0, a.last = r, a.tail = n, a.tailMode = i) } function Ho(e, t, n) { var r = t.pendingProps, i = r.revealOrder, a = r.tail; if (wo(e, t, r.children, n), 0 !== (2 & (r = Za.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Wo(e, n, t); else if (19 === e.tag) Wo(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ei(Za, r), 0 === (1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === es(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Bo(t, !1, i, n, a); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === es(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Bo(t, !0, n, null, a); break; case "together": Bo(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Uo(e, t) { 0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Vo(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), Ol |= t.lanes, 0 === (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(a(153)); if (null !== t.child) { for (n = Lc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Lc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function qo(e, t) { if (!ia) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Go(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Xo(e, t, n) { var r = t.pendingProps; switch (ta(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Go(t), null; case 1: case 17: return Ni(t.type) && Li(), Go(t), null; case 3: return r = t.stateNode, Qa(), Ai(Ti), Ai(Mi), ns(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (da(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== aa && (sc(aa), aa = null))), No(e, t), Go(t), null; case 5: Ja(t); var i = Ya(Xa.current); if (n = t.type, null !== e && null != t.stateNode) Lo(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(a(166)); return Go(t), null } if (e = Ya(qa.current), da(t)) { r = t.stateNode, n = t.type; var s = t.memoizedProps; switch (r[hi] = t, r[fi] = s, e = 0 !== (1 & t.mode), n) { case "dialog": zr("cancel", r), zr("close", r); break; case "iframe": case "object": case "embed": zr("load", r); break; case "video": case "audio": for (i = 0; i < Dr.length; i++)zr(Dr[i], r); break; case "source": zr("error", r); break; case "img": case "image": case "link": zr("error", r), zr("load", r); break; case "details": zr("toggle", r); break; case "input": Q(r, s), zr("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, zr("invalid", r); break; case "textarea": ie(r, s), zr("invalid", r) }for (var l in be(n, s), i = null, s) if (s.hasOwnProperty(l)) { var c = s[l]; "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== s.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== s.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", "" + c]) : o.hasOwnProperty(l) && null != c && "onScroll" === l && zr("scroll", r) } switch (n) { case "input": G(r), Z(r, s, !0); break; case "textarea": G(r), se(r); break; case "select": case "option": break; default: "function" === typeof s.onClick && (r.onclick = Zr) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = oe(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[fi] = r, Ro(e, t, !1, !1), t.stateNode = e; e: { switch (l = ye(n, r), n) { case "dialog": zr("cancel", e), zr("close", e), i = r; break; case "iframe": case "object": case "embed": zr("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Dr.length; i++)zr(Dr[i], e); i = r; break; case "source": zr("error", e), i = r; break; case "img": case "image": case "link": zr("error", e), zr("load", e), i = r; break; case "details": zr("toggle", e), i = r; break; case "input": Q(e, r), i = K(e, r), zr("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = j({}, r, { value: void 0 }), zr("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), zr("invalid", e) }for (s in be(n, i), c = i) if (c.hasOwnProperty(s)) { var u = c[s]; "style" === s ? ge(e, u) : "dangerouslySetInnerHTML" === s ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === s ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== s && "suppressHydrationWarning" !== s && "autoFocus" !== s && (o.hasOwnProperty(s) ? null != u && "onScroll" === s && zr("scroll", e) : null != u && y(e, s, u, l)) } switch (n) { case "input": G(e), Z(e, r, !1); break; case "textarea": G(e), se(e); break; case "option": null != r.value && e.setAttribute("value", "" + V(r.value)); break; case "select": e.multiple = !!r.multiple, null != (s = r.value) ? ne(e, !!r.multiple, s, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" === typeof i.onClick && (e.onclick = Zr) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Go(t), null; case 6: if (e && null != t.stateNode) Io(e, t, e.memoizedProps, r); else { if ("string" !== typeof r && null === t.stateNode) throw Error(a(166)); if (n = Ya(Xa.current), Ya(qa.current), da(t)) { if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (s = r.nodeValue !== n) && null !== (e = na)) switch (e.tag) { case 3: Jr(r.nodeValue, n, 0 !== (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Jr(r.nodeValue, n, 0 !== (1 & e.mode)) }s && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r } return Go(t), null; case 13: if (Ai(Za), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (ia && null !== ra && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) ha(), fa(), t.flags |= 98560, s = !1; else if (s = da(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!s) throw Error(a(318)); if (!(s = null !== (s = t.memoizedState) ? s.dehydrated : null)) throw Error(a(317)); s[hi] = t } else fa(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Go(t), s = !1 } else null !== aa && (sc(aa), aa = null), s = !0; if (!s) return 65536 & t.flags ? t : null } return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & Za.current) ? 0 === Il && (Il = 3) : mc())), null !== t.updateQueue && (t.flags |= 4), Go(t), null); case 4: return Qa(), No(e, t), null === e && Hr(t.stateNode.containerInfo), Go(t), null; case 10: return Ca(t.type._context), Go(t), null; case 19: if (Ai(Za), null === (s = t.memoizedState)) return Go(t), null; if (r = 0 !== (128 & t.flags), null === (l = s.rendering)) if (r) qo(s, !1); else { if (0 !== Il || null !== e && 0 !== (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = es(e))) { for (t.flags |= 128, qo(s, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (s = n).flags &= 14680066, null === (l = s.alternate) ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = l.childLanes, s.lanes = l.lanes, s.child = l.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = l.memoizedProps, s.memoizedState = l.memoizedState, s.updateQueue = l.updateQueue, s.type = l.type, e = l.dependencies, s.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ei(Za, 1 & Za.current | 2), t.child } e = e.sibling } null !== s.tail && $e() > Hl && (t.flags |= 128, r = !0, qo(s, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = es(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), qo(s, !0), null === s.tail && "hidden" === s.tailMode && !l.alternate && !ia) return Go(t), null } else 2 * $e() - s.renderingStartTime > Hl && 1073741824 !== n && (t.flags |= 128, r = !0, qo(s, !1), t.lanes = 4194304); s.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = s.last) ? n.sibling = l : t.child = l, s.last = l) } return null !== s.tail ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = $e(), t.sibling = null, n = Za.current, Ei(Za, r ? 1 & n | 2 : 1 & n), t) : (Go(t), null); case 22: case 23: return dc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Nl) && (Go(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Go(t), null; case 24: case 25: return null }throw Error(a(156, t.tag)) } function Yo(e, t) { switch (ta(t), t.tag) { case 1: return Ni(t.type) && Li(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return Qa(), Ai(Ti), Ai(Mi), ns(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return Ja(t), null; case 13: if (Ai(Za), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(a(340)); fa() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return Ai(Za), null; case 4: return Qa(), null; case 10: return Ca(t.type._context), null; case 22: case 23: return dc(), null; default: return null } } Ro = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, No = function () { }, Lo = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Ya(qa.current); var a, s = null; switch (n) { case "input": i = K(e, i), r = K(e, r), s = []; break; case "select": i = j({}, i, { value: void 0 }), r = j({}, r, { value: void 0 }), s = []; break; case "textarea": i = re(e, i), r = re(e, r), s = []; break; default: "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = Zr) }for (u in be(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (a in l) l.hasOwnProperty(a) && (n || (n = {}), n[a] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (o.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (a in l) !l.hasOwnProperty(a) || c && c.hasOwnProperty(a) || (n || (n = {}), n[a] = ""); for (a in c) c.hasOwnProperty(a) && l[a] !== c[a] && (n || (n = {}), n[a] = c[a]) } else n || (s || (s = []), s.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (s = s || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (s = s || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (o.hasOwnProperty(u) ? (null != c && "onScroll" === u && zr("scroll", e), s || l === c || (s = [])) : (s = s || []).push(u, c)) } n && (s = s || []).push("style", n); var u = s; (t.updateQueue = u) && (t.flags |= 4) } }, Io = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Ko = !1, Qo = !1, $o = "function" === typeof WeakSet ? WeakSet : Set, Jo = null; function Zo(e, t) { var n = e.ref; if (null !== n) if ("function" === typeof n) try { n(null) } catch (r) { Sc(e, t, r) } else n.current = null } function el(e, t, n) { try { n() } catch (r) { Sc(e, t, r) } } var tl = !1; function nl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var a = i.destroy; i.destroy = void 0, void 0 !== a && el(t, n, a) } i = i.next } while (i !== r) } } function rl(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function il(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" === typeof t ? t(e) : t.current = e } } function al(e) { var t = e.alternate; null !== t && (e.alternate = null, al(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[fi], delete t[mi], delete t[gi], delete t[vi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function sl(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ol(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || sl(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function ll(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Zr)); else if (4 !== r && null !== (e = e.child)) for (ll(e, t, n), e = e.sibling; null !== e;)ll(e, t, n), e = e.sibling } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } var ul = null, dl = !1; function hl(e, t, n) { for (n = n.child; null !== n;)fl(e, t, n), n = n.sibling } function fl(e, t, n) { if (at && "function" === typeof at.onCommitFiberUnmount) try { at.onCommitFiberUnmount(it, n) } catch (o) { } switch (n.tag) { case 5: Qo || Zo(n, t); case 6: var r = ul, i = dl; ul = null, hl(e, t, n), dl = i, null !== (ul = r) && (dl ? (e = ul, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : ul.removeChild(n.stateNode)); break; case 18: null !== ul && (dl ? (e = ul, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), Ht(e)) : li(ul, n.stateNode)); break; case 4: r = ul, i = dl, ul = n.stateNode.containerInfo, dl = !0, hl(e, t, n), ul = r, dl = i; break; case 0: case 11: case 14: case 15: if (!Qo && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) { i = r = r.next; do { var a = i, s = a.destroy; a = a.tag, void 0 !== s && (0 !== (2 & a) || 0 !== (4 & a)) && el(n, t, s), i = i.next } while (i !== r) } hl(e, t, n); break; case 1: if (!Qo && (Zo(n, t), "function" === typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (o) { Sc(n, t, o) } hl(e, t, n); break; case 21: hl(e, t, n); break; case 22: 1 & n.mode ? (Qo = (r = Qo) || null !== n.memoizedState, hl(e, t, n), Qo = r) : hl(e, t, n); break; default: hl(e, t, n) } } function pl(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new $o), t.forEach((function (t) { var r = Mc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function ml(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var s = e, o = t, l = o; e: for (; null !== l;) { switch (l.tag) { case 5: ul = l.stateNode, dl = !1; break e; case 3: case 4: ul = l.stateNode.containerInfo, dl = !0; break e }l = l.return } if (null === ul) throw Error(a(160)); fl(s, o, i), ul = null, dl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (u) { Sc(i, t, u) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)gl(t, e), t = t.sibling } function gl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (ml(t, e), vl(e), 4 & r) { try { nl(3, e, e.return), rl(3, e) } catch (g) { Sc(e, e.return, g) } try { nl(5, e, e.return) } catch (g) { Sc(e, e.return, g) } } break; case 1: ml(t, e), vl(e), 512 & r && null !== n && Zo(n, n.return); break; case 5: if (ml(t, e), vl(e), 512 & r && null !== n && Zo(n, n.return), 32 & e.flags) { var i = e.stateNode; try { he(i, "") } catch (g) { Sc(e, e.return, g) } } if (4 & r && null != (i = e.stateNode)) { var s = e.memoizedProps, o = null !== n ? n.memoizedProps : s, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === s.type && null != s.name && $(i, s), ye(l, o); var u = ye(l, s); for (o = 0; o < c.length; o += 2) { var d = c[o], h = c[o + 1]; "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : y(i, d, h, u) } switch (l) { case "input": J(i, s); break; case "textarea": ae(i, s); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var p = s.value; null != p ? ne(i, !!s.multiple, p, !1) : f !== !!s.multiple && (null != s.defaultValue ? ne(i, !!s.multiple, s.defaultValue, !0) : ne(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[fi] = s } catch (g) { Sc(e, e.return, g) } } break; case 6: if (ml(t, e), vl(e), 4 & r) { if (null === e.stateNode) throw Error(a(162)); i = e.stateNode, s = e.memoizedProps; try { i.nodeValue = s } catch (g) { Sc(e, e.return, g) } } break; case 3: if (ml(t, e), vl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { Ht(t.containerInfo) } catch (g) { Sc(e, e.return, g) } break; case 4: default: ml(t, e), vl(e); break; case 13: ml(t, e), vl(e), 8192 & (i = e.child).flags && (s = null !== i.memoizedState, i.stateNode.isHidden = s, !s || null !== i.alternate && null !== i.alternate.memoizedState || (Bl = $e())), 4 & r && pl(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Qo = (u = Qo) || d, ml(t, e), Qo = u) : ml(t, e), vl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode)) for (Jo = e, d = e.child; null !== d;) { for (h = Jo = d; null !== Jo;) { switch (p = (f = Jo).child, f.tag) { case 0: case 11: case 14: case 15: nl(4, f, f.return); break; case 1: Zo(f, f.return); var m = f.stateNode; if ("function" === typeof m.componentWillUnmount) { r = f, n = f.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (g) { Sc(r, n, g) } } break; case 5: Zo(f, f.return); break; case 22: if (null !== f.memoizedState) { xl(h); continue } }null !== p ? (p.return = f, Jo = p) : xl(h) } d = d.sibling } e: for (d = null, h = e; ;) { if (5 === h.tag) { if (null === d) { d = h; try { i = h.stateNode, u ? "function" === typeof (s = i.style).setProperty ? s.setProperty("display", "none", "important") : s.display = "none" : (l = h.stateNode, o = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", o)) } catch (g) { Sc(e, e.return, g) } } } else if (6 === h.tag) { if (null === d) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (g) { Sc(e, e.return, g) } } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) { h.child.return = h, h = h.child; continue } if (h === e) break e; for (; null === h.sibling;) { if (null === h.return || h.return === e) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: ml(t, e), vl(e), 4 & r && pl(e); case 21: } } function vl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (sl(n)) { var r = n; break e } n = n.return } throw Error(a(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (he(i, ""), r.flags &= -33), cl(e, ol(e), i); break; case 3: case 4: var s = r.stateNode.containerInfo; ll(e, ol(e), s); break; default: throw Error(a(161)) } } catch (o) { Sc(e, e.return, o) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function bl(e, t, n) { Jo = e, yl(e, t, n) } function yl(e, t, n) { for (var r = 0 !== (1 & e.mode); null !== Jo;) { var i = Jo, a = i.child; if (22 === i.tag && r) { var s = null !== i.memoizedState || Ko; if (!s) { var o = i.alternate, l = null !== o && null !== o.memoizedState || Qo; o = Ko; var c = Qo; if (Ko = s, (Qo = l) && !c) for (Jo = i; null !== Jo;)l = (s = Jo).child, 22 === s.tag && null !== s.memoizedState ? _l(i) : null !== l ? (l.return = s, Jo = l) : _l(i); for (; null !== a;)Jo = a, yl(a, t, n), a = a.sibling; Jo = i, Ko = o, Qo = c } wl(e) } else 0 !== (8772 & i.subtreeFlags) && null !== a ? (a.return = i, Jo = a) : wl(e) } } function wl(e) { for (; null !== Jo;) { var t = Jo; if (0 !== (8772 & t.flags)) { var n = t.alternate; try { if (0 !== (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: Qo || rl(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !Qo) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : to(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = t.updateQueue; null !== s && Ua(t, s, r); break; case 3: var o = t.updateQueue; if (null !== o) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }Ua(t, o, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var h = d.dehydrated; null !== h && Ht(h) } } } break; default: throw Error(a(163)) }Qo || 512 & t.flags && il(t) } catch (f) { Sc(t, t.return, f) } } if (t === e) { Jo = null; break } if (null !== (n = t.sibling)) { n.return = t.return, Jo = n; break } Jo = t.return } } function xl(e) { for (; null !== Jo;) { var t = Jo; if (t === e) { Jo = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, Jo = n; break } Jo = t.return } } function _l(e) { for (; null !== Jo;) { var t = Jo; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { rl(4, t) } catch (l) { Sc(t, n, l) } break; case 1: var r = t.stateNode; if ("function" === typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (l) { Sc(t, i, l) } } var a = t.return; try { il(t) } catch (l) { Sc(t, a, l) } break; case 5: var s = t.return; try { il(t) } catch (l) { Sc(t, s, l) } } } catch (l) { Sc(t, t.return, l) } if (t === e) { Jo = null; break } var o = t.sibling; if (null !== o) { o.return = t.return, Jo = o; break } Jo = t.return } } var kl, Sl = Math.ceil, Al = w.ReactCurrentDispatcher, El = w.ReactCurrentOwner, Cl = w.ReactCurrentBatchConfig, Ml = 0, Tl = null, Pl = null, Rl = 0, Nl = 0, Ll = Si(0), Il = 0, Dl = null, Ol = 0, jl = 0, Fl = 0, zl = null, Wl = null, Bl = 0, Hl = 1 / 0, Ul = null, Vl = !1, ql = null, Gl = null, Xl = !1, Yl = null, Kl = 0, Ql = 0, $l = null, Jl = -1, Zl = 0; function ec() { return 0 !== (6 & Ml) ? $e() : -1 !== Jl ? Jl : Jl = $e() } function tc(e) { return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Ml) && 0 !== Rl ? Rl & -Rl : null !== ma.transition ? (0 === Zl && (Zl = mt()), Zl) : 0 !== (e = yt) ? e : e = void 0 === (e = window.event) ? 16 : Qt(e.type) } function nc(e, t, n, r) { if (50 < Ql) throw Ql = 0, $l = null, Error(a(185)); vt(e, n, r), 0 !== (2 & Ml) && e === Tl || (e === Tl && (0 === (2 & Ml) && (jl |= n), 4 === Il && oc(e, Rl)), rc(e, r), 1 === n && 0 === Ml && 0 === (1 & t.mode) && (Hl = $e() + 500, zi && Hi())) } function rc(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, a = e.pendingLanes; 0 < a;) { var s = 31 - st(a), o = 1 << s, l = i[s]; -1 === l ? 0 !== (o & n) && 0 === (o & r) || (i[s] = ft(o, t)) : l <= t && (e.expiredLanes |= o), a &= ~o } }(e, t); var r = ht(e, e === Tl ? Rl : 0); if (0 === r) null !== n && Ye(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && Ye(n), 1 === t) 0 === e.tag ? function (e) { zi = !0, Bi(e) }(lc.bind(null, e)) : Bi(lc.bind(null, e)), si((function () { 0 === (6 & Ml) && Hi() })), n = null; else { switch (wt(r)) { case 1: n = Ze; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Tc(n, ic.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function ic(e, t) { if (Jl = -1, Zl = 0, 0 !== (6 & Ml)) throw Error(a(327)); var n = e.callbackNode; if (_c() && e.callbackNode !== n) return null; var r = ht(e, e === Tl ? Rl : 0); if (0 === r) return null; if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = gc(e, r); else { t = r; var i = Ml; Ml |= 2; var s = pc(); for (Tl === e && Rl === t || (Ul = null, Hl = $e() + 500, hc(e, t)); ;)try { bc(); break } catch (l) { fc(e, l) } Ea(), Al.current = s, Ml = i, null !== Pl ? t = 0 : (Tl = null, Rl = 0, t = Il) } if (0 !== t) { if (2 === t && (0 !== (i = pt(e)) && (r = i, t = ac(e, i))), 1 === t) throw n = Dl, hc(e, 0), oc(e, r), rc(e, $e()), n; if (6 === t) oc(e, r); else { if (i = e.current.alternate, 0 === (30 & r) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], a = i.getSnapshot; i = i.value; try { if (!or(a(), i)) return !1 } catch (o) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) && (2 === (t = gc(e, r)) && (0 !== (s = pt(e)) && (r = s, t = ac(e, s))), 1 === t)) throw n = Dl, hc(e, 0), oc(e, r), rc(e, $e()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(a(345)); case 2: case 5: xc(e, Wl, Ul); break; case 3: if (oc(e, r), (130023424 & r) === r && 10 < (t = Bl + 500 - $e())) { if (0 !== ht(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { ec(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(xc.bind(null, e, Wl, Ul), t); break } xc(e, Wl, Ul); break; case 4: if (oc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var o = 31 - st(r); s = 1 << o, (o = t[o]) > i && (i = o), r &= ~s } if (r = i, 10 < (r = (120 > (r = $e() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Sl(r / 1960)) - r)) { e.timeoutHandle = ri(xc.bind(null, e, Wl, Ul), r); break } xc(e, Wl, Ul); break; default: throw Error(a(329)) } } } return rc(e, $e()), e.callbackNode === n ? ic.bind(null, e) : null } function ac(e, t) { var n = zl; return e.current.memoizedState.isDehydrated && (hc(e, t).flags |= 256), 2 !== (e = gc(e, t)) && (t = Wl, Wl = n, null !== t && sc(t)), e } function sc(e) { null === Wl ? Wl = e : Wl.push.apply(Wl, e) } function oc(e, t) { for (t &= ~Fl, t &= ~jl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - st(t), r = 1 << n; e[n] = -1, t &= ~r } } function lc(e) { if (0 !== (6 & Ml)) throw Error(a(327)); _c(); var t = ht(e, 0); if (0 === (1 & t)) return rc(e, $e()), null; var n = gc(e, t); if (0 !== e.tag && 2 === n) { var r = pt(e); 0 !== r && (t = r, n = ac(e, r)) } if (1 === n) throw n = Dl, hc(e, 0), oc(e, t), rc(e, $e()), n; if (6 === n) throw Error(a(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, xc(e, Wl, Ul), rc(e, $e()), null } function cc(e, t) { var n = Ml; Ml |= 1; try { return e(t) } finally { 0 === (Ml = n) && (Hl = $e() + 500, zi && Hi()) } } function uc(e) { null !== Yl && 0 === Yl.tag && 0 === (6 & Ml) && _c(); var t = Ml; Ml |= 1; var n = Cl.transition, r = yt; try { if (Cl.transition = null, yt = 1, e) return e() } finally { yt = r, Cl.transition = n, 0 === (6 & (Ml = t)) && Hi() } } function dc() { Nl = Ll.current, Ai(Ll) } function hc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Pl) for (n = Pl.return; null !== n;) { var r = n; switch (ta(r), r.tag) { case 1: null !== (r = r.type.childContextTypes) && void 0 !== r && Li(); break; case 3: Qa(), Ai(Ti), Ai(Mi), ns(); break; case 5: Ja(r); break; case 4: Qa(); break; case 13: case 19: Ai(Za); break; case 10: Ca(r.type._context); break; case 22: case 23: dc() }n = n.return } if (Tl = e, Pl = e = Lc(e.current, null), Rl = Nl = t, Il = 0, Dl = null, Fl = jl = Ol = 0, Wl = zl = null, null !== Ra) { for (t = 0; t < Ra.length; t++)if (null !== (r = (n = Ra[t]).interleaved)) { n.interleaved = null; var i = r.next, a = n.pending; if (null !== a) { var s = a.next; a.next = i, r.next = s } n.pending = r } Ra = null } return e } function fc(e, t) { for (; ;) { var n = Pl; try { if (Ea(), rs.current = $s, cs) { for (var r = ss.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } cs = !1 } if (as = 0, ls = os = ss = null, us = !1, ds = 0, El.current = null, null === n || null === n.return) { Il = 1, Dl = t, Pl = null; break } e: { var s = e, o = n.return, l = n, c = t; if (t = Rl, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) { var u = c, d = l, h = d.tag; if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) { var f = d.alternate; f ? (d.updateQueue = f.updateQueue, d.memoizedState = f.memoizedState, d.lanes = f.lanes) : (d.updateQueue = null, d.memoizedState = null) } var p = go(o); if (null !== p) { p.flags &= -257, vo(p, o, l, 0, t), 1 & p.mode && mo(s, u, t), c = u; var m = (t = p).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (0 === (1 & t)) { mo(s, u, t), mc(); break e } c = Error(a(426)) } else if (ia && 1 & l.mode) { var v = go(o); if (null !== v) { 0 === (65536 & v.flags) && (v.flags |= 256), vo(v, o, l, 0, t), pa(lo(c, l)); break e } } s = c = lo(c, l), 4 !== Il && (Il = 2), null === zl ? zl = [s] : zl.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, t &= -t, s.lanes |= t, Ba(s, fo(0, c, t)); break e; case 1: l = c; var b = s.type, y = s.stateNode; if (0 === (128 & s.flags) && ("function" === typeof b.getDerivedStateFromError || null !== y && "function" === typeof y.componentDidCatch && (null === Gl || !Gl.has(y)))) { s.flags |= 65536, t &= -t, s.lanes |= t, Ba(s, po(s, l, t)); break e } }s = s.return } while (null !== s) } wc(n) } catch (w) { t = w, Pl === n && null !== n && (Pl = n = n.return); continue } break } } function pc() { var e = Al.current; return Al.current = $s, null === e ? $s : e } function mc() { 0 !== Il && 3 !== Il && 2 !== Il || (Il = 4), null === Tl || 0 === (268435455 & Ol) && 0 === (268435455 & jl) || oc(Tl, Rl) } function gc(e, t) { var n = Ml; Ml |= 2; var r = pc(); for (Tl === e && Rl === t || (Ul = null, hc(e, t)); ;)try { vc(); break } catch (i) { fc(e, i) } if (Ea(), Ml = n, Al.current = r, null !== Pl) throw Error(a(261)); return Tl = null, Rl = 0, Il } function vc() { for (; null !== Pl;)yc(Pl) } function bc() { for (; null !== Pl && !Ke();)yc(Pl) } function yc(e) { var t = kl(e.alternate, e, Nl); e.memoizedProps = e.pendingProps, null === t ? wc(e) : Pl = t, El.current = null } function wc(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 === (32768 & t.flags)) { if (null !== (n = Xo(n, t, Nl))) return void (Pl = n) } else { if (null !== (n = Yo(n, t))) return n.flags &= 32767, void (Pl = n); if (null === e) return Il = 6, void (Pl = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Pl = t); Pl = t = e } while (null !== t); 0 === Il && (Il = 5) } function xc(e, t, n) { var r = yt, i = Cl.transition; try { Cl.transition = null, yt = 1, function (e, t, n, r) { do { _c() } while (null !== Yl); if (0 !== (6 & Ml)) throw Error(a(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(a(177)); e.callbackNode = null, e.callbackPriority = 0; var s = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - st(n), a = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~a } }(e, s), e === Tl && (Pl = Tl = null, Rl = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Xl || (Xl = !0, Tc(tt, (function () { return _c(), null }))), s = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || s) { s = Cl.transition, Cl.transition = null; var o = yt; yt = 1; var l = Ml; Ml |= 4, El.current = null, function (e, t) { if (ei = Vt, fr(e = hr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { n.nodeType, s.nodeType } catch (x) { n = null; break e } var o = 0, l = -1, c = -1, u = 0, d = 0, h = e, f = null; t: for (; ;) { for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (l = o + i), h !== s || 0 !== r && 3 !== h.nodeType || (c = o + r), 3 === h.nodeType && (o += h.nodeValue.length), null !== (p = h.firstChild);)f = h, h = p; for (; ;) { if (h === e) break t; if (f === n && ++u === i && (l = o), f === s && ++d === r && (c = o), null !== (p = h.nextSibling)) break; f = (h = f).parentNode } h = p } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Vt = !1, Jo = t; null !== Jo;)if (e = (t = Jo).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, Jo = e; else for (; null !== Jo;) { t = Jo; try { var m = t.alternate; if (0 !== (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, v = m.memoizedState, b = t.stateNode, y = b.getSnapshotBeforeUpdate(t.elementType === t.type ? g : to(t.type, g), v); b.__reactInternalSnapshotBeforeUpdate = y } break; case 3: var w = t.stateNode.containerInfo; 1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement); break; default: throw Error(a(163)) } } catch (x) { Sc(t, t.return, x) } if (null !== (e = t.sibling)) { e.return = t.return, Jo = e; break } Jo = t.return } m = tl, tl = !1 }(e, n), gl(n, e), pr(ti), Vt = !!ei, ti = ei = null, e.current = n, bl(n, e, i), Qe(), Ml = l, yt = o, Cl.transition = s } else e.current = n; if (Xl && (Xl = !1, Yl = e, Kl = i), s = e.pendingLanes, 0 === s && (Gl = null), function (e) { if (at && "function" === typeof at.onCommitFiberRoot) try { at.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags)) } catch (t) { } }(n.stateNode), rc(e, $e()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Vl) throw Vl = !1, e = ql, ql = null, e; 0 !== (1 & Kl) && 0 !== e.tag && _c(), s = e.pendingLanes, 0 !== (1 & s) ? e === $l ? Ql++ : (Ql = 0, $l = e) : Ql = 0, Hi() }(e, t, n, r) } finally { Cl.transition = i, yt = r } return null } function _c() { if (null !== Yl) { var e = wt(Kl), t = Cl.transition, n = yt; try { if (Cl.transition = null, yt = 16 > e ? 16 : e, null === Yl) var r = !1; else { if (e = Yl, Yl = null, Kl = 0, 0 !== (6 & Ml)) throw Error(a(331)); var i = Ml; for (Ml |= 4, Jo = e.current; null !== Jo;) { var s = Jo, o = s.child; if (0 !== (16 & Jo.flags)) { var l = s.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for (Jo = u; null !== Jo;) { var d = Jo; switch (d.tag) { case 0: case 11: case 15: nl(8, d, s) }var h = d.child; if (null !== h) h.return = d, Jo = h; else for (; null !== Jo;) { var f = (d = Jo).sibling, p = d.return; if (al(d), d === u) { Jo = null; break } if (null !== f) { f.return = p, Jo = f; break } Jo = p } } } var m = s.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var v = g.sibling; g.sibling = null, g = v } while (null !== g) } } Jo = s } } if (0 !== (2064 & s.subtreeFlags) && null !== o) o.return = s, Jo = o; else e: for (; null !== Jo;) { if (0 !== (2048 & (s = Jo).flags)) switch (s.tag) { case 0: case 11: case 15: nl(9, s, s.return) }var b = s.sibling; if (null !== b) { b.return = s.return, Jo = b; break e } Jo = s.return } } var y = e.current; for (Jo = y; null !== Jo;) { var w = (o = Jo).child; if (0 !== (2064 & o.subtreeFlags) && null !== w) w.return = o, Jo = w; else e: for (o = y; null !== Jo;) { if (0 !== (2048 & (l = Jo).flags)) try { switch (l.tag) { case 0: case 11: case 15: rl(9, l) } } catch (_) { Sc(l, l.return, _) } if (l === o) { Jo = null; break e } var x = l.sibling; if (null !== x) { x.return = l.return, Jo = x; break e } Jo = l.return } } if (Ml = i, Hi(), at && "function" === typeof at.onPostCommitFiberRoot) try { at.onPostCommitFiberRoot(it, e) } catch (_) { } r = !0 } return r } finally { yt = n, Cl.transition = t } } return !1 } function kc(e, t, n) { e = za(e, t = fo(0, t = lo(n, t), 1), 1), t = ec(), null !== e && (vt(e, 1, t), rc(e, t)) } function Sc(e, t, n) { if (3 === e.tag) kc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { kc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Gl || !Gl.has(r))) { t = za(t, e = po(t, e = lo(n, e), 1), 1), e = ec(), null !== t && (vt(t, 1, e), rc(t, e)); break } } t = t.return } } function Ac(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = ec(), e.pingedLanes |= e.suspendedLanes & n, Tl === e && (Rl & n) === n && (4 === Il || 3 === Il && (130023424 & Rl) === Rl && 500 > $e() - Bl ? hc(e, 0) : Fl |= n), rc(e, t) } function Ec(e, t) { 0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = ec(); null !== (e = Ia(e, t)) && (vt(e, t, n), rc(e, n)) } function Cc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Ec(e, n) } function Mc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(a(314)) }null !== r && r.delete(t), Ec(e, n) } function Tc(e, t) { return Xe(e, t) } function Pc(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Rc(e, t, n, r) { return new Pc(e, t, n, r) } function Nc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Lc(e, t) { var n = e.alternate; return null === n ? ((n = Rc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Ic(e, t, n, r, i, s) { var o = 2; if (r = e, "function" === typeof e) Nc(e) && (o = 1); else if ("string" === typeof e) o = 5; else e: switch (e) { case k: return Dc(n.children, i, s, t); case S: o = 8, i |= 8; break; case A: return (e = Rc(12, n, t, 2 | i)).elementType = A, e.lanes = s, e; case T: return (e = Rc(13, n, t, i)).elementType = T, e.lanes = s, e; case P: return (e = Rc(19, n, t, i)).elementType = P, e.lanes = s, e; case L: return Oc(n, i, s, t); default: if ("object" === typeof e && null !== e) switch (e.$$typeof) { case E: o = 10; break e; case C: o = 9; break e; case M: o = 11; break e; case R: o = 14; break e; case N: o = 16, r = null; break e }throw Error(a(130, null == e ? e : typeof e, "")) }return (t = Rc(o, n, t, i)).elementType = e, t.type = r, t.lanes = s, t } function Dc(e, t, n, r) { return (e = Rc(7, e, r, t)).lanes = n, e } function Oc(e, t, n, r) { return (e = Rc(22, e, r, t)).elementType = L, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function jc(e, t, n) { return (e = Rc(6, e, null, t)).lanes = n, e } function Fc(e, t, n) { return (t = Rc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function zc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Wc(e, t, n, r, i, a, s, o, l) { return e = new zc(e, t, n, o, l), 1 === t ? (t = 1, !0 === a && (t |= 8)) : t = 0, a = Rc(3, null, null, t), e.current = a, a.stateNode = e, a.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Oa(a), e } function Bc(e) { if (!e) return Ci; e: { if (He(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(a(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ni(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(a(171)) } if (1 === e.tag) { var n = e.type; if (Ni(n)) return Di(e, n, t) } return t } function Hc(e, t, n, r, i, a, s, o, l) { return (e = Wc(n, r, !0, e, 0, a, 0, o, l)).context = Bc(null), n = e.current, (a = Fa(r = ec(), i = tc(n))).callback = void 0 !== t && null !== t ? t : null, za(n, a, i), e.current.lanes = i, vt(e, i, r), rc(e, r), e } function Uc(e, t, n, r) { var i = t.current, a = ec(), s = tc(i); return n = Bc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Fa(a, s)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = za(i, t, s)) && (nc(e, i, s, a), Wa(e, i, s)), s } function Vc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function qc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Gc(e, t) { qc(e, t), (e = e.alternate) && qc(e, t) } kl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Ti.current) yo = !0; else { if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return yo = !1, function (e, t, n) { switch (t.tag) { case 3: To(t), fa(); break; case 5: $a(t); break; case 1: Ni(t.type) && Oi(t); break; case 4: Ka(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ei(_a, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ei(Za, 1 & Za.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? jo(e, t, n) : (Ei(Za, 1 & Za.current), null !== (e = Vo(e, t, n)) ? e.sibling : null); Ei(Za, 1 & Za.current); break; case 19: if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) { if (r) return Ho(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ei(Za, Za.current), r) break; return null; case 22: case 23: return t.lanes = 0, So(e, t, n) }return Vo(e, t, n) }(e, t, n); yo = 0 !== (131072 & e.flags) } else yo = !1, ia && 0 !== (1048576 & t.flags) && Zi(t, Gi, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Uo(e, t), e = t.pendingProps; var i = Ri(t, Mi.current); Ta(t, n), i = ms(null, t, r, e, i, n); var s = gs(); return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ni(r) ? (s = !0, Oi(t)) : s = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Oa(t), i.updater = ro, t.stateNode = i, i._reactInternals = t, oo(t, r, e, n), t = Mo(null, t, r, !0, s, n)) : (t.tag = 0, ia && s && ea(t), wo(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Uo(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" === typeof e) return Nc(e) ? 1 : 0; if (void 0 !== e && null !== e) { if ((e = e.$$typeof) === M) return 11; if (e === R) return 14 } return 2 }(r), e = to(r, e), i) { case 0: t = Eo(null, t, r, e, n); break e; case 1: t = Co(null, t, r, e, n); break e; case 11: t = xo(null, t, r, e, n); break e; case 14: t = _o(null, t, r, to(r.type, e), n); break e }throw Error(a(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, Eo(e, t, r, i = t.elementType === r ? i : to(r, i), n); case 1: return r = t.type, i = t.pendingProps, Co(e, t, r, i = t.elementType === r ? i : to(r, i), n); case 3: e: { if (To(t), null === e) throw Error(a(387)); r = t.pendingProps, i = (s = t.memoizedState).element, ja(e, t), Ha(t, r, null, n); var o = t.memoizedState; if (r = o.element, s.isDehydrated) { if (s = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = s, t.memoizedState = s, 256 & t.flags) { t = Po(e, t, r, n, i = lo(Error(a(423)), t)); break e } if (r !== i) { t = Po(e, t, r, n, i = lo(Error(a(424)), t)); break e } for (ra = ci(t.stateNode.containerInfo.firstChild), na = t, ia = !0, aa = null, n = xa(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (fa(), r === i) { t = Vo(e, t, n); break e } wo(e, t, r, n) } t = t.child } return t; case 5: return $a(t), null === e && ca(t), r = t.type, i = t.pendingProps, s = null !== e ? e.memoizedProps : null, o = i.children, ni(r, i) ? o = null : null !== s && ni(r, s) && (t.flags |= 32), Ao(e, t), wo(e, t, o, n), t.child; case 6: return null === e && ca(t), null; case 13: return jo(e, t, n); case 4: return Ka(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = wa(t, null, r, n) : wo(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, xo(e, t, r, i = t.elementType === r ? i : to(r, i), n); case 7: return wo(e, t, t.pendingProps, n), t.child; case 8: case 12: return wo(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, s = t.memoizedProps, o = i.value, Ei(_a, r._currentValue), r._currentValue = o, null !== s) if (or(s.value, o)) { if (s.children === i.children && !Ti.current) { t = Vo(e, t, n); break e } } else for (null !== (s = t.child) && (s.return = t); null !== s;) { var l = s.dependencies; if (null !== l) { o = s.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === s.tag) { (c = Fa(-1, n & -n)).tag = 2; var u = s.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } s.lanes |= n, null !== (c = s.alternate) && (c.lanes |= n), Ma(s.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === s.tag) o = s.type === t.type ? null : s.child; else if (18 === s.tag) { if (null === (o = s.return)) throw Error(a(341)); o.lanes |= n, null !== (l = o.alternate) && (l.lanes |= n), Ma(o, n, t), o = s.sibling } else o = s.child; if (null !== o) o.return = s; else for (o = s; null !== o;) { if (o === t) { o = null; break } if (null !== (s = o.sibling)) { s.return = o.return, o = s; break } o = o.return } s = o } wo(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Ta(t, n), r = r(i = Pa(i)), t.flags |= 1, wo(e, t, r, n), t.child; case 14: return i = to(r = t.type, t.pendingProps), _o(e, t, r, i = to(r.type, i), n); case 15: return ko(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : to(r, i), Uo(e, t), t.tag = 1, Ni(r) ? (e = !0, Oi(t)) : e = !1, Ta(t, n), ao(t, r, i), oo(t, r, i, n), Mo(null, t, r, !0, e, n); case 19: return Ho(e, t, n); case 22: return So(e, t, n) }throw Error(a(156, t.tag)) }; var Xc = "function" === typeof reportError ? reportError : function (e) { console.error(e) }; function Yc(e) { this._internalRoot = e } function Kc(e) { this._internalRoot = e } function Qc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function $c(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function Jc() { } function Zc(e, t, n, r, i) { var a = n._reactRootContainer; if (a) { var s = a; if ("function" === typeof i) { var o = i; i = function () { var e = Vc(s); o.call(e) } } Uc(t, s, e, i) } else s = function (e, t, n, r, i) { if (i) { if ("function" === typeof r) { var a = r; r = function () { var e = Vc(s); a.call(e) } } var s = Hc(t, r, e, 0, null, !1, 0, "", Jc); return e._reactRootContainer = s, e[pi] = s.current, Hr(8 === e.nodeType ? e.parentNode : e), uc(), s } for (; i = e.lastChild;)e.removeChild(i); if ("function" === typeof r) { var o = r; r = function () { var e = Vc(l); o.call(e) } } var l = Wc(e, 0, !1, null, 0, !1, 0, "", Jc); return e._reactRootContainer = l, e[pi] = l.current, Hr(8 === e.nodeType ? e.parentNode : e), uc((function () { Uc(t, l, n, r) })), l }(n, t, e, i, r); return Vc(s) } Kc.prototype.render = Yc.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(a(409)); Uc(e, t, null, null) }, Kc.prototype.unmount = Yc.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; uc((function () { Uc(null, e, null, null) })), t[pi] = null } }, Kc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = St(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Lt.length && 0 !== t && t < Lt[n].priority; n++); Lt.splice(n, 0, e), 0 === n && jt(e) } }, xt = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (bt(t, 1 | n), rc(t, $e()), 0 === (6 & Ml) && (Hl = $e() + 500, Hi())) } break; case 13: uc((function () { var t = Ia(e, 1); if (null !== t) { var n = ec(); nc(t, e, 1, n) } })), Gc(e, 1) } }, _t = function (e) { if (13 === e.tag) { var t = Ia(e, 134217728); if (null !== t) nc(t, e, 134217728, ec()); Gc(e, 134217728) } }, kt = function (e) { if (13 === e.tag) { var t = tc(e), n = Ia(e, t); if (null !== n) nc(n, e, t, ec()); Gc(e, t) } }, St = function () { return yt }, At = function (e, t) { var n = yt; try { return yt = e, t() } finally { yt = n } }, _e = function (e, t, n) { switch (t) { case "input": if (J(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = xi(r); if (!i) throw Error(a(90)); X(r), J(r, i) } } } break; case "textarea": ae(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, Me = cc, Te = uc; var eu = { usingClientEntryPoint: !1, Events: [yi, wi, xi, Ee, Ce, cc] }, tu = { findFiberByHostInstance: bi, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, nu = { bundleType: tu.bundleType, version: tu.version, rendererPackageName: tu.rendererPackageName, rendererConfig: tu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: w.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = qe(e)) ? null : e.stateNode }, findFiberByHostInstance: tu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var ru = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ru.isDisabled && ru.supportsFiber) try { it = ru.inject(nu), at = ru } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!Qc(t)) throw Error(a(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: _, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!Qc(e)) throw Error(a(299)); var n = !1, r = "", i = Xc; return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Wc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, Hr(8 === e.nodeType ? e.parentNode : e), new Yc(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" === typeof e.render) throw Error(a(188)); throw e = Object.keys(e).join(","), Error(a(268, e)) } return e = null === (e = qe(t)) ? null : e.stateNode }, t.flushSync = function (e) { return uc(e) }, t.hydrate = function (e, t, n) { if (!$c(t)) throw Error(a(200)); return Zc(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!Qc(e)) throw Error(a(405)); var r = null != n && n.hydratedSources || null, i = !1, s = "", o = Xc; if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (s = n.identifierPrefix), void 0 !== n.onRecoverableError && (o = n.onRecoverableError)), t = Hc(t, null, e, 1, null != n ? n : null, i, 0, s, o), e[pi] = t.current, Hr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Kc(t) }, t.render = function (e, t, n) { if (!$c(t)) throw Error(a(200)); return Zc(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!$c(e)) throw Error(a(40)); return !!e._reactRootContainer && (uc((function () { Zc(null, null, e, !1, (function () { e._reactRootContainer = null, e[pi] = null })) })), !0) }, t.unstable_batchedUpdates = cc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!$c(n)) throw Error(a(200)); if (null == e || void 0 === e._reactInternals) throw Error(a(38)); return Zc(e, t, n, !1, r) }, t.version = "18.3.1-next-f1338f8080-20240426" }, 391: (e, t, n) => { "use strict"; var r = n(950); t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot }, 950: (e, t, n) => { "use strict"; !function e() { if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } }(), e.exports = n(730) }, 360: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => { "use strict"; __webpack_require__.d(__webpack_exports__, { Es: () => Cloud, ci: () => renderSimpleIcon, fB: () => fetchSimpleIcons }); var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43), _csstools_convert_colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(299); function asyncGeneratorStep(e, t, n, r, i, a, s) { try { var o = e[a](s), l = o.value } catch (c) { return void n(c) } o.done ? t(l) : Promise.resolve(l).then(r, i) } function _asyncToGenerator(e) { return function () { var t = this, n = arguments; return new Promise((function (r, i) { var a = e.apply(t, n); function s(e) { asyncGeneratorStep(a, r, i, s, o, "next", e) } function o(e) { asyncGeneratorStep(a, r, i, s, o, "throw", e) } s(void 0) })) } } function _extends() { return _extends = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, _extends.apply(this, arguments) } var tagCanvasString = "(function(){\"use strict\"; var r,C,p=Math.abs,o=Math.sin,l=Math.cos,g=Math.max,h=Math.min,af=Math.ceil,E=Math.sqrt,w=Math.pow,I={},D={},R={0:\"0,\",1:\"17,\",2:\"34,\",3:\"51,\",4:\"68,\",5:\"85,\",6:\"102,\",7:\"119,\",8:\"136,\",9:\"153,\",a:\"170,\",A:\"170,\",b:\"187,\",B:\"187,\",c:\"204,\",C:\"204,\",d:\"221,\",D:\"221,\",e:\"238,\",E:\"238,\",f:\"255,\",F:\"255,\"},f,d,b,T,z,F,M,c=document,v,e,P,j={};for(r=0;r<256;++r)C=r.toString(16),r<16&&(C='0'+C),D[C]=D[C.toUpperCase()]=r.toString()+',';function n(a){return typeof a!='undefined'}function B(a){return typeof a=='object'&&a!=null}function G(a,c,b){return isNaN(a)?b:h(b,g(c,a))}function x(){return!1}function q(){return(new Date).valueOf()}function ak(c,d){var b=[],e=c.length,a;for(a=0;a<e;++a)b.push(c[a]);return b.sort(d),b}function ai(a){for(var b=a.length-1,d,c;b;)c=~~(Math.random()*b),d=a[b],a[b]=a[c],a[c]=d,--b}function ag(){var a=window.AudioContext||window.webkitAudioContext;if(e=new a,!e){e='off';return}return e}function $(u,a,t,s,r,q,p){var j=s,h=r,i=t*.01,n=80*i,m=100*i,o=40*i,l=30*i,c=l/2,b=j+n,f=b-o,k=h+m,d=k-l,g=h+l,e=h+m/2;if(a.setTransform(1,0,0,1,0,0),a.setLineDash([]),a.globalAlpha=1,a.strokeStyle=p,a.lineWidth=q,a.lineJoin='round',a.beginPath(),a.moveTo(f,g),a.lineTo(f,d),a.moveTo(b,k),a.lineTo(f,d),a.lineTo(j,d),a.lineTo(j,g),a.lineTo(f,g),a.lineTo(b,h),u){a.lineTo(b,g),a.moveTo(b,d),a.lineTo(b,k),a.moveTo(b-c,e-c),a.lineTo(b+c,e+c),a.moveTo(b+c,e-c),a.lineTo(b-c,e+c),a.stroke();return}a.closePath(),a.stroke()}function s(a,b,c){this.x=a,this.y=b,this.z=c}z=s.prototype,z.length=function(){return E(this.x*this.x+this.y*this.y+this.z*this.z)},z.dot=function(a){return this.x*a.x+this.y*a.y+this.z*a.z},z.cross=function(a){var b=this.y*a.z-this.z*a.y,c=this.z*a.x-this.x*a.z,d=this.x*a.y-this.y*a.x;return new s(b,c,d)},z.angle=function(b){var c=this.dot(b),a;return c==0?Math.PI/2:(a=c/(this.length()*b.length()),a>=1)?0:a<=-1?Math.PI:Math.acos(a)},z.unit=function(){var a=this.length();return new s(this.x/a,this.y/a,this.z/a)};function ay(b,a){a=a*Math.PI/180,b=b*Math.PI/180;var c=o(b)*l(a),d=-o(a),e=-l(b)*l(a);return new s(c,d,e)}function m(a){this[1]={1:a[0],2:a[1],3:a[2]},this[2]={1:a[3],2:a[4],3:a[5]},this[3]={1:a[6],2:a[7],3:a[8]}}T=m.prototype,m.Identity=function(){return new m([1,0,0,0,1,0,0,0,1])},m.Rotation=function(e,a){var c=o(e),d=l(e),b=1-d;return new m([d+w(a.x,2)*b,a.x*a.y*b-a.z*c,a.x*a.z*b+a.y*c,a.y*a.x*b+a.z*c,d+w(a.y,2)*b,a.y*a.z*b-a.x*c,a.z*a.x*b-a.y*c,a.z*a.y*b+a.x*c,d+w(a.z,2)*b])},T.mul=function(c){var d=[],a,b,e=c.xform?1:0;for(a=1;a<=3;++a)for(b=1;b<=3;++b)e?d.push(this[a][1]*c[1][b]+this[a][2]*c[2][b]+this[a][3]*c[3][b]):d.push(this[a][b]*c);return new m(d)},T.xform=function(b){var a={},c=b.x,d=b.y,e=b.z;return a.x=c*this[1][1]+d*this[2][1]+e*this[3][1],a.y=c*this[1][2]+d*this[2][2]+e*this[3][2],a.z=c*this[1][3]+d*this[2][3]+e*this[3][3],a};function aB(g,j,k,m,f){var a,b,c,d,e=[],h=2/g,i;i=Math.PI*(3-E(5)+(parseFloat(f)?parseFloat(f):0));for(a=0;a<g;++a)b=a*h-1+h/2,c=E(1-b*b),d=a*i,e.push([l(d)*c*j,b*k,o(d)*c*m]);return e}function U(n,p,m,k,h,g){var b,f=[],i=2/n,j,a,d,c,e;j=Math.PI*(3-E(5)+(parseFloat(g)?parseFloat(g):0));for(a=0;a<n;++a)d=a*i-1+i/2,b=a*j,c=l(b),e=o(b),f.push(p?[d*m,c*k,e*h]:[c*m,d*k,e*h]);return f}function aa(k,e,f,h,i,j){var b,g=[],m=Math.PI*2/e,a,c,d;for(a=0;a<e;++a)b=a*m,c=l(b),d=o(b),g.push(k?[j*f,c*h,d*i]:[c*f,j*h,d*i]);return g}function ax(a,b,c,d,e){return U(a,0,b,c,d,e)}function aH(a,b,c,d,e){return U(a,1,b,c,d,e)}function aG(b,c,d,e,a){return a=isNaN(a)?0:a*1,aa(0,b,c,d,e,a)}function aF(b,c,d,e,a){return a=isNaN(a)?0:a*1,aa(1,b,c,d,e,a)}function av(b){var a=new Image;a.onload=function(){var c=a.width/2,d=a.height/2;b.centreFunc=function(b,g,h,e,f){b.setTransform(1,0,0,1,0,0),b.globalAlpha=1,b.drawImage(a,e-c,f-d)}},a.src=b.centreImage}function aE(a,c){var b=a,d,e,f=(c*1).toPrecision(3)+')';return a[0]==='#'?(I[a]||(a.length===4?I[a]='rgba('+R[a[1]]+R[a[2]]+R[a[3]]:I[a]='rgba('+D[a.substr(1,2)]+D[a.substr(3,2)]+D[a.substr(5,2)]),b=I[a]+f):a.substr(0,4)==='rgb('||a.substr(0,4)==='hsl('?b=a.replace('(','a(').replace(')',','+f):(a.substr(0,5)==='rgba('||a.substr(0,5)==='hsla(')&&(d=a.lastIndexOf(',')+1,e=a.indexOf(')'),c*=parseFloat(a.substring(d,e)),b=a.substr(0,d)+c.toPrecision(3)+')'),b}function k(b,d){if(window.G_vmlCanvasManager)return null;var a=c.createElement('canvas');return a.width=b,a.height=d,a}function aD(){var b=k(3,3),a,c;return!!b&&(a=b.getContext('2d'),a.strokeStyle='#000',a.shadowColor='#fff',a.shadowBlur=3,a.globalAlpha=0,a.strokeRect(2,2,2,2),a.globalAlpha=1,c=a.getImageData(2,2,1,1),b=null,c.data[0]>0)}function aC(a,c,f,d){var e=a.createLinearGradient(0,0,c,0),b;for(b in d)e.addColorStop(1-b,d[b]);a.fillStyle=e,a.fillRect(0,f,c,1)}function L(a,m,j){var l=1024,d=1,e=a.weightGradient,i,f,b,c;if(a.gCanvas)f=a.gCanvas.getContext('2d'),d=a.gCanvas.height;else{if(B(e[0])?d=e.length:e=[e],a.gCanvas=i=k(l,d),!i)return null;f=i.getContext('2d');for(b=0;b<d;++b)aC(f,l,b,e[b])}return j=g(h(j||0,d-1),0),c=f.getImageData(~~((l-1)*m),j,1,1).data,'rgba('+c[0]+','+c[1]+','+c[2]+','+c[3]/255+')'}function Y(b,i,q,k,o,n,h,d,a,g,f,l){var m=o+(d||0)+(a.length&&a[0]<0?p(a[0]):0),j=n+(d||0)+(a.length&&a[1]<0?p(a[1]):0),c,e;b.font=i,b.textBaseline='top',b.fillStyle=q,h&&(b.shadowColor=h),d&&(b.shadowBlur=d),a.length&&(b.shadowOffsetX=a[0],b.shadowOffsetY=a[1]);for(c=0;c<k.length;++c)e=0,f&&('right'==l?e=g-f[c]:'centre'==l&&(e=(g-f[c])/2)),b.fillText(k[c],m+e,j),j+=parseInt(i)}function y(d,a,b,f,e,c,g){c?(d.beginPath(),d.moveTo(a,b+e-c),d.arcTo(a,b,a+c,b,c),d.arcTo(a+f,b,a+f,b+c,c),d.arcTo(a+f,b+e,a+f-c,b+e,c),d.arcTo(a,b+e,a,b+e-c,c),d.closePath(),d[g?'stroke':'fill']()):d[g?'strokeRect':'fillRect'](a,b,f,e)}function O(a,b,c,d,e,f,g,h,i){this.strings=a,this.font=b,this.width=c,this.height=d,this.maxWidth=e,this.stringWidths=f,this.align=g,this.valign=h,this.scale=i}M=O.prototype,M.SetImage=function(a,b,c,d,e,f,g,h){this.image=a,this.iwidth=b*this.scale,this.iheight=c*this.scale,this.ipos=d,this.ipad=e*this.scale,this.iscale=h,this.ialign=f,this.ivalign=g},M.Align=function(c,d,a){var b=0;return a=='right'||a=='bottom'?b=d-c:a!='left'&&a!='top'&&(b=(d-c)/2),b},M.Create=function(G,D,F,b,A,m,q,j,E){var o,e,f,a,l,s,i,u,v,r,w,n,c,d,x,B=p(q[0]),C=p(q[1]),t,z;return j=g(j,B+m,C+m),l=2*(j+b),i=2*(j+b),e=this.width+l,f=this.height+i,v=r=j+b,this.image&&(w=n=j+b,c=this.iwidth,d=this.iheight,this.ipos=='top'||this.ipos=='bottom'?(c<this.width?w+=this.Align(c,this.width,this.ialign):v+=this.Align(this.width,c,this.align),this.ipos=='top'?r+=d+this.ipad:n+=this.height+this.ipad,e=g(e,c+l),f+=d+this.ipad):(d<this.height?n+=this.Align(d,this.height,this.ivalign):r+=this.Align(this.height,d,this.valign),this.ipos=='right'?w+=this.width+this.ipad:v+=c+this.ipad,e+=c+this.ipad,f=g(f,d+i))),o=k(e,f),!o?null:(l=i=b/2,s=e-b,u=f-b,x=h(E,s/2,u/2),a=o.getContext('2d'),D&&(a.fillStyle=D,y(a,l,i,s,u,x)),b&&(a.strokeStyle=F,a.lineWidth=b,y(a,l,i,s,u,x,!0)),(m||B||C)&&(t=k(e,f),t&&(z=a,a=t.getContext('2d'))),Y(a,this.font,G,this.strings,v,r,0,0,[],this.maxWidth,this.stringWidths,this.align),this.image&&a.drawImage(this.image,w,n,c,d),z&&(a=z,A&&(a.shadowColor=A),m&&(a.shadowBlur=m),a.shadowOffsetX=q[0],a.shadowOffsetY=q[1],a.drawImage(t,0,0)),o)};function H(a,c,d){var b=k(c,d),e;return b?(e=b.getContext('2d'),e.drawImage(a,(c-a.width)/2,(d-a.height)/2),b):null}function S(e,b,c){var a=k(b,c),d;return a?(d=a.getContext('2d'),d.drawImage(e,0,0,b,c),a):null}function W(n,u,t,e,s,c,v,d,r,w){var g=u+(2*d+c)*e,f=t+(2*d+c)*e,l=k(g,f),b,i,q,m,j,o,a,p;return l?(c*=e,r*=e,i=q=c/2,m=g-c,j=f-c,d=d*e+i,b=l.getContext('2d'),p=h(r,m/2,j/2),s&&(b.fillStyle=s,y(b,i,q,m,j,p)),c&&(b.strokeStyle=v,b.lineWidth=c,y(b,i,q,m,j,p,!0)),w?(o=k(g,f),a=o.getContext('2d'),a.drawImage(n,d,d,u,t),a.globalCompositeOperation='source-in',a.fillStyle=v,a.fillRect(0,0,g,f),a.globalCompositeOperation='destination-over',a.drawImage(l,0,0),a.globalCompositeOperation='source-over',b.drawImage(o,0,0)):b.drawImage(n,d,d,n.width,n.height),{image:l,width:g/e,height:f/e}):null}function at(l,f,c,d,j){var e,a,b=parseFloat(f),i=g(c,d);return e=k(c,d),!e?null:(f.indexOf('%')>0?b=i*b/100:b=b*j,a=e.getContext('2d'),a.globalCompositeOperation='source-over',a.fillStyle='#fff',b>=i/2?(b=h(c,d)/2,a.beginPath(),a.moveTo(c/2,d/2),a.arc(c/2,d/2,b,0,2*Math.PI,!1),a.fill(),a.closePath()):(b=h(c/2,d/2,b),y(a,0,0,c,d,b,!0),a.fill()),a.globalCompositeOperation='source-in',a.drawImage(l,0,0,c,d),e)}function ao(q,m,i,b,h,a,c){var g=p(c[0]),f=p(c[1]),j=m+(g>a?g+a:a*2)*b,l=i+(f>a?f+a:a*2)*b,n=b*((a||0)+(c[0]<0?g:0)),o=b*((a||0)+(c[1]<0?f:0)),e,d;return e=k(j,l),!e?null:(d=e.getContext('2d'),h&&(d.shadowColor=h),a&&(d.shadowBlur=a*b),c&&(d.shadowOffsetX=c[0]*b,d.shadowOffsetY=c[1]*b),d.drawImage(q,n,o,m,i),{image:e,width:j/b,height:l/b})}function ae(m,o,l){var c=parseInt(m.toString().length*l),h=parseInt(l*2*m.length),j=k(c,h),g,i,e,f,b,d,n,a;if(!j)return null;g=j.getContext('2d'),g.fillStyle='#000',g.fillRect(0,0,c,h),Y(g,l+'px '+o,'#fff',m,0,0,0,0,[],'centre'),i=g.getImageData(0,0,c,h),e=i.width,f=i.height,a={min:{x:e,y:f},max:{x:-1,y:-1}};for(d=0;d<f;++d)for(b=0;b<e;++b)n=(d*e+b)*4,i.data[n+1]>0&&(b<a.min.x&&(a.min.x=b),b>a.max.x&&(a.max.x=b),d<a.min.y&&(a.min.y=d),d>a.max.y&&(a.max.y=d));return e!=c&&(a.min.x*=c/e,a.max.x*=c/e),f!=h&&(a.min.y*=c/f,a.max.y*=c/f),j=null,a}function Q(a){return\"'\"+a.replace(/('|\")/g,'').replace(/s*,s*/g,\"', '\")+\"'\"}function t(b,d,a){a=a||c,a.addEventListener?a.addEventListener(b,d,!1):a.attachEvent('on'+b,d)}function am(b,d,a){a=a||c,a.removeEventListener?a.removeEventListener(b,d):a.detachEvent('on'+b,d)}function A(g,e,j,a,b){var l=b.imageScale,h,c,k,m,f,d;if(!e.complete)return t('load',function(){A(g,e,j,a,b)},e);if(!g.complete)return t('load',function(){A(g,e,j,a,b)},g);if(j&&!j.complete)return t('load',function(){A(g,e,j,a,b)},j);e.width=e.width,e.height=e.height,l&&(g.width=e.width*l,g.height=e.height*l),a.iw=g.width,a.ih=g.height,b.txtOpt&&(c=g,h=b.zoomMax*b.txtScale,f=a.iw*h,d=a.ih*h,f<e.naturalWidth||d<e.naturalHeight?(c=S(g,f,d),c&&(a.fimage=c)):(f=a.iw,d=a.ih,h=1),parseFloat(b.imageRadius)&&(a.image=a.fimage=g=at(a.image,b.imageRadius,f,d,h)),a.HasText()||(b.shadow&&(c=ao(a.image,f,d,h,b.shadow,b.shadowBlur,b.shadowOffset),c&&(a.fimage=c.image,a.w=c.width,a.h=c.height)),(b.bgColour||b.bgOutlineThickness)&&(k=b.bgColour=='tag'?i(a.a,'background-color'):b.bgColour,m=b.bgOutline=='tag'?i(a.a,'color'):b.bgOutline||b.textColour,f=a.fimage.width,d=a.fimage.height,b.outlineMethod=='colour'&&(c=W(a.fimage,f,d,h,k,b.bgOutlineThickness,a.outline.colour,b.padding,b.bgRadius,1),c&&(a.oimage=c.image)),c=W(a.fimage,f,d,h,k,b.bgOutlineThickness,m,b.padding,b.bgRadius),c&&(a.fimage=c.image,a.w=c.width,a.h=c.height)),b.outlineMethod=='size'&&(b.outlineIncrease>0?(a.iw+=2*b.outlineIncrease,a.ih+=2*b.outlineIncrease,f=h*a.iw,d=h*a.ih,c=S(a.fimage,f,d),a.oimage=c,a.fimage=H(a.fimage,a.oimage.width,a.oimage.height)):(f=h*(a.iw+2*b.outlineIncrease),d=h*(a.ih+2*b.outlineIncrease),c=S(a.fimage,f,d),a.oimage=H(c,a.fimage.width,a.fimage.height))))),a.alt=j,a.Init()}function i(a,d){var b=c.defaultView,e=d.replace(/-([a-z])/g,function(a){return a.charAt(1).toUpperCase()});return b&&b.getComputedStyle&&b.getComputedStyle(a,null).getPropertyValue(d)||a.currentStyle&&a.currentStyle[e]}function aj(c,d,e){var b=1,a;return d?b=1*(c.getAttribute(d)||e):(a=i(c,'font-size'))&&(b=a.indexOf('px')>-1&&a.replace('px','')*1||a.indexOf('pt')>-1&&a.replace('pt','')*1.25||a*3.3),b}function u(a){return a.target&&n(a.target.id)?a.target.id:a.srcElement.parentNode.id}function K(a,c){var b,d,e=parseInt(i(c,'width'))/c.width,f=parseInt(i(c,'height'))/c.height;return n(a.offsetX)?b={x:a.offsetX,y:a.offsetY}:(d=X(c.id),n(a.changedTouches)&&(a=a.changedTouches[0]),a.pageX&&(b={x:a.pageX-d.x,y:a.pageY-d.y})),b&&e&&f&&(b.x/=e,b.y/=f),b}function an(c){var d=c.target||c.fromElement.parentNode,b=a.tc[d.id];b&&(b.mx=b.my=-1,b.UnFreeze(),b.EndDrag())}function ad(e){var g,c=a,b,d,f=u(e);for(g in c.tc)b=c.tc[g],b.tttimer&&(clearTimeout(b.tttimer),b.tttimer=null);f&&c.tc[f]&&(b=c.tc[f],(d=K(e,b.canvas))&&(b.mx=d.x,b.my=d.y,b.Drag(e,d)),b.drawn=0)}function ap(b){var e=a,f=c.addEventListener?0:1,d=u(b);d&&b.button==f&&e.tc[d]&&e.tc[d].BeginDrag(b)}function aq(b){var f=a,g=c.addEventListener?0:1,e=u(b),d;e&&b.button==g&&f.tc[e]&&(d=f.tc[e],ad(b),!d.EndDrag()&&!d.touchState&&d.Clicked(b))}function ar(c){var e=u(c),b=e&&a.tc[e],d;b&&c.changedTouches&&(c.touches.length==1&&b.touchState==0?(b.touchState=1,b.BeginDrag(c),(d=K(c,b.canvas))&&(b.mx=d.x,b.my=d.y,b.drawn=0)):c.targetTouches.length==2&&b.pinchZoom?(b.touchState=3,b.EndDrag(),b.BeginPinch(c)):(b.EndDrag(),b.EndPinch(),b.touchState=0))}function ac(c){var d=u(c),b=d&&a.tc[d];if(b&&c.changedTouches){switch(b.touchState){case 1:b.Draw(),b.Clicked();break;break;case 2:b.EndDrag();break;case 3:b.EndPinch()}b.touchState=0}}function au(c){var f,e=a,b,d,g=u(c);for(f in e.tc)b=e.tc[f],b.tttimer&&(clearTimeout(b.tttimer),b.tttimer=null);if(b=g&&e.tc[g],b&&c.changedTouches&&b.touchState){switch(b.touchState){case 1:case 2:(d=K(c,b.canvas))&&(b.mx=d.x,b.my=d.y,b.Drag(c,d)&&(b.touchState=2));break;case 3:b.Pinch(c)}b.drawn=0}}function ab(b){var d=a,c=u(b);c&&d.tc[c]&&(b.cancelBubble=!0,b.returnValue=!1,b.preventDefault&&b.preventDefault(),d.tc[c].Wheel((b.wheelDelta||b.detail)>0))}function aw(d){var c,b=a;clearTimeout(b.scrollTimer);for(c in b.tc)b.tc[c].Pause();b.scrollTimer=setTimeout(function(){var b,c=a;for(b in c.tc)c.tc[b].Resume()},b.scrollPause)}function al(){Z(q())}function Z(b){var c=a.tc,d;a.NextFrame(a.interval),b=b||q();for(d in c)c[d].Draw(b)}function az(){requestAnimationFrame(Z)}function aA(a){setTimeout(al,a)}function X(f){var g=c.getElementById(f),b=g.getBoundingClientRect(),a=c.documentElement,d=c.body,e=window,h=e.pageXOffset||a.scrollLeft,i=e.pageYOffset||a.scrollTop,j=a.clientLeft||d.clientLeft,k=a.clientTop||d.clientTop;return{x:b.left+h-j,y:b.top+i-k}}function aI(a,b,d,e){var c=a.radius*a.z1/(a.z1+a.z2+b.z);return{x:b.x*c*d,y:b.y*c*e,z:b.z,w:(a.z1-b.z)/a.z2}}function V(a){this.e=a,this.br=0,this.line=[],this.text=[],this.original=a.innerText||a.textContent}F=V.prototype,F.Empty=function(){for(var a=0;a<this.text.length;++a)if(this.text[a].length)return!1;return!0},F.Lines=function(c){var e=c?1:0,b,d,a;c=c||this.e,b=c.childNodes,d=b.length;for(a=0;a<d;++a)b[a].nodeName=='BR'?(this.text.push(this.line.join(' ')),this.br=1):b[a].nodeType==3?this.br?(this.line=[b[a].nodeValue],this.br=0):this.line.push(b[a].nodeValue):this.Lines(b[a]);return e||this.br||this.text.push(this.line.join(' ')),this.text},F.SplitWidth=function(h,e,f,g){var c,b,a,d=[];e.font=g+'px '+f;for(c=0;c<this.text.length;++c){a=this.text[c].split(/s+/),this.line=[a[0]];for(b=1;b<a.length;++b)e.measureText(this.line.join(' ')+' '+a[b]).width>h?(d.push(this.line.join(' ')),this.line=[a[b]]):this.line.push(a[b]);d.push(this.line.join(' '))}return this.text=d};function _(a,b){this.ts=null,this.tc=a,this.tag=b,this.x=this.y=this.w=this.h=this.sc=1,this.z=0,this.pulse=1,this.pulsate=a.pulsateTo<1,this.colour=a.outlineColour,this.adash=~~a.outlineDash,this.agap=~~a.outlineDashSpace||this.adash,this.aspeed=a.outlineDashSpeed*1,this.colour=='tag'?this.colour=i(b.a,'color'):this.colour=='tagbg'&&(this.colour=i(b.a,'background-color')),this.Draw=this.pulsate?this.DrawPulsate:this.DrawSimple,this.radius=a.outlineRadius|0,this.SetMethod(a.outlineMethod,a.altImage)}f=_.prototype,f.SetMethod=function(a,d){var b={block:['PreDraw','DrawBlock'],colour:['PreDraw','DrawColour'],outline:['PostDraw','DrawOutline'],classic:['LastDraw','DrawOutline'],size:['PreDraw','DrawSize'],none:['LastDraw']},c=b[a]||b.outline;a=='none'?this.Draw=function(){return 1}:this.drawFunc=this[c[1]],this[c[0]]=this.Draw,d&&(this.RealPreDraw=this.PreDraw,this.PreDraw=this.DrawAlt)},f.Update=function(d,e,i,j,a,f,g,h){var b=this.tc.outlineOffset,c=2*b;this.x=a*d+g-b,this.y=a*e+h-b,this.w=a*i+c,this.h=a*j+c,this.sc=a,this.z=f},f.Ants=function(k){if(!this.adash)return;var b=this.adash,c=this.agap,a=this.aspeed,j=b+c,h=0,g=b,f=c,i=0,d=0,e;a&&(d=p(a)*(q()-this.ts)/50,a<0&&(d=864e4-d),a=~~d%j),a?(b>=a?(h=b-a,g=a):(f=j-a,i=c-f),e=[h,f,g,i]):e=[b,c],k.setLineDash(e)},f.DrawOutline=function(a,d,e,b,c,f){var g=h(this.radius,c/2,b/2);a.strokeStyle=f,this.Ants(a),y(a,d,e,b,c,g,!0)},f.DrawSize=function(i,n,m,l,k,j,a,h,g){var f=a.w,e=a.h,c,b,d;return this.pulsate?(a.image?d=(a.image.height+this.tc.outlineIncrease)/a.image.height:d=a.oscale,b=a.fimage||a.image,c=1+(d-1)*(1-this.pulse),a.h*=c,a.w*=c):b=a.oimage,a.alpha=1,a.Draw(i,h,g,b),a.h=e,a.w=f,1},f.DrawColour=function(d,h,i,e,f,g,a,b,c){return a.oimage?(this.pulse<1?(a.alpha=1-w(this.pulse,2),a.Draw(d,b,c,a.fimage),a.alpha=this.pulse):a.alpha=1,a.Draw(d,b,c,a.oimage),1):this[a.image?'DrawColourImage':'DrawColourText'](d,h,i,e,f,g,a,b,c)},f.DrawColourText=function(f,h,i,j,g,e,a,b,c){var d=a.colour;return a.colour=e,a.alpha=1,a.Draw(f,b,c),a.colour=d,1},f.DrawColourImage=function(a,q,p,o,n,m,i,r,l){var f=a.canvas,e=~~g(q,0),d=~~g(p,0),c=h(f.width-e,o)+.5|0,b=h(f.height-d,n)+.5|0,j;return v?(v.width=c,v.height=b):v=k(c,b),!v?this.SetMethod('outline'):(j=v.getContext('2d'),j.drawImage(f,e,d,c,b,0,0,c,b),a.clearRect(e,d,c,b),this.pulsate?i.alpha=1-w(this.pulse,2):i.alpha=1,i.Draw(a,r,l),a.setTransform(1,0,0,1,0,0),a.save(),a.beginPath(),a.rect(e,d,c,b),a.clip(),a.globalCompositeOperation='source-in',a.fillStyle=m,a.fillRect(e,d,c,b),a.restore(),a.globalAlpha=1,a.globalCompositeOperation='destination-over',a.drawImage(v,0,0,c,b,e,d,c,b),a.globalCompositeOperation='source-over',1)},f.DrawAlt=function(b,a,c,d,f,g){var e=this.RealPreDraw(b,a,c,d,f,g);return a.alt&&(a.DrawImage(b,c,d,a.alt),e=1),e},f.DrawBlock=function(a,d,e,b,c,f){var g=h(this.radius,c/2,b/2);a.fillStyle=f,y(a,d,e,b,c,g)},f.DrawSimple=function(a,b,c,d,e,f){var g=this.tc;return a.setTransform(1,0,0,1,0,0),a.strokeStyle=this.colour,a.lineWidth=g.outlineThickness,a.shadowBlur=a.shadowOffsetX=a.shadowOffsetY=0,a.globalAlpha=f?e:1,this.drawFunc(a,this.x,this.y,this.w,this.h,this.colour,b,c,d)},f.DrawPulsate=function(h,d,e,f){var g=q()-this.ts,c=this.tc,b=c.pulsateTo+(1-c.pulsateTo)*(.5+l(2*Math.PI*g/(1e3*c.pulsateTime))/2);return this.pulse=b=a.Smooth(1,b),this.DrawSimple(h,d,e,f,b,1)},f.Active=function(d,a,b){var c=a>=this.x&&b>=this.y&&a<=this.x+this.w&&b<=this.y+this.h;return c?this.ts=this.ts||q():this.ts=null,c},f.PreDraw=f.PostDraw=f.LastDraw=x;function J(a,h,c,b,e,f,g,d,i,j,k,l,m,n){this.tc=a,this.image=null,this.text=h,this.text_original=n,this.line_widths=[],this.title=c.title||null,this.a=c,this.position=new s(b[0],b[1],b[2]),this.x=this.y=this.z=0,this.w=e,this.h=f,this.colour=g||a.textColour,this.bgColour=d||a.bgColour,this.bgRadius=i|0,this.bgOutline=j||this.colour,this.bgOutlineThickness=k|0,this.textFont=l||a.textFont,this.padding=m|0,this.sc=this.alpha=1,this.weighted=!a.weight,this.outline=new _(a,this),this.audio=null}d=J.prototype,d.Init=function(b){var a=this.tc;this.textHeight=a.textHeight,this.HasText()?this.Measure(a.ctxt,a):(this.w=this.iw,this.h=this.ih),this.SetShadowColour=a.shadowAlpha?this.SetShadowColourAlpha:this.SetShadowColourFixed,this.SetDraw(a)},d.Draw=x,d.HasText=function(){return this.text&&this.text[0].length>0},d.EqualTo=function(a){var b=a.getElementsByTagName('img');return this.a.href!=a.href?0:b.length?this.image.src==b[0].src:(a.innerText||a.textContent)==this.text_original},d.SetImage=function(a){this.image=this.fimage=a},d.SetAudio=function(a){this.audio=a,this.audio.load()},d.SetDraw=function(a){this.Draw=this.fimage?a.ie>7?this.DrawImageIE:this.DrawImage:this.DrawText,a.noSelect&&(this.CheckActive=x)},d.MeasureText=function(d){var a,e=this.text.length,b=0,c;for(a=0;a<e;++a)this.line_widths[a]=c=d.measureText(this.text[a]).width,b=g(b,c);return b},d.Measure=function(e,a){var f=ae(this.text,this.textFont,this.textHeight),b,k,h,i,g,l,j,c,d;j=f?f.max.y+f.min.y:this.textHeight,e.font=this.font=this.textHeight+'px '+this.textFont,l=this.MeasureText(e),a.txtOpt&&(b=a.txtScale,k=b*this.textHeight,h=k+'px '+this.textFont,i=[b*a.shadowOffset[0],b*a.shadowOffset[1]],e.font=h,g=this.MeasureText(e),d=new O(this.text,h,g+b,b*j+b,g,this.line_widths,a.textAlign,a.textVAlign,b),this.image&&d.SetImage(this.image,this.iw,this.ih,a.imagePosition,a.imagePadding,a.imageAlign,a.imageVAlign,a.imageScale),c=d.Create(this.colour,this.bgColour,this.bgOutline,b*this.bgOutlineThickness,a.shadow,b*a.shadowBlur,i,b*this.padding,b*this.bgRadius),a.outlineMethod=='colour'?this.oimage=d.Create(this.outline.colour,this.bgColour,this.outline.colour,b*this.bgOutlineThickness,a.shadow,b*a.shadowBlur,i,b*this.padding,b*this.bgRadius):a.outlineMethod=='size'&&(f=ae(this.text,this.textFont,this.textHeight+a.outlineIncrease),k=f.max.y+f.min.y,h=b*(this.textHeight+a.outlineIncrease)+'px '+this.textFont,e.font=h,g=this.MeasureText(e),d=new O(this.text,h,g+b,b*k+b,g,this.line_widths,a.textAlign,a.textVAlign,b),this.image&&d.SetImage(this.image,this.iw+a.outlineIncrease,this.ih+a.outlineIncrease,a.imagePosition,a.imagePadding,a.imageAlign,a.imageVAlign,a.imageScale),this.oimage=d.Create(this.colour,this.bgColour,this.bgOutline,b*this.bgOutlineThickness,a.shadow,b*a.shadowBlur,i,b*this.padding,b*this.bgRadius),this.oscale=this.oimage.width/c.width,a.outlineIncrease>0?c=H(c,this.oimage.width,this.oimage.height):this.oimage=H(this.oimage,c.width,c.height)),c&&(this.fimage=c,l=this.fimage.width/b,j=this.fimage.height/b),this.SetDraw(a),a.txtOpt=!!this.fimage),this.h=j,this.w=l},d.SetFont=function(a,b,c,d){this.textFont=a,this.colour=b,this.bgColour=c,this.bgOutline=d,this.Measure(this.tc.ctxt,this.tc)},d.SetWeight=function(c){var b=this.tc,e=b.weightMode.split(/[, ]/),d,a,f=c.length;if(!this.HasText())return;this.weighted=!0;for(a=0;a<f;++a)d=e[a]||'size','both'==d?(this.Weight(c[a],b.ctxt,b,'size',b.min_weight[a],b.max_weight[a],a),this.Weight(c[a],b.ctxt,b,'colour',b.min_weight[a],b.max_weight[a],a)):this.Weight(c[a],b.ctxt,b,d,b.min_weight[a],b.max_weight[a],a);this.Measure(b.ctxt,b)},d.Weight=function(b,i,a,d,f,h,e){b=isNaN(b)?1:b;var c=(b-f)/(h-f);'colour'==d?this.colour=L(a,c,e):'bgcolour'==d?this.bgColour=L(a,c,e):'bgoutline'==d?this.bgOutline=L(a,c,e):'outline'==d?this.outline.colour=L(a,c,e):'size'==d&&(a.weightSizeMin>0&&a.weightSizeMax>a.weightSizeMin?this.textHeight=a.weightSize*(a.weightSizeMin+(a.weightSizeMax-a.weightSizeMin)*c):this.textHeight=g(1,b*a.weightSize))},d.SetShadowColourFixed=function(a,b,c){a.shadowColor=b},d.SetShadowColourAlpha=function(a,b,c){a.shadowColor=aE(b,c)},d.DrawText=function(a,h,i){var e=this.tc,g=this.x,f=this.y,c=this.sc,b,d;a.globalAlpha=this.alpha,a.fillStyle=this.colour,e.shadow&&this.SetShadowColour(a,e.shadow,this.alpha),a.font=this.font,g+=h/c,f+=i/c-this.h/2;for(b=0;b<this.text.length;++b)d=g,'right'==e.textAlign?d+=this.w/2-this.line_widths[b]:'centre'==e.textAlign?d-=this.line_widths[b]/2:d-=this.w/2,a.setTransform(c,0,0,c,c*d,c*f),a.fillText(this.text[b],0,0),f+=this.textHeight},d.DrawImage=function(b,i,k,l){var e=this.x,f=this.y,a=this.sc,j=l||this.fimage,c=this.w,d=this.h,g=this.alpha,h=this.shadow;b.globalAlpha=g,h&&this.SetShadowColour(b,h,g),e+=i/a-c/2,f+=k/a-d/2,b.setTransform(a,0,0,a,a*e,a*f),b.drawImage(j,0,0,c,d)},d.DrawImageIE=function(b,d,e){var c=this.fimage,a=this.sc,f=c.width=this.w*a,g=c.height=this.h*a,h=this.x*a+d-f/2,i=this.y*a+e-g/2;b.setTransform(1,0,0,1,0,0),b.globalAlpha=this.alpha,b.drawImage(c,h,i)},d.Calc=function(g,e){var a,b=this.tc,d=b.minBrightness,f=b.maxBrightness,c=b.max_radius;return a=g.xform(this.position),this.xformed=a,a=aI(b,a,b.stretchX,b.stretchY),this.x=a.x,this.y=a.y,this.z=a.z,this.sc=a.w,this.alpha=e*G(d+(f-d)*(c-this.z)/(2*c),0,1),this.xformed},d.UpdateActive=function(h,e,f){var a=this.outline,b=this.w,c=this.h,d=this.x-b/2,g=this.y-c/2;return a.Update(d,g,b,c,this.sc,this.z,e,f),a},d.CheckActive=function(a,d,e){var b=this.tc,c=this.UpdateActive(a,d,e);return c.Active(a,b.mx,b.my)?c:null},d.Clicked=function(f){var b=this.a,a=b.target,d=b.href,e;if(a!=''&&a!='_self'){if(self.frames[a])self.frames[a].document.location=d;else{try{if(top.frames[a]){top.frames[a].document.location=d;return}}catch(a){}window.open(d,a)}return}if(c.createEvent){if(e=c.createEvent('MouseEvents'),e.initMouseEvent('click',1,1,window,0,0,0,0,0,0,0,0,0,0,null),!b.dispatchEvent(e))return}else if(b.fireEvent)if(!b.fireEvent('onclick'))return;c.location=d},d.StopAudio=function(){this.audio&&this.playing&&this.audio.pause(),this.stopped=1,this.playing=0},d.PlayAudio=function(){if(e==='off'||this.tc.audioOff)return;if(!e&&!ag())return;var a=this.tc.audio,c=this.tc.gain,d='suspended',b;if(this.audio)if(this.track||(this.track=e.createMediaElementSource(this.audio),this.gain=e.createGain(),this.track.connect(this.gain),this.gain.connect(e.destination)),a=this.audio,c=this.gain,!a.paused)return 1;if(a){if(e.state==d&&e.resume(),e.state==d)return;return c.gain.value=h(2,g(0,this.tc.audioVolume*1)),a.currentTime=0,this.stopped=0,b=a.play(),b!==void 0&&b.then(a=>{this.stopped?this.audio.pause():this.playing=1}),1}};function a(f,o,k){var d,i,b=c.getElementById(f),l=['id','class','innerHTML'];if(!b)throw 0;if(n(window.G_vmlCanvasManager)&&(b=window.G_vmlCanvasManager.initElement(b),this.ie=parseFloat(navigator.appVersion.split('MSIE')[1])),b&&(!b.getContext||!b.getContext('2d').fillText)){i=c.createElement('DIV');for(d=0;d<l.length;++d)i[l[d]]=b[l[d]];throw b.parentNode.insertBefore(i,b),b.parentNode.removeChild(b),0}for(d in a.options)this[d]=k&&n(k[d])?k[d]:n(a[d])?a[d]:a.options[d];if(this.canvas=b,this.ctxt=b.getContext('2d'),this.z1=250/g(this.depth,.001),this.z2=this.z1/this.zoom,this.radius=h(b.height,b.width)*.0075,this.max_radius=100,this.max_weight=[],this.min_weight=[],this.textFont=this.textFont&&Q(this.textFont),this.textHeight*=1,this.imageRadius=this.imageRadius.toString(),this.pulsateTo=G(this.pulsateTo,0,1),this.minBrightness=G(this.minBrightness,0,1),this.maxBrightness=G(this.maxBrightness,this.minBrightness,1),this.ctxt.textBaseline='top',this.lx=(this.lock+'').indexOf('x')+1,this.ly=(this.lock+'').indexOf('y')+1,this.frozen=this.dx=this.dy=this.fixedAnim=this.touchState=0,this.fixedAlpha=1,this.source=o||f,this.repeatTags=h(64,~~this.repeatTags),this.minTags=h(200,~~this.minTags),~~this.scrollPause>0?a.scrollPause=~~this.scrollPause:this.scrollPause=0,this.minTags>0&&this.repeatTags<1&&(d=this.GetTags().length)&&(this.repeatTags=af(this.minTags/d)-1),this.transform=m.Identity(),this.startTime=this.time=q(),this.mx=this.my=-1,this.centreImage&&av(this),this.Animate=this.dragControl?this.AnimateDrag:this.AnimatePosition,this.animTiming=typeof a[this.animTiming]=='function'?a[this.animTiming]:a.Smooth,this.shadowBlur||this.shadowOffset[0]||this.shadowOffset[1]?(this.ctxt.shadowColor=this.shadow,this.shadow=this.ctxt.shadowColor,this.shadowAlpha=aD()):delete this.shadow,this.activeAudio===!1?e='off':this.activeAudio&&this.LoadAudio(),this.Load(),o&&this.hideTags&&function(b){a.loaded?b.HideTags():t('load',function(){b.HideTags()},window)}(this),this.yaw=this.initial?this.initial[0]*this.maxSpeed:0,this.pitch=this.initial?this.initial[1]*this.maxSpeed:0,this.tooltip?(this.ctitle=b.title,b.title='',this.tooltip=='native'?this.Tooltip=this.TooltipNative:(this.Tooltip=this.TooltipDiv,this.ttdiv||(this.ttdiv=c.createElement('div'),this.ttdiv.className=this.tooltipClass,this.ttdiv.style.position='absolute',this.ttdiv.style.zIndex=b.style.zIndex+1,t('mouseover',function(a){a.target.style.display='none'},this.ttdiv),c.body.appendChild(this.ttdiv)))):this.Tooltip=this.TooltipNone,!this.noMouse&&!j[f]){j[f]=[['mousemove',ad],['mouseout',an],['mouseup',aq],['touchstart',ar],['touchend',ac],['touchcancel',ac],['touchmove',au]],this.dragControl&&(j[f].push(['mousedown',ap]),j[f].push(['selectstart',x])),this.wheelZoom&&(j[f].push(['mousewheel',ab]),j[f].push(['DOMMouseScroll',ab])),this.scrollPause&&j[f].push(['scroll',aw,window]);for(d=0;d<j[f].length;++d)i=j[f][d],t(i[0],i[1],i[2]?i[2]:b)}a.started||(a.NextFrame=window.requestAnimationFrame?az:aA,a.interval=this.interval,a.NextFrame(this.interval),a.started=1)}b=a.prototype,b.SourceElements=function(){return c.querySelectorAll?c.querySelectorAll('#'+this.source):[c.getElementById(this.source)]},b.HideTags=function(){var b=this.SourceElements(),a;for(a=0;a<b.length;++a)b[a].style.display='none'},b.GetTags=function(){var e=this.SourceElements(),c,f=[],a,b,d;for(d=0;d<=this.repeatTags;++d)for(a=0;a<e.length;++a){c=e[a].getElementsByTagName('a');for(b=0;b<c.length;++b)f.push(c[b])}return f},b.Message=function(j){var g=[],a,f,b=j.split(''),d,e,h,i;for(a=0;a<b.length;++a)b[a]!=' '&&(f=a-b.length/2,d=c.createElement('A'),d.href='#',d.innerText=b[a],h=100*o(f/9),i=-100*l(f/9),e=new J(this,b[a],d,[h,0,i],2,18,'#000','#fff',0,0,0,'monospace',2,b[a]),e.Init(),g.push(e));return g},b.AddAudio=function(b,c){if(e==='off')return;var a=b.getElementsByTagName('audio');a.length&&(c.SetAudio(a[0]),this.hasAudio=1)},b.CreateTag=function(b){var e,c,a,f,d,g,h,j,k=[0,0,0],l;if('text'!=this.imageMode)if(e=b.getElementsByTagName('img'),e.length)if(c=new Image,c.src=e[0].src,!this.imageMode)return a=new J(this,\"\",b,k,0,0),a.SetImage(c),A(c,e[0],e[1],a,this),this.AddAudio(b,a),a;if('image'!=this.imageMode&&(d=new V(b),f=d.Lines(),d.Empty()?d=null:(g=this.textFont||Q(i(b,'font-family')),this.splitWidth&&(f=d.SplitWidth(this.splitWidth,this.ctxt,g,this.textHeight)),h=this.bgColour=='tag'?i(b,'background-color'):this.bgColour,j=this.bgOutline=='tag'?i(b,'color'):this.bgOutline)),d||c)return a=new J(this,f,b,k,2,this.textHeight+2,this.textColour||i(b,'color'),h,this.bgRadius,j,this.bgOutlineThickness,g,this.padding,d&&d.original),c?(a.SetImage(c),A(c,e[0],e[1],a,this)):a.Init(),this.AddAudio(b,a),a},b.UpdateTag=function(a,b){var c=this.textColour||i(b,'color'),d=this.textFont||Q(i(b,'font-family')),e=this.bgColour=='tag'?i(b,'background-color'):this.bgColour,f=this.bgOutline=='tag'?i(b,'color'):this.bgOutline;a.a=b,a.title=b.title,(a.colour!=c||a.textFont!=d||a.bgColour!=e||a.bgOutline!=f)&&a.SetFont(d,c,e,f)},b.Weight=function(d){var f=d.length,c,b,a,e=[],g,h=this.weightFrom?this.weightFrom.split(/[, ]/):[null],i=h.length;for(b=0;b<f;++b){e[b]=[];for(a=0;a<i;++a)c=aj(d[b].a,h[a],this.textHeight),(!this.max_weight[a]||c>this.max_weight[a])&&(this.max_weight[a]=c),(!this.min_weight[a]||c<this.min_weight[a])&&(this.min_weight[a]=c),e[b][a]=c}for(a=0;a<i;++a)this.max_weight[a]>this.min_weight[a]&&(g=1);if(g)for(b=0;b<f;++b)d[b].SetWeight(e[b])},b.Load=function(){var c=this.GetTags(),b=[],d,k,l,h,i,j,f,a,e=[],m={sphere:aB,vcylinder:ax,hcylinder:aH,vring:aG,hring:aF};if(c.length){e.length=c.length;for(a=0;a<c.length;++a)e[a]=a;this.shuffleTags&&ai(e),h=100*this.radiusX,i=100*this.radiusY,j=100*this.radiusZ,this.max_radius=g(h,g(i,j));for(a=0;a<c.length;++a)k=this.CreateTag(c[e[a]]),k&&b.push(k);this.weight&&this.Weight(b,!0),this.shapeArgs?this.shapeArgs[0]=b.length:(l=this.shape.toString().split(/[(),]/),d=l.shift(),typeof window[d]=='function'?this.shape=window[d]:this.shape=m[d]||m.sphere,this.shapeArgs=[b.length,h,i,j].concat(l)),f=this.shape.apply(this,this.shapeArgs),this.listLength=b.length;for(a=0;a<b.length;++a)b[a].position=new s(f[a][0],f[a][1],f[a][2])}this.noTagsMessage&&!b.length&&(a=this.imageMode&&this.imageMode!='both'?this.imageMode+' ':'',b=this.Message('No '+a+'tags')),this.taglist=b},b.Update=function(){var e=this.GetTags(),d=[],j=this.taglist,k,f=[],c=[],h,i,g,a,b;if(!this.shapeArgs)return this.Load();if(e.length){g=this.listLength=e.length,i=j.length;for(a=0;a<i;++a)d.push(j[a]),c.push(a);for(a=0;a<g;++a){for(b=0,k=0;b<i;++b)j[b].EqualTo(e[a])&&(this.UpdateTag(d[b],e[a]),k=c[b]=-1);k||f.push(a)}for(a=0,b=0;a<i;++a)c[b]==-1?c.splice(b,1):++b;if(c.length){for(ai(c);c.length&&f.length;)a=c.shift(),b=f.shift(),d[a]=this.CreateTag(e[b]);for(c.sort(function(a,b){return a-b});c.length;)d.splice(c.pop(),1)}for(b=d.length/(f.length+1),a=0;f.length;)d.splice(af(++a*b),0,this.CreateTag(e[f.shift()]));this.shapeArgs[0]=g=d.length,h=this.shape.apply(this,this.shapeArgs);for(a=0;a<g;++a)d[a].position=new s(h[a][0],h[a][1],h[a][2]);this.weight&&this.Weight(d)}this.taglist=d},b.SetShadow=function(a){a.shadowBlur=this.shadowBlur,a.shadowOffsetX=this.shadowOffset[0],a.shadowOffsetY=this.shadowOffset[1]},b.LoadAudio=function(){if(!e&&!ag())return;this.audio=c.createElement('audio'),this.audio.src=this.activeAudio,this.track=e.createMediaElementSource(this.audio),this.gain=e.createGain(),this.track.connect(this.gain),this.gain.connect(e.destination),this.hasAudio=1,P=function(a){e.resume(),c.removeEventListener('click',P)},c.addEventListener('click',P)},b.ShowAudioIcon=function(){var a=this.audioIconSize,c=this.canvas,d=this.ctxt,k=c.width-a-3,f=c.height-a-3,g=this.audioIconThickness,h='#000',i='#fff',j=this.audioIconDark,b=this.audioOff,l='suspended';if(!e)return;b||(b=e.state===l),this.audioIcon&&this.hasAudio&&($(b,d,a,k,f,g+1,j?i:h),$(b,d,a,k,f,g,j?h:i))},b.CheckAudioIcon=function(){var a=this.audioIconSize,b=this.canvas,c=this.audioIconThickness/2,d=b.width-a-3-c,e=b.height-a-3-c;if(this.audioIcon&&this.mx>=d&&this.my>=e)return!0},b.ToggleAudio=function(){var a=this.audioOff||e&&e.state==='suspended';a||this.currentAudio&&this.currentAudio.StopAudio(),this.audioOff=!a},b.Draw=function(s){if(this.paused)return;var l=this.canvas,i=l.width,j=l.height,q=0,p=(s-this.time)*a.interval/1e3,h=i/2+this.offsetX,g=j/2+this.offsetY,d=this.ctxt,b,f,c,o=-1,e=this.taglist,k=e.length,t=this.active&&this.active.tag,m='',u=this.frontSelect,r=this.centreFunc==x,n;if(this.time=s,this.frozen&&this.drawn)return this.Animate(i,j,p);n=this.AnimateFixed(),d.setTransform(1,0,0,1,0,0);for(c=0;c<k;++c)e[c].Calc(this.transform,this.fixedAlpha);if(e=ak(e,function(a,b){return b.z-a.z}),n&&this.fixedAnim.active)b=this.fixedAnim.tag.UpdateActive(d,h,g);else if(this.active=null,this.CheckAudioIcon())m='pointer';else{for(c=0;c<k;++c)f=this.mx>=0&&this.my>=0&&this.taglist[c].CheckActive(d,h,g),f&&f.sc>q&&(!u||f.z<=0)&&(b=f,o=c,b.tag=this.taglist[c],q=f.sc);this.active=b}this.txtOpt||this.shadow&&this.SetShadow(d),d.clearRect(0,0,i,j);for(c=0;c<k;++c){if(!r&&e[c].z<=0){try{this.centreFunc(d,i,j,h,g)}catch(a){alert(a),this.centreFunc=x}r=!0}b&&b.tag==e[c]&&b.PreDraw(d,e[c],h,g)||e[c].Draw(d,h,g),b&&b.tag==e[c]&&b.PostDraw(d)}this.freezeActive&&b?this.Freeze():(this.UnFreeze(),this.drawn=k==this.listLength),this.fixedCallback&&(this.fixedCallback(this,this.fixedCallbackTag),this.fixedCallback=null),n||this.Animate(i,j,p),b&&(b.LastDraw(d),b.tag!=t&&(this.currentAudio&&this.currentAudio!=b.tag&&this.currentAudio.StopAudio(),b.tag.PlayAudio()&&(this.currentAudio=b.tag)),m=this.activeCursor),l.style.cursor=m,this.Tooltip(b,this.taglist[o]),this.audioIcon&&this.ShowAudioIcon()},b.TooltipNone=function(){},b.TooltipNative=function(b,a){b?this.canvas.title=a&&a.title?a.title:'':this.canvas.title=this.ctitle},b.SetTTDiv=function(c,d){var a=this,b=a.ttdiv.style;c!=a.ttdiv.innerHTML&&(b.display='none'),a.ttdiv.innerHTML=c,d&&(d.title=a.ttdiv.innerHTML),b.display=='none'&&!a.tttimer&&(a.tttimer=setTimeout(function(){var c=X(a.canvas.id);b.display='block',b.left=c.x+a.mx+'px',b.top=c.y+a.my+24+'px',a.tttimer=null},a.tooltipDelay))},b.TooltipDiv=function(b,a){b&&a&&a.title?this.SetTTDiv(a.title,a):!b&&this.mx!=-1&&this.my!=-1&&this.ctitle.length?this.SetTTDiv(this.ctitle):this.ttdiv.style.display='none'},b.Transform=function(c,a,b){if(a||b){var d=o(a),e=l(a),f=o(b),g=l(b),h=new m([g,0,f,0,1,0,-f,0,g]),i=new m([1,0,0,0,e,-d,0,d,e]);c.transform=c.transform.mul(h.mul(i))}},b.AnimateFixed=function(){var a,b,c,d,e;return!!(this.fadeIn&&(b=q()-this.startTime,b>=this.fadeIn?(this.fadeIn=0,this.fixedAlpha=1):this.fixedAlpha=b/this.fadeIn),this.fixedAnim)&&(this.fixedAnim.transform||(this.fixedAnim.transform=this.transform),a=this.fixedAnim,b=q()-a.t0,c=a.angle,d,e=this.animTiming(a.t,b),this.transform=a.transform,b>=a.t?(this.fixedCallbackTag=a.tag,this.fixedCallback=a.cb,this.fixedAnim=this.yaw=this.pitch=0):c*=e,d=m.Rotation(c,a.axis),this.transform=this.transform.mul(d),this.fixedAnim!=0)},b.AnimatePosition=function(g,h,f){var a=this,d=a.mx,e=a.my,b,c;!a.frozen&&d>=0&&e>=0&&d<g&&e<h?(b=a.maxSpeed,c=a.reverse?-1:1,a.lx||(a.yaw=(d*2*b/g-b)*c*f),a.ly||(a.pitch=(e*2*b/h-b)*-c*f),a.initial=null):a.initial||(a.frozen&&!a.freezeDecel?a.yaw=a.pitch=0:a.Decel(a)),this.Transform(a,a.pitch,a.yaw)},b.AnimateDrag=function(d,e,c){var a=this,b=100*c*a.maxSpeed/a.max_radius/a.zoom;a.dx||a.dy?(a.lx||(a.yaw=a.dx*b/a.stretchX),a.ly||(a.pitch=a.dy*-b/a.stretchY),a.dx=a.dy=0,a.initial=null):a.initial||a.Decel(a),this.Transform(a,a.pitch,a.yaw)},b.Freeze=function(){this.frozen||(this.preFreeze=[this.yaw,this.pitch],this.frozen=1,this.drawn=0)},b.UnFreeze=function(){this.frozen&&(this.yaw=this.preFreeze[0],this.pitch=this.preFreeze[1],this.frozen=0)},b.Decel=function(a){var b=a.minSpeed,c=p(a.yaw),d=p(a.pitch);!a.lx&&c>b&&(a.yaw=c>a.z0?a.yaw*a.decel:0),!a.ly&&d>b&&(a.pitch=d>a.z0?a.pitch*a.decel:0)},b.Zoom=function(a){this.z2=this.z1*(1/a),this.drawn=0},b.Clicked=function(b){if(this.CheckAudioIcon()){this.ToggleAudio();return}var a=this.active;try{a&&a.tag&&(this.clickToFront===!1||this.clickToFront===null?a.tag.Clicked(b):this.TagToFront(a.tag,this.clickToFront,function(){a.tag.Clicked(b)},!0))}catch(a){}},b.Wheel=function(a){var b=this.zoom+this.zoomStep*(a?1:-1);this.zoom=h(this.zoomMax,g(this.zoomMin,b)),this.Zoom(this.zoom)},b.BeginDrag=function(a){this.down=K(a,this.canvas),a.cancelBubble=!0,a.returnValue=!1,a.preventDefault&&a.preventDefault()},b.Drag=function(e,a){if(this.dragControl&&this.down){var d=this.dragThreshold*this.dragThreshold,b=a.x-this.down.x,c=a.y-this.down.y;(this.dragging||b*b+c*c>d)&&(this.dx=b,this.dy=c,this.dragging=1,this.down=a)}return this.dragging},b.EndDrag=function(){var a=this.dragging;return this.dragging=this.down=null,a};function ah(a){var b=a.targetTouches[0],c=a.targetTouches[1];return E(w(c.pageX-b.pageX,2)+w(c.pageY-b.pageY,2))}b.BeginPinch=function(a){this.pinched=[ah(a),this.zoom],a.preventDefault&&a.preventDefault()},b.Pinch=function(d){var b,c,a=this.pinched;if(!a)return;c=ah(d),b=a[1]*c/a[0],this.zoom=h(this.zoomMax,g(this.zoomMin,b)),this.Zoom(this.zoom)},b.EndPinch=function(a){this.pinched=null},b.Pause=function(){this.paused=!0},b.Resume=function(){this.paused=!1},b.SetSpeed=function(a){this.initial=a,this.yaw=a[0]*this.maxSpeed,this.pitch=a[1]*this.maxSpeed},b.FindTag=function(a){if(!n(a))return null;if(n(a.index)&&(a=a.index),!B(a))return this.taglist[a];var c,d,b;n(a.id)?(c='id',d=a.id):n(a.text)&&(c='innerText',d=a.text);for(b=0;b<this.taglist.length;++b)if(this.taglist[b].a[c]==d)return this.taglist[b]},b.RotateTag=function(a,h,i,j,f,g){var b=a.Calc(this.transform,1),c=new s(b.x,b.y,b.z),d=ay(i,h),e=c.angle(d),k=c.cross(d).unit();e==0?(this.fixedCallbackTag=a,this.fixedCallback=f):this.fixedAnim={angle:-e,axis:k,t:j,t0:q(),cb:f,tag:a,active:g}},b.TagToFront=function(a,b,c,d){this.RotateTag(a,0,0,b,c,d)},b.Volume=function(a){this.audioVolume=a*1},a.Start=function(b,c,d){a.Delete(b),a.tc[b]=new a(b,c,d)};function N(c,b){a.tc[b]&&a.tc[b][c]()}a.Linear=function(a,b){return b/a},a.Smooth=function(a,b){return.5-l(b*Math.PI/a)/2},a.Pause=function(a){N('Pause',a)},a.Resume=function(a){N('Resume',a)},a.Reload=function(a){N('Load',a)},a.Update=function(a){N('Update',a)},a.SetSpeed=function(c,b){return!!(B(b)&&a.tc[c]&&!isNaN(b[0])&&!isNaN(b[1]))&&(a.tc[c].SetSpeed(b),!0)},a.TagToFront=function(c,b){return!!B(b)&&(b.lat=b.lng=0,a.RotateTag(c,b))},a.RotateTag=function(c,b){if(B(b)&&a.tc[c]){isNaN(b.time)&&(b.time=500);var d=a.tc[c].FindTag(b);if(d)return a.tc[c].RotateTag(d,b.lat,b.lng,b.time,b.callback,b.active),!0}return!1},a.Delete=function(b){var d,e;if(j[b])if(e=c.getElementById(b),e)for(d=0;d<j[b].length;++d)am(j[b][d][0],j[b][d][1],e);delete j[b],delete a.tc[b]},a.tc={},a.options={z1:2e4,z2:2e4,z0:2e-4,freezeActive:!1,freezeDecel:!1,activeCursor:'pointer',pulsateTo:1,pulsateTime:3,reverse:!1,depth:.5,maxSpeed:.05,minSpeed:0,decel:.95,interval:20,minBrightness:.1,maxBrightness:1,outlineColour:'#ffff99',outlineThickness:2,outlineOffset:5,outlineMethod:'outline',outlineRadius:0,textColour:'#ff99ff',textHeight:15,textFont:'Helvetica, Arial, sans-serif',shadow:'#000',shadowBlur:0,shadowOffset:[0,0],initial:null,hideTags:!0,zoom:1,weight:!1,weightMode:'size',weightFrom:null,weightSize:1,weightSizeMin:null,weightSizeMax:null,weightGradient:{0:'#f00',0.33:'#ff0',0.66:'#0f0',1:'#00f'},txtOpt:!0,txtScale:2,frontSelect:!1,wheelZoom:!0,zoomMin:.3,zoomMax:3,zoomStep:.05,shape:'sphere',lock:null,tooltip:null,tooltipDelay:300,tooltipClass:'tctooltip',radiusX:1,radiusY:1,radiusZ:1,stretchX:1,stretchY:1,offsetX:0,offsetY:0,shuffleTags:!1,noSelect:!1,noMouse:!1,imageScale:1,paused:!1,dragControl:!1,dragThreshold:4,centreFunc:x,splitWidth:0,animTiming:'Smooth',clickToFront:!1,fadeIn:0,padding:0,bgColour:null,bgRadius:0,bgOutline:null,bgOutlineThickness:0,outlineIncrease:4,textAlign:'centre',textVAlign:'middle',imageMode:null,imagePosition:null,imagePadding:2,imageAlign:'centre',imageVAlign:'middle',noTagsMessage:!0,centreImage:null,pinchZoom:!1,repeatTags:0,minTags:0,imageRadius:0,scrollPause:!1,outlineDash:0,outlineDashSpace:0,outlineDashSpeed:1,activeAudio:'',audioVolume:1,audioIcon:1,audioIconSize:20,audioIconThickness:2,audioIconDark:0,altImage:0};for(r in a.options)a[r]=a.options[r];window.TagCanvas=a,t('load',function(){a.loaded=1},window)})()", s = function () { return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1) }, guid = function () { return "" + s() + s() + "-" + s() + "-" + s() + "-" + s() + "-" + s() + s() + s() }, UseInViewport = function (e) { var t = e.cb, n = e.children, r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); return react__WEBPACK_IMPORTED_MODULE_0__.useEffect((function () { var e = new IntersectionObserver((function (e) { t(e.some((function (e) { return e.isIntersecting }))) }), { root: null, rootMargin: "0px", threshold: .1 }); return null != r && r.current && e.observe(r.current), function () { e.disconnect() } }), [t]), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: r }, n) }, isScriptLoaded = !1, tr = function (e) { try { e() } catch (t) { try { e() } catch (t) { } } }, CloudWrapped = function CloudWrapped(_ref) { var _ref$options = _ref.options, options = void 0 === _ref$options ? {} : _ref$options, _ref$containerProps = _ref.containerProps, containerProps = void 0 === _ref$containerProps ? {} : _ref$containerProps, _ref$canvasProps = _ref.canvasProps, canvasProps = void 0 === _ref$canvasProps ? {} : _ref$canvasProps, children = _ref.children, _ref$id = _ref.id, id = void 0 === _ref$id ? guid() : _ref$id, state = react__WEBPACK_IMPORTED_MODULE_0__.useRef({ canvasContainerId: "canvas-container-" + id, canvasId: "canvas-" + id, hasStarted: !1 }).current, _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), mounted = _React$useState[0], setMounted = _React$useState[1]; react__WEBPACK_IMPORTED_MODULE_0__.useEffect((function () { return setMounted(!0), function () { return tr((function () { eval("TagCanvas.Delete('" + state.canvasId + "')") })) } }), []); var supportsTouch = "undefined" !== typeof window && ("ontouchstart" in window || navigator.maxTouchPoints), ops = JSON.stringify(_extends({ dragControl: !!supportsTouch, maxSpeed: supportsTouch ? .01 : .05, textFont: null, textColour: null }, options)), onVisibilityChange = function onVisibilityChange(isVisible) { return tr((function () { if (isVisible && mounted) if (isScriptLoaded || (eval(tagCanvasString), isScriptLoaded = !0), state.hasStarted) eval("TagCanvas.Resume('" + state.canvasId + "')"); else try { eval("TagCanvas.Start('" + state.canvasId + "', null, " + ops + ")"), state.hasStarted = !0 } catch (e) { var el = document.getElementById(state.canvasContainerId); throw el && (el.style.display = "none"), e } else state.hasStarted && eval("TagCanvas.Pause('" + state.canvasId + "')") })) }; return react__WEBPACK_IMPORTED_MODULE_0__.createElement(UseInViewport, { cb: onVisibilityChange }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", Object.assign({ id: state.canvasContainerId }, containerProps), react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", Object.assign({ id: state.canvasId, style: { width: "100%", maxWidth: "70vh" }, width: 1e3, height: 1e3 }, canvasProps), children))) }, Cloud = function (e) { return react__WEBPACK_IMPORTED_MODULE_0__.createElement(CloudWrapped, Object.assign({}, e, { key: guid() })) }, addHash = function (e) { return "#" === e[0] ? e : "#" + e }, renderSimpleIcon = function (e) { var t = e.aProps, n = void 0 === t ? {} : t, r = e.bgHex, i = void 0 === r ? "#fff" : r, a = e.fallbackHex, s = void 0 === a ? "#000" : a, o = e.icon, l = e.imgProps, c = void 0 === l ? {} : l, u = e.minContrastRatio, d = void 0 === u ? 1 : u, h = e.size, f = void 0 === h ? 42 : h, p = addHash(o.hex), m = addHash(i), g = addHash(s), v = ((0, _csstools_convert_colors__WEBPACK_IMPORTED_MODULE_1__.yX)(m, p) > d ? (0, _csstools_convert_colors__WEBPACK_IMPORTED_MODULE_1__.xp)(p) : (0, _csstools_convert_colors__WEBPACK_IMPORTED_MODULE_1__.xp)(g)).map((function (e) { return Math.round(e / 100 * 255) })), b = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" style="fill: rgb(' + v[0] + ", " + v[1] + ", " + v[2] + ');" viewBox="0 0 24 24" height="' + f + 'px" width="' + f + 'px"> <title>' + o.title + '</title> <path d="' + o.path + '"></path> </svg>', y = _extends({ key: guid(), title: o.title, style: { cursor: "pointer" } }, n), w = _extends({ height: f, width: f, alt: o.title, src: b }, c); return react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", Object.assign({}, y), react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", Object.assign({}, w))) }; function createCommonjsModule(e, t) { return e(t = { exports: {} }, t.exports), t.exports } var runtime_1 = createCommonjsModule((function (e) { var t = function (e) { var t, n = Object.prototype, r = n.hasOwnProperty, i = "function" === typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", s = i.asyncIterator || "@@asyncIterator", o = i.toStringTag || "@@toStringTag"; function l(e, t, n) { return Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }), e[t] } try { l({}, "") } catch (R) { l = function (e, t, n) { return e[t] = n } } function c(e, t, n, r) { var i = t && t.prototype instanceof g ? t : g, a = Object.create(i.prototype), s = new M(r || []); return a._invoke = function (e, t, n) { var r = d; return function (i, a) { if (r === f) throw new Error("Generator is already running"); if (r === p) { if ("throw" === i) throw a; return P() } for (n.method = i, n.arg = a; ;) { var s = n.delegate; if (s) { var o = A(s, n); if (o) { if (o === m) continue; return o } } if ("next" === n.method) n.sent = n._sent = n.arg; else if ("throw" === n.method) { if (r === d) throw r = p, n.arg; n.dispatchException(n.arg) } else "return" === n.method && n.abrupt("return", n.arg); r = f; var l = u(e, t, n); if ("normal" === l.type) { if (r = n.done ? p : h, l.arg === m) continue; return { value: l.arg, done: n.done } } "throw" === l.type && (r = p, n.method = "throw", n.arg = l.arg) } } }(e, n, s), a } function u(e, t, n) { try { return { type: "normal", arg: e.call(t, n) } } catch (R) { return { type: "throw", arg: R } } } e.wrap = c; var d = "suspendedStart", h = "suspendedYield", f = "executing", p = "completed", m = {}; function g() { } function v() { } function b() { } var y = {}; l(y, a, (function () { return this })); var w = Object.getPrototypeOf, x = w && w(w(T([]))); x && x !== n && r.call(x, a) && (y = x); var _ = b.prototype = g.prototype = Object.create(y); function k(e) { ["next", "throw", "return"].forEach((function (t) { l(e, t, (function (e) { return this._invoke(t, e) })) })) } function S(e, t) { function n(i, a, s, o) { var l = u(e[i], e, a); if ("throw" !== l.type) { var c = l.arg, d = c.value; return d && "object" === typeof d && r.call(d, "__await") ? t.resolve(d.__await).then((function (e) { n("next", e, s, o) }), (function (e) { n("throw", e, s, o) })) : t.resolve(d).then((function (e) { c.value = e, s(c) }), (function (e) { return n("throw", e, s, o) })) } o(l.arg) } var i; this._invoke = function (e, r) { function a() { return new t((function (t, i) { n(e, r, t, i) })) } return i = i ? i.then(a, a) : a() } } function A(e, n) { var r = e.iterator[n.method]; if (r === t) { if (n.delegate = null, "throw" === n.method) { if (e.iterator.return && (n.method = "return", n.arg = t, A(e, n), "throw" === n.method)) return m; n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method") } return m } var i = u(r, e.iterator, n.arg); if ("throw" === i.type) return n.method = "throw", n.arg = i.arg, n.delegate = null, m; var a = i.arg; return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, m) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, m) } function E(e) { var t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t) } function C(e) { var t = e.completion || {}; t.type = "normal", delete t.arg, e.completion = t } function M(e) { this.tryEntries = [{ tryLoc: "root" }], e.forEach(E, this), this.reset(!0) } function T(e) { if (e) { var n = e[a]; if (n) return n.call(e); if ("function" === typeof e.next) return e; if (!isNaN(e.length)) { var i = -1, s = function n() { for (; ++i < e.length;)if (r.call(e, i)) return n.value = e[i], n.done = !1, n; return n.value = t, n.done = !0, n }; return s.next = s } } return { next: P } } function P() { return { value: t, done: !0 } } return v.prototype = b, l(_, "constructor", b), l(b, "constructor", v), v.displayName = l(b, o, "GeneratorFunction"), e.isGeneratorFunction = function (e) { var t = "function" === typeof e && e.constructor; return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name)) }, e.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, b) : (e.__proto__ = b, l(e, o, "GeneratorFunction")), e.prototype = Object.create(_), e }, e.awrap = function (e) { return { __await: e } }, k(S.prototype), l(S.prototype, s, (function () { return this })), e.AsyncIterator = S, e.async = function (t, n, r, i, a) { void 0 === a && (a = Promise); var s = new S(c(t, n, r, i), a); return e.isGeneratorFunction(n) ? s : s.next().then((function (e) { return e.done ? e.value : s.next() })) }, k(_), l(_, o, "Generator"), l(_, a, (function () { return this })), l(_, "toString", (function () { return "[object Generator]" })), e.keys = function (e) { var t = []; for (var n in e) t.push(n); return t.reverse(), function n() { for (; t.length;) { var r = t.pop(); if (r in e) return n.value = r, n.done = !1, n } return n.done = !0, n } }, e.values = T, M.prototype = { constructor: M, reset: function (e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(C), !e) for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t) }, stop: function () { this.done = !0; var e = this.tryEntries[0].completion; if ("throw" === e.type) throw e.arg; return this.rval }, dispatchException: function (e) { if (this.done) throw e; var n = this; function i(r, i) { return o.type = "throw", o.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i } for (var a = this.tryEntries.length - 1; a >= 0; --a) { var s = this.tryEntries[a], o = s.completion; if ("root" === s.tryLoc) return i("end"); if (s.tryLoc <= this.prev) { var l = r.call(s, "catchLoc"), c = r.call(s, "finallyLoc"); if (l && c) { if (this.prev < s.catchLoc) return i(s.catchLoc, !0); if (this.prev < s.finallyLoc) return i(s.finallyLoc) } else if (l) { if (this.prev < s.catchLoc) return i(s.catchLoc, !0) } else { if (!c) throw new Error("try statement without catch or finally"); if (this.prev < s.finallyLoc) return i(s.finallyLoc) } } } }, abrupt: function (e, t) { for (var n = this.tryEntries.length - 1; n >= 0; --n) { var i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) { var a = i; break } } a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null); var s = a ? a.completion : {}; return s.type = e, s.arg = t, a ? (this.method = "next", this.next = a.finallyLoc, m) : this.complete(s) }, complete: function (e, t) { if ("throw" === e.type) throw e.arg; return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), m }, finish: function (e) { for (var t = this.tryEntries.length - 1; t >= 0; --t) { var n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), C(n), m } }, catch: function (e) { for (var t = this.tryEntries.length - 1; t >= 0; --t) { var n = this.tryEntries[t]; if (n.tryLoc === e) { var r = n.completion; if ("throw" === r.type) { var i = r.arg; C(n) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (e, n, r) { return this.delegate = { iterator: T(e), resultName: n, nextLoc: r }, "next" === this.method && (this.arg = t), m } }, e }(e.exports); try { regeneratorRuntime = t } catch (n) { "object" === typeof globalThis ? globalThis.regeneratorRuntime = t : Function("r", "regeneratorRuntime = r")(t) } })), svgToPath = function (e) { var t = e.indexOf('d="'), n = e.indexOf('"', t + 3); return e.substring(t + 3, n) }, url = "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/", cache = {}, fallback = "", getSlugPath = function () { var e = _asyncToGenerator(runtime_1.mark((function e(t) { var n, r, i, a; return runtime_1.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (cache[t]) { e.next = 15; break } return e.prev = 1, n = "" + url + t + ".svg", e.next = 5, fetch(n, { cache: "force-cache" }); case 5: return r = e.sent, e.next = 8, r.text(); case 8: i = e.sent, a = svgToPath(i), cache[t] = a, e.next = 15; break; case 13: e.prev = 13, e.t0 = e.catch(1); case 15: if (!cache[t]) { e.next = 17; break } return e.abrupt("return", cache[t]); case 17: return e.abrupt("return", fallback); case 18: case "end": return e.stop() } }), e, null, [[1, 13]]) }))); return function (t) { return e.apply(this, arguments) } }(), getSlugsPath = function () { var e = _asyncToGenerator(runtime_1.mark((function e(t) { var n; return runtime_1.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: return n = {}, t.forEach((function (e) { n[e] = e })), e.next = 4, Promise.all(Object.keys(n).map(getSlugPath)); case 4: return e.abrupt("return", t.map((function (e) { var t; return { slug: e, path: null != (t = cache[e]) ? t : fallback } }))); case 5: case "end": return e.stop() } }), e) }))); return function (t) { return e.apply(this, arguments) } }(), TITLE_TO_SLUG_REPLACEMENTS = { "+": "plus", ".": "dot", "&": "and", "\u0111": "d", "\u0127": "h", "\u0131": "i", "\u0138": "k", "\u0140": "l", "\u0142": "l", "\xdf": "ss", "\u0167": "t" }, TITLE_TO_SLUG_CHARS_REGEX = RegExp("[" + Object.keys(TITLE_TO_SLUG_REPLACEMENTS).join("") + "]", "g"), TITLE_TO_SLUG_RANGE_REGEX = /[^a-z0-9]/g, getSlug = function (e) { return e.title.toLowerCase().replace(TITLE_TO_SLUG_CHARS_REGEX, (function (e) { return TITLE_TO_SLUG_REPLACEMENTS[e] })).normalize("NFD").replace(TITLE_TO_SLUG_RANGE_REGEX, "") }, url$1 = "https://raw.githubusercontent.com/simple-icons/simple-icons/develop/_data/simple-icons.json", cache$1, fallback$1 = "#000", primeCache = function () { var e = _asyncToGenerator(runtime_1.mark((function e() { var t, n; return runtime_1.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (cache$1) { e.next = 14; break } return e.prev = 1, e.next = 4, fetch(url$1, { cache: "force-cache" }); case 4: return t = e.sent, e.next = 7, t.json(); case 7: n = e.sent, cache$1 = {}, n.icons.forEach((function (e) { var t, n = getSlug({ title: e.title }); cache$1[n] = { hex: addHash(null != (t = e.hex) ? t : fallback$1), title: e.title, slug: n } })), e.next = 14; break; case 12: e.prev = 12, e.t0 = e.catch(1); case 14: case "end": return e.stop() } }), e, null, [[1, 12]]) }))); return function () { return e.apply(this, arguments) } }(), getSlugHexs = function () { var e = _asyncToGenerator(runtime_1.mark((function e(t) { return runtime_1.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, primeCache(); case 2: return e.abrupt("return", { hexs: t.map((function (e) { var t, n, r, i; return { slug: e, hex: cache$1 && null != (t = null == (n = cache$1[e]) ? void 0 : n.hex) ? t : fallback$1, title: cache$1 && null != (r = null == (i = cache$1[e]) ? void 0 : i.title) ? r : "icon" } })), cache: cache$1 }); case 3: case "end": return e.stop() } }), e) }))); return function (t) { return e.apply(this, arguments) } }(), fetchSimpleIcons = function () { var e = _asyncToGenerator(runtime_1.mark((function e(t) { var n, r, i, a, s, o, l; return runtime_1.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: return n = t.slugs, e.next = 3, Promise.all([getSlugsPath(n), getSlugHexs(n)]); case 3: return r = e.sent, i = r[0], a = r[1], s = a.hexs, o = a.cache, l = {}, s.forEach((function (e) { l[e.slug] = e })), i.forEach((function (e) { l[e.slug].path = e.path })), n.forEach((function (e) { var t = l[e]; t.hex && t.path || delete l[e] })), e.abrupt("return", { simpleIcons: l, allIcon: o }); case 13: case "end": return e.stop() } }), e) }))); return function (t) { return e.apply(this, arguments) } }() }, 153: (e, t, n) => { "use strict"; var r = n(43), i = Symbol.for("react.element"), a = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, o = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, a = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) s.call(t, r) && !l.hasOwnProperty(r) && (a[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === a[r] && (a[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: a, _owner: o.current } } t.Fragment = a, t.jsx = c, t.jsxs = c }, 202: (e, t) => { "use strict"; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.iterator; var p = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function v(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } function b() { } function y(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } v.prototype.isReactComponent = {}, v.prototype.setState = function (e, t) { if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, v.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, b.prototype = v.prototype; var w = y.prototype = new b; w.constructor = y, m(w, v.prototype), w.isPureReactComponent = !0; var x = Array.isArray, _ = Object.prototype.hasOwnProperty, k = { current: null }, S = { key: !0, ref: !0, __self: !0, __source: !0 }; function A(e, t, r) { var i, a = {}, s = null, o = null; if (null != t) for (i in void 0 !== t.ref && (o = t.ref), void 0 !== t.key && (s = "" + t.key), t) _.call(t, i) && !S.hasOwnProperty(i) && (a[i] = t[i]); var l = arguments.length - 2; if (1 === l) a.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; a.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === a[i] && (a[i] = l[i]); return { $$typeof: n, type: e, key: s, ref: o, props: a, _owner: k.current } } function E(e) { return "object" === typeof e && null !== e && e.$$typeof === n } var C = /\/+/g; function M(e, t) { return "object" === typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function T(e, t, i, a, s) { var o = typeof e; "undefined" !== o && "boolean" !== o || (e = null); var l = !1; if (null === e) l = !0; else switch (o) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return s = s(l = e), e = "" === a ? "." + M(l, 0) : a, x(s) ? (i = "", null != e && (i = e.replace(C, "$&/") + "/"), T(s, t, i, "", (function (e) { return e }))) : null != s && (E(s) && (s = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(s, i + (!s.key || l && l.key === s.key ? "" : ("" + s.key).replace(C, "$&/") + "/") + e)), t.push(s)), 1; if (l = 0, a = "" === a ? "." : a + ":", x(e)) for (var c = 0; c < e.length; c++) { var u = a + M(o = e[c], c); l += T(o, t, i, u, s) } else if (u = function (e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = f && e[f] || e["@@iterator"]) ? e : null }(e), "function" === typeof u) for (e = u.call(e), c = 0; !(o = e.next()).done;)l += T(o = o.value, t, i, u = a + M(o, c++), s); else if ("object" === o) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function P(e, t, n) { if (null == e) return e; var r = [], i = 0; return T(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function R(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var N = { current: null }, L = { transition: null }, I = { ReactCurrentDispatcher: N, ReactCurrentBatchConfig: L, ReactCurrentOwner: k }; function D() { throw Error("act(...) is not supported in production builds of React.") } t.Children = { map: P, forEach: function (e, t, n) { P(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return P(e, (function () { t++ })), t }, toArray: function (e) { return P(e, (function (e) { return e })) || [] }, only: function (e) { if (!E(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = v, t.Fragment = i, t.Profiler = s, t.PureComponent = y, t.StrictMode = a, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = I, t.act = D, t.cloneElement = function (e, t, r) { if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = m({}, e.props), a = e.key, s = e.ref, o = e._owner; if (null != t) { if (void 0 !== t.ref && (s = t.ref, o = k.current), void 0 !== t.key && (a = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) _.call(t, c) && !S.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: a, ref: s, props: i, _owner: o } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: o, _context: e }, e.Consumer = e }, t.createElement = A, t.createFactory = function (e) { var t = A.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = E, t.lazy = function (e) { return { $$typeof: h, _payload: { _status: -1, _result: e }, _init: R } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = L.transition; L.transition = {}; try { e() } finally { L.transition = t } }, t.unstable_act = D, t.useCallback = function (e, t) { return N.current.useCallback(e, t) }, t.useContext = function (e) { return N.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return N.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return N.current.useEffect(e, t) }, t.useId = function () { return N.current.useId() }, t.useImperativeHandle = function (e, t, n) { return N.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return N.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return N.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return N.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return N.current.useReducer(e, t, n) }, t.useRef = function (e) { return N.current.useRef(e) }, t.useState = function (e) { return N.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return N.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return N.current.useTransition() }, t.version = "18.3.1" }, 43: (e, t, n) => { "use strict"; e.exports = n(202) }, 579: (e, t, n) => { "use strict"; e.exports = n(153) }, 234: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < a(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, s = i >>> 1; r < s;) { var o = 2 * (r + 1) - 1, l = e[o], c = o + 1, u = e[c]; if (0 > a(l, n)) c < i && 0 > a(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[o] = n, r = o); else { if (!(c < i && 0 > a(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function a(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" === typeof performance && "function" === typeof performance.now) { var s = performance; t.unstable_now = function () { return s.now() } } else { var o = Date, l = o.now(); t.unstable_now = function () { return o.now() - l } } var c = [], u = [], d = 1, h = null, f = 3, p = !1, m = !1, g = !1, v = "function" === typeof setTimeout ? setTimeout : null, b = "function" === typeof clearTimeout ? clearTimeout : null, y = "undefined" !== typeof setImmediate ? setImmediate : null; function w(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function x(e) { if (g = !1, w(e), !m) if (null !== r(c)) m = !0, L(_); else { var t = r(u); null !== t && I(x, t.startTime - e) } } function _(e, n) { m = !1, g && (g = !1, b(E), E = -1), p = !0; var a = f; try { for (w(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !T());) { var s = h.callback; if ("function" === typeof s) { h.callback = null, f = h.priorityLevel; var o = s(h.expirationTime <= n); n = t.unstable_now(), "function" === typeof o ? h.callback = o : h === r(c) && i(c), w(n) } else i(c); h = r(c) } if (null !== h) var l = !0; else { var d = r(u); null !== d && I(x, d.startTime - n), l = !1 } return l } finally { h = null, f = a, p = !1 } } "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var k, S = !1, A = null, E = -1, C = 5, M = -1; function T() { return !(t.unstable_now() - M < C) } function P() { if (null !== A) { var e = t.unstable_now(); M = e; var n = !0; try { n = A(!0, e) } finally { n ? k() : (S = !1, A = null) } } else S = !1 } if ("function" === typeof y) k = function () { y(P) }; else if ("undefined" !== typeof MessageChannel) { var R = new MessageChannel, N = R.port2; R.port1.onmessage = P, k = function () { N.postMessage(null) } } else k = function () { v(P, 0) }; function L(e) { A = e, S || (S = !0, k()) } function I(e, n) { E = v((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || p || (m = !0, L(_)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (f) { case 1: case 2: case 3: var t = 3; break; default: t = f }var n = f; f = t; try { return e() } finally { f = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = f; f = e; try { return t() } finally { f = n } }, t.unstable_scheduleCallback = function (e, i, a) { var s = t.unstable_now(); switch ("object" === typeof a && null !== a ? a = "number" === typeof (a = a.delay) && 0 < a ? s + a : s : a = s, e) { case 1: var o = -1; break; case 2: o = 250; break; case 5: o = 1073741823; break; case 4: o = 1e4; break; default: o = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: a, expirationTime: o = a + o, sortIndex: -1 }, a > s ? (e.sortIndex = a, n(u, e), null === r(c) && e === r(u) && (g ? (b(E), E = -1) : g = !0, I(x, a - s))) : (e.sortIndex = o, n(c, e), m || p || (m = !0, L(_))), e }, t.unstable_shouldYield = T, t.unstable_wrapCallback = function (e) { var t = f; return function () { var n = f; f = t; try { return e.apply(this, arguments) } finally { f = n } } } }, 853: (e, t, n) => { "use strict"; e.exports = n(234) }, 23: function (e, t, n) { !function (t, r) { e.exports = r(n(43)) }("undefined" != typeof self && self, (e => (() => { var t = { 7403: (e, t, n) => { "use strict"; n.d(t, { default: () => E }); var r = n(4087), i = n.n(r); const a = function (e) { return new RegExp(/<[a-z][\s\S]*>/i).test(e) }, s = function (e, t) { return Math.floor(Math.random() * (t - e + 1)) + e }; var o = "TYPE_CHARACTER", l = "REMOVE_CHARACTER", c = "REMOVE_ALL", u = "REMOVE_LAST_VISIBLE_NODE", d = "PAUSE_FOR", h = "CALL_FUNCTION", f = "ADD_HTML_TAG_ELEMENT", p = "CHANGE_DELETE_SPEED", m = "CHANGE_DELAY", g = "CHANGE_CURSOR", v = "PASTE_STRING", b = "HTML_TAG"; function y(e) { return y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, y(e) } function w(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, r) } return n } function x(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? w(Object(n), !0).forEach((function (t) { S(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function _(e) { return function (e) { if (Array.isArray(e)) return k(e) }(e) || function (e) { if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e) }(e) || function (e, t) { if (e) { if ("string" == typeof e) return k(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? k(e, t) : void 0 } }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function k(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function S(e, t, n) { return (t = A(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function A(e) { var t = function (e) { if ("object" !== y(e) || null === e) return e; var t = e[Symbol.toPrimitive]; if (void 0 !== t) { var n = t.call(e, "string"); if ("object" !== y(n)) return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e); return "symbol" === y(t) ? t : String(t) } const E = function () { function e(t, n) { var y = this; if (function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), S(this, "state", { cursorAnimation: null, lastFrameTime: null, pauseUntil: null, eventQueue: [], eventLoop: null, eventLoopPaused: !1, reverseCalledEvents: [], calledEvents: [], visibleNodes: [], initialOptions: null, elements: { container: null, wrapper: document.createElement("span"), cursor: document.createElement("span") } }), S(this, "options", { strings: null, cursor: "|", delay: "natural", pauseFor: 1500, deleteSpeed: "natural", loop: !1, autoStart: !1, devMode: !1, skipAddStyles: !1, wrapperClassName: "Typewriter__wrapper", cursorClassName: "Typewriter__cursor", stringSplitter: null, onCreateTextNode: null, onRemoveNode: null }), S(this, "setupWrapperElement", (function () { y.state.elements.container && (y.state.elements.wrapper.className = y.options.wrapperClassName, y.state.elements.cursor.className = y.options.cursorClassName, y.state.elements.cursor.innerHTML = y.options.cursor, y.state.elements.container.innerHTML = "", y.state.elements.container.appendChild(y.state.elements.wrapper), y.state.elements.container.appendChild(y.state.elements.cursor)) })), S(this, "start", (function () { return y.state.eventLoopPaused = !1, y.runEventLoop(), y })), S(this, "pause", (function () { return y.state.eventLoopPaused = !0, y })), S(this, "stop", (function () { return y.state.eventLoop && ((0, r.cancel)(y.state.eventLoop), y.state.eventLoop = null), y })), S(this, "pauseFor", (function (e) { return y.addEventToQueue(d, { ms: e }), y })), S(this, "typeOutAllStrings", (function () { return "string" == typeof y.options.strings ? (y.typeString(y.options.strings).pauseFor(y.options.pauseFor), y) : (y.options.strings.forEach((function (e) { y.typeString(e).pauseFor(y.options.pauseFor).deleteAll(y.options.deleteSpeed) })), y) })), S(this, "typeString", (function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (a(e)) return y.typeOutHTMLString(e, t); if (e) { var n = (y.options || {}).stringSplitter, r = "function" == typeof n ? n(e) : e.split(""); y.typeCharacters(r, t) } return y })), S(this, "pasteString", (function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return a(e) ? y.typeOutHTMLString(e, t, !0) : (e && y.addEventToQueue(v, { character: e, node: t }), y) })), S(this, "typeOutHTMLString", (function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 ? arguments[2] : void 0, r = function (e) { var t = document.createElement("div"); return t.innerHTML = e, t.childNodes }(e); if (r.length > 0) for (var i = 0; i < r.length; i++) { var a = r[i], s = a.innerHTML; a && 3 !== a.nodeType ? (a.innerHTML = "", y.addEventToQueue(f, { node: a, parentNode: t }), n ? y.pasteString(s, a) : y.typeString(s, a)) : a.textContent && (n ? y.pasteString(a.textContent, t) : y.typeString(a.textContent, t)) } return y })), S(this, "deleteAll", (function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "natural"; return y.addEventToQueue(c, { speed: e }), y })), S(this, "changeDeleteSpeed", (function (e) { if (!e) throw new Error("Must provide new delete speed"); return y.addEventToQueue(p, { speed: e }), y })), S(this, "changeDelay", (function (e) { if (!e) throw new Error("Must provide new delay"); return y.addEventToQueue(m, { delay: e }), y })), S(this, "changeCursor", (function (e) { if (!e) throw new Error("Must provide new cursor"); return y.addEventToQueue(g, { cursor: e }), y })), S(this, "deleteChars", (function (e) { if (!e) throw new Error("Must provide amount of characters to delete"); for (var t = 0; t < e; t++)y.addEventToQueue(l); return y })), S(this, "callFunction", (function (e, t) { if (!e || "function" != typeof e) throw new Error("Callback must be a function"); return y.addEventToQueue(h, { cb: e, thisArg: t }), y })), S(this, "typeCharacters", (function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (!e || !Array.isArray(e)) throw new Error("Characters must be an array"); return e.forEach((function (e) { y.addEventToQueue(o, { character: e, node: t }) })), y })), S(this, "removeCharacters", (function (e) { if (!e || !Array.isArray(e)) throw new Error("Characters must be an array"); return e.forEach((function () { y.addEventToQueue(l) })), y })), S(this, "addEventToQueue", (function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return y.addEventToStateProperty(e, t, n, "eventQueue") })), S(this, "addReverseCalledEvent", (function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return y.options.loop ? y.addEventToStateProperty(e, t, n, "reverseCalledEvents") : y })), S(this, "addEventToStateProperty", (function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = arguments.length > 3 ? arguments[3] : void 0, i = { eventName: e, eventArgs: t || {} }; return y.state[r] = n ? [i].concat(_(y.state[r])) : [].concat(_(y.state[r]), [i]), y })), S(this, "runEventLoop", (function () { y.state.lastFrameTime || (y.state.lastFrameTime = Date.now()); var e = Date.now(), t = e - y.state.lastFrameTime; if (!y.state.eventQueue.length) { if (!y.options.loop) return; y.state.eventQueue = _(y.state.calledEvents), y.state.calledEvents = [], y.options = x({}, y.state.initialOptions) } if (y.state.eventLoop = i()(y.runEventLoop), !y.state.eventLoopPaused) { if (y.state.pauseUntil) { if (e < y.state.pauseUntil) return; y.state.pauseUntil = null } var n, r = _(y.state.eventQueue), a = r.shift(); if (!(t <= (n = a.eventName === u || a.eventName === l ? "natural" === y.options.deleteSpeed ? s(40, 80) : y.options.deleteSpeed : "natural" === y.options.delay ? s(120, 160) : y.options.delay))) { var w = a.eventName, k = a.eventArgs; switch (y.logInDevMode({ currentEvent: a, state: y.state, delay: n }), w) { case v: case o: var S = k.character, A = k.node, E = document.createTextNode(S), C = E; y.options.onCreateTextNode && "function" == typeof y.options.onCreateTextNode && (C = y.options.onCreateTextNode(S, E)), C && (A ? A.appendChild(C) : y.state.elements.wrapper.appendChild(C)), y.state.visibleNodes = [].concat(_(y.state.visibleNodes), [{ type: "TEXT_NODE", character: S, node: C }]); break; case l: r.unshift({ eventName: u, eventArgs: { removingCharacterNode: !0 } }); break; case d: var M = a.eventArgs.ms; y.state.pauseUntil = Date.now() + parseInt(M); break; case h: var T = a.eventArgs, P = T.cb, R = T.thisArg; P.call(R, { elements: y.state.elements }); break; case f: var N = a.eventArgs, L = N.node, I = N.parentNode; I ? I.appendChild(L) : y.state.elements.wrapper.appendChild(L), y.state.visibleNodes = [].concat(_(y.state.visibleNodes), [{ type: b, node: L, parentNode: I || y.state.elements.wrapper }]); break; case c: var D = y.state.visibleNodes, O = k.speed, j = []; O && j.push({ eventName: p, eventArgs: { speed: O, temp: !0 } }); for (var F = 0, z = D.length; F < z; F++)j.push({ eventName: u, eventArgs: { removingCharacterNode: !1 } }); O && j.push({ eventName: p, eventArgs: { speed: y.options.deleteSpeed, temp: !0 } }), r.unshift.apply(r, j); break; case u: var W = a.eventArgs.removingCharacterNode; if (y.state.visibleNodes.length) { var B = y.state.visibleNodes.pop(), H = B.type, U = B.node, V = B.character; y.options.onRemoveNode && "function" == typeof y.options.onRemoveNode && y.options.onRemoveNode({ node: U, character: V }), U && U.parentNode.removeChild(U), H === b && W && r.unshift({ eventName: u, eventArgs: {} }) } break; case p: y.options.deleteSpeed = a.eventArgs.speed; break; case m: y.options.delay = a.eventArgs.delay; break; case g: y.options.cursor = a.eventArgs.cursor, y.state.elements.cursor.innerHTML = a.eventArgs.cursor }y.options.loop && (a.eventName === u || a.eventArgs && a.eventArgs.temp || (y.state.calledEvents = [].concat(_(y.state.calledEvents), [a]))), y.state.eventQueue = r, y.state.lastFrameTime = e } } })), t) if ("string" == typeof t) { var w = document.querySelector(t); if (!w) throw new Error("Could not find container element"); this.state.elements.container = w } else this.state.elements.container = t; n && (this.options = x(x({}, this.options), n)), this.state.initialOptions = x({}, this.options), this.init() } var t, n; return t = e, (n = [{ key: "init", value: function () { var e; this.setupWrapperElement(), this.addEventToQueue(g, { cursor: this.options.cursor }, !0), this.addEventToQueue(c, null, !0), !window || window.___TYPEWRITER_JS_STYLES_ADDED___ || this.options.skipAddStyles || ((e = document.createElement("style")).appendChild(document.createTextNode(".Typewriter__cursor{-webkit-animation:Typewriter-cursor 1s infinite;animation:Typewriter-cursor 1s infinite;margin-left:1px}@-webkit-keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}@keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}")), document.head.appendChild(e), window.___TYPEWRITER_JS_STYLES_ADDED___ = !0), !0 === this.options.autoStart && this.options.strings && this.typeOutAllStrings().start() } }, { key: "logInDevMode", value: function (e) { this.options.devMode && console.log(e) } }]) && function (e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, A(r.key), r) } }(t.prototype, n), Object.defineProperty(t, "prototype", { writable: !1 }), e }() }, 8552: (e, t, n) => { var r = n(852)(n(5639), "DataView"); e.exports = r }, 1989: (e, t, n) => { var r = n(1789), i = n(401), a = n(7667), s = n(1327), o = n(1866); function l(e) { var t = -1, n = null == e ? 0 : e.length; for (this.clear(); ++t < n;) { var r = e[t]; this.set(r[0], r[1]) } } l.prototype.clear = r, l.prototype.delete = i, l.prototype.get = a, l.prototype.has = s, l.prototype.set = o, e.exports = l }, 8407: (e, t, n) => { var r = n(7040), i = n(4125), a = n(2117), s = n(7518), o = n(4705); function l(e) { var t = -1, n = null == e ? 0 : e.length; for (this.clear(); ++t < n;) { var r = e[t]; this.set(r[0], r[1]) } } l.prototype.clear = r, l.prototype.delete = i, l.prototype.get = a, l.prototype.has = s, l.prototype.set = o, e.exports = l }, 7071: (e, t, n) => { var r = n(852)(n(5639), "Map"); e.exports = r }, 3369: (e, t, n) => { var r = n(4785), i = n(1285), a = n(6e3), s = n(9916), o = n(5265); function l(e) { var t = -1, n = null == e ? 0 : e.length; for (this.clear(); ++t < n;) { var r = e[t]; this.set(r[0], r[1]) } } l.prototype.clear = r, l.prototype.delete = i, l.prototype.get = a, l.prototype.has = s, l.prototype.set = o, e.exports = l }, 3818: (e, t, n) => { var r = n(852)(n(5639), "Promise"); e.exports = r }, 8525: (e, t, n) => { var r = n(852)(n(5639), "Set"); e.exports = r }, 8668: (e, t, n) => { var r = n(3369), i = n(619), a = n(2385); function s(e) { var t = -1, n = null == e ? 0 : e.length; for (this.__data__ = new r; ++t < n;)this.add(e[t]) } s.prototype.add = s.prototype.push = i, s.prototype.has = a, e.exports = s }, 6384: (e, t, n) => { var r = n(8407), i = n(7465), a = n(3779), s = n(7599), o = n(4758), l = n(4309); function c(e) { var t = this.__data__ = new r(e); this.size = t.size } c.prototype.clear = i, c.prototype.delete = a, c.prototype.get = s, c.prototype.has = o, c.prototype.set = l, e.exports = c }, 2705: (e, t, n) => { var r = n(5639).Symbol; e.exports = r }, 1149: (e, t, n) => { var r = n(5639).Uint8Array; e.exports = r }, 577: (e, t, n) => { var r = n(852)(n(5639), "WeakMap"); e.exports = r }, 4963: e => { e.exports = function (e, t) { for (var n = -1, r = null == e ? 0 : e.length, i = 0, a = []; ++n < r;) { var s = e[n]; t(s, n, e) && (a[i++] = s) } return a } }, 4636: (e, t, n) => { var r = n(2545), i = n(5694), a = n(1469), s = n(4144), o = n(5776), l = n(6719), c = Object.prototype.hasOwnProperty; e.exports = function (e, t) { var n = a(e), u = !n && i(e), d = !n && !u && s(e), h = !n && !u && !d && l(e), f = n || u || d || h, p = f ? r(e.length, String) : [], m = p.length; for (var g in e) !t && !c.call(e, g) || f && ("length" == g || d && ("offset" == g || "parent" == g) || h && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || o(g, m)) || p.push(g); return p } }, 2488: e => { e.exports = function (e, t) { for (var n = -1, r = t.length, i = e.length; ++n < r;)e[i + n] = t[n]; return e } }, 2908: e => { e.exports = function (e, t) { for (var n = -1, r = null == e ? 0 : e.length; ++n < r;)if (t(e[n], n, e)) return !0; return !1 } }, 8470: (e, t, n) => { var r = n(7813); e.exports = function (e, t) { for (var n = e.length; n--;)if (r(e[n][0], t)) return n; return -1 } }, 8866: (e, t, n) => { var r = n(2488), i = n(1469); e.exports = function (e, t, n) { var a = t(e); return i(e) ? a : r(a, n(e)) } }, 4239: (e, t, n) => { var r = n(2705), i = n(9607), a = n(2333), s = r ? r.toStringTag : void 0; e.exports = function (e) { return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : s && s in Object(e) ? i(e) : a(e) } }, 9454: (e, t, n) => { var r = n(4239), i = n(7005); e.exports = function (e) { return i(e) && "[object Arguments]" == r(e) } }, 939: (e, t, n) => { var r = n(2492), i = n(7005); e.exports = function e(t, n, a, s, o) { return t === n || (null == t || null == n || !i(t) && !i(n) ? t != t && n != n : r(t, n, a, s, e, o)) } }, 2492: (e, t, n) => { var r = n(6384), i = n(7114), a = n(8351), s = n(6096), o = n(4160), l = n(1469), c = n(4144), u = n(6719), d = "[object Arguments]", h = "[object Array]", f = "[object Object]", p = Object.prototype.hasOwnProperty; e.exports = function (e, t, n, m, g, v) { var b = l(e), y = l(t), w = b ? h : o(e), x = y ? h : o(t), _ = (w = w == d ? f : w) == f, k = (x = x == d ? f : x) == f, S = w == x; if (S && c(e)) { if (!c(t)) return !1; b = !0, _ = !1 } if (S && !_) return v || (v = new r), b || u(e) ? i(e, t, n, m, g, v) : a(e, t, w, n, m, g, v); if (!(1 & n)) { var A = _ && p.call(e, "__wrapped__"), E = k && p.call(t, "__wrapped__"); if (A || E) { var C = A ? e.value() : e, M = E ? t.value() : t; return v || (v = new r), g(C, M, n, m, v) } } return !!S && (v || (v = new r), s(e, t, n, m, g, v)) } }, 8458: (e, t, n) => { var r = n(3560), i = n(5346), a = n(3218), s = n(346), o = /^\[object .+?Constructor\]$/, l = Function.prototype, c = Object.prototype, u = l.toString, d = c.hasOwnProperty, h = RegExp("^" + u.call(d).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); e.exports = function (e) { return !(!a(e) || i(e)) && (r(e) ? h : o).test(s(e)) } }, 8749: (e, t, n) => { var r = n(4239), i = n(1780), a = n(7005), s = {}; s["[object Float32Array]"] = s["[object Float64Array]"] = s["[object Int8Array]"] = s["[object Int16Array]"] = s["[object Int32Array]"] = s["[object Uint8Array]"] = s["[object Uint8ClampedArray]"] = s["[object Uint16Array]"] = s["[object Uint32Array]"] = !0, s["[object Arguments]"] = s["[object Array]"] = s["[object ArrayBuffer]"] = s["[object Boolean]"] = s["[object DataView]"] = s["[object Date]"] = s["[object Error]"] = s["[object Function]"] = s["[object Map]"] = s["[object Number]"] = s["[object Object]"] = s["[object RegExp]"] = s["[object Set]"] = s["[object String]"] = s["[object WeakMap]"] = !1, e.exports = function (e) { return a(e) && i(e.length) && !!s[r(e)] } }, 280: (e, t, n) => { var r = n(5726), i = n(6916), a = Object.prototype.hasOwnProperty; e.exports = function (e) { if (!r(e)) return i(e); var t = []; for (var n in Object(e)) a.call(e, n) && "constructor" != n && t.push(n); return t } }, 2545: e => { e.exports = function (e, t) { for (var n = -1, r = Array(e); ++n < e;)r[n] = t(n); return r } }, 1717: e => { e.exports = function (e) { return function (t) { return e(t) } } }, 4757: e => { e.exports = function (e, t) { return e.has(t) } }, 4429: (e, t, n) => { var r = n(5639)["__core-js_shared__"]; e.exports = r }, 7114: (e, t, n) => { var r = n(8668), i = n(2908), a = n(4757); e.exports = function (e, t, n, s, o, l) { var c = 1 & n, u = e.length, d = t.length; if (u != d && !(c && d > u)) return !1; var h = l.get(e), f = l.get(t); if (h && f) return h == t && f == e; var p = -1, m = !0, g = 2 & n ? new r : void 0; for (l.set(e, t), l.set(t, e); ++p < u;) { var v = e[p], b = t[p]; if (s) var y = c ? s(b, v, p, t, e, l) : s(v, b, p, e, t, l); if (void 0 !== y) { if (y) continue; m = !1; break } if (g) { if (!i(t, (function (e, t) { if (!a(g, t) && (v === e || o(v, e, n, s, l))) return g.push(t) }))) { m = !1; break } } else if (v !== b && !o(v, b, n, s, l)) { m = !1; break } } return l.delete(e), l.delete(t), m } }, 8351: (e, t, n) => { var r = n(2705), i = n(1149), a = n(7813), s = n(7114), o = n(8776), l = n(1814), c = r ? r.prototype : void 0, u = c ? c.valueOf : void 0; e.exports = function (e, t, n, r, c, d, h) { switch (n) { case "[object DataView]": if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1; e = e.buffer, t = t.buffer; case "[object ArrayBuffer]": return !(e.byteLength != t.byteLength || !d(new i(e), new i(t))); case "[object Boolean]": case "[object Date]": case "[object Number]": return a(+e, +t); case "[object Error]": return e.name == t.name && e.message == t.message; case "[object RegExp]": case "[object String]": return e == t + ""; case "[object Map]": var f = o; case "[object Set]": var p = 1 & r; if (f || (f = l), e.size != t.size && !p) return !1; var m = h.get(e); if (m) return m == t; r |= 2, h.set(e, t); var g = s(f(e), f(t), r, c, d, h); return h.delete(e), g; case "[object Symbol]": if (u) return u.call(e) == u.call(t) }return !1 } }, 6096: (e, t, n) => { var r = n(8234), i = Object.prototype.hasOwnProperty; e.exports = function (e, t, n, a, s, o) { var l = 1 & n, c = r(e), u = c.length; if (u != r(t).length && !l) return !1; for (var d = u; d--;) { var h = c[d]; if (!(l ? h in t : i.call(t, h))) return !1 } var f = o.get(e), p = o.get(t); if (f && p) return f == t && p == e; var m = !0; o.set(e, t), o.set(t, e); for (var g = l; ++d < u;) { var v = e[h = c[d]], b = t[h]; if (a) var y = l ? a(b, v, h, t, e, o) : a(v, b, h, e, t, o); if (!(void 0 === y ? v === b || s(v, b, n, a, o) : y)) { m = !1; break } g || (g = "constructor" == h) } if (m && !g) { var w = e.constructor, x = t.constructor; w == x || !("constructor" in e) || !("constructor" in t) || "function" == typeof w && w instanceof w && "function" == typeof x && x instanceof x || (m = !1) } return o.delete(e), o.delete(t), m } }, 1957: (e, t, n) => { var r = "object" == typeof n.g && n.g && n.g.Object === Object && n.g; e.exports = r }, 8234: (e, t, n) => { var r = n(8866), i = n(9551), a = n(3674); e.exports = function (e) { return r(e, a, i) } }, 5050: (e, t, n) => { var r = n(7019); e.exports = function (e, t) { var n = e.__data__; return r(t) ? n["string" == typeof t ? "string" : "hash"] : n.map } }, 852: (e, t, n) => { var r = n(8458), i = n(7801); e.exports = function (e, t) { var n = i(e, t); return r(n) ? n : void 0 } }, 9607: (e, t, n) => { var r = n(2705), i = Object.prototype, a = i.hasOwnProperty, s = i.toString, o = r ? r.toStringTag : void 0; e.exports = function (e) { var t = a.call(e, o), n = e[o]; try { e[o] = void 0; var r = !0 } catch (e) { } var i = s.call(e); return r && (t ? e[o] = n : delete e[o]), i } }, 9551: (e, t, n) => { var r = n(4963), i = n(479), a = Object.prototype.propertyIsEnumerable, s = Object.getOwnPropertySymbols, o = s ? function (e) { return null == e ? [] : (e = Object(e), r(s(e), (function (t) { return a.call(e, t) }))) } : i; e.exports = o }, 4160: (e, t, n) => { var r = n(8552), i = n(7071), a = n(3818), s = n(8525), o = n(577), l = n(4239), c = n(346), u = "[object Map]", d = "[object Promise]", h = "[object Set]", f = "[object WeakMap]", p = "[object DataView]", m = c(r), g = c(i), v = c(a), b = c(s), y = c(o), w = l; (r && w(new r(new ArrayBuffer(1))) != p || i && w(new i) != u || a && w(a.resolve()) != d || s && w(new s) != h || o && w(new o) != f) && (w = function (e) { var t = l(e), n = "[object Object]" == t ? e.constructor : void 0, r = n ? c(n) : ""; if (r) switch (r) { case m: return p; case g: return u; case v: return d; case b: return h; case y: return f }return t }), e.exports = w }, 7801: e => { e.exports = function (e, t) { return null == e ? void 0 : e[t] } }, 1789: (e, t, n) => { var r = n(4536); e.exports = function () { this.__data__ = r ? r(null) : {}, this.size = 0 } }, 401: e => { e.exports = function (e) { var t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t } }, 7667: (e, t, n) => { var r = n(4536), i = Object.prototype.hasOwnProperty; e.exports = function (e) { var t = this.__data__; if (r) { var n = t[e]; return "__lodash_hash_undefined__" === n ? void 0 : n } return i.call(t, e) ? t[e] : void 0 } }, 1327: (e, t, n) => { var r = n(4536), i = Object.prototype.hasOwnProperty; e.exports = function (e) { var t = this.__data__; return r ? void 0 !== t[e] : i.call(t, e) } }, 1866: (e, t, n) => { var r = n(4536); e.exports = function (e, t) { var n = this.__data__; return this.size += this.has(e) ? 0 : 1, n[e] = r && void 0 === t ? "__lodash_hash_undefined__" : t, this } }, 5776: e => { var t = /^(?:0|[1-9]\d*)$/; e.exports = function (e, n) { var r = typeof e; return !!(n = null == n ? 9007199254740991 : n) && ("number" == r || "symbol" != r && t.test(e)) && e > -1 && e % 1 == 0 && e < n } }, 7019: e => { e.exports = function (e) { var t = typeof e; return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e } }, 5346: (e, t, n) => { var r, i = n(4429), a = (r = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || "")) ? "Symbol(src)_1." + r : ""; e.exports = function (e) { return !!a && a in e } }, 5726: e => { var t = Object.prototype; e.exports = function (e) { var n = e && e.constructor; return e === ("function" == typeof n && n.prototype || t) } }, 7040: e => { e.exports = function () { this.__data__ = [], this.size = 0 } }, 4125: (e, t, n) => { var r = n(8470), i = Array.prototype.splice; e.exports = function (e) { var t = this.__data__, n = r(t, e); return !(n < 0 || (n == t.length - 1 ? t.pop() : i.call(t, n, 1), --this.size, 0)) } }, 2117: (e, t, n) => { var r = n(8470); e.exports = function (e) { var t = this.__data__, n = r(t, e); return n < 0 ? void 0 : t[n][1] } }, 7518: (e, t, n) => { var r = n(8470); e.exports = function (e) { return r(this.__data__, e) > -1 } }, 4705: (e, t, n) => { var r = n(8470); e.exports = function (e, t) { var n = this.__data__, i = r(n, e); return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this } }, 4785: (e, t, n) => { var r = n(1989), i = n(8407), a = n(7071); e.exports = function () { this.size = 0, this.__data__ = { hash: new r, map: new (a || i), string: new r } } }, 1285: (e, t, n) => { var r = n(5050); e.exports = function (e) { var t = r(this, e).delete(e); return this.size -= t ? 1 : 0, t } }, 6e3: (e, t, n) => { var r = n(5050); e.exports = function (e) { return r(this, e).get(e) } }, 9916: (e, t, n) => { var r = n(5050); e.exports = function (e) { return r(this, e).has(e) } }, 5265: (e, t, n) => { var r = n(5050); e.exports = function (e, t) { var n = r(this, e), i = n.size; return n.set(e, t), this.size += n.size == i ? 0 : 1, this } }, 8776: e => { e.exports = function (e) { var t = -1, n = Array(e.size); return e.forEach((function (e, r) { n[++t] = [r, e] })), n } }, 4536: (e, t, n) => { var r = n(852)(Object, "create"); e.exports = r }, 6916: (e, t, n) => { var r = n(5569)(Object.keys, Object); e.exports = r }, 1167: (e, t, n) => { e = n.nmd(e); var r = n(1957), i = t && !t.nodeType && t, a = i && e && !e.nodeType && e, s = a && a.exports === i && r.process, o = function () { try { return a && a.require && a.require("util").types || s && s.binding && s.binding("util") } catch (e) { } }(); e.exports = o }, 2333: e => { var t = Object.prototype.toString; e.exports = function (e) { return t.call(e) } }, 5569: e => { e.exports = function (e, t) { return function (n) { return e(t(n)) } } }, 5639: (e, t, n) => { var r = n(1957), i = "object" == typeof self && self && self.Object === Object && self, a = r || i || Function("return this")(); e.exports = a }, 619: e => { e.exports = function (e) { return this.__data__.set(e, "__lodash_hash_undefined__"), this } }, 2385: e => { e.exports = function (e) { return this.__data__.has(e) } }, 1814: e => { e.exports = function (e) { var t = -1, n = Array(e.size); return e.forEach((function (e) { n[++t] = e })), n } }, 7465: (e, t, n) => { var r = n(8407); e.exports = function () { this.__data__ = new r, this.size = 0 } }, 3779: e => { e.exports = function (e) { var t = this.__data__, n = t.delete(e); return this.size = t.size, n } }, 7599: e => { e.exports = function (e) { return this.__data__.get(e) } }, 4758: e => { e.exports = function (e) { return this.__data__.has(e) } }, 4309: (e, t, n) => { var r = n(8407), i = n(7071), a = n(3369); e.exports = function (e, t) { var n = this.__data__; if (n instanceof r) { var s = n.__data__; if (!i || s.length < 199) return s.push([e, t]), this.size = ++n.size, this; n = this.__data__ = new a(s) } return n.set(e, t), this.size = n.size, this } }, 346: e => { var t = Function.prototype.toString; e.exports = function (e) { if (null != e) { try { return t.call(e) } catch (e) { } try { return e + "" } catch (e) { } } return "" } }, 7813: e => { e.exports = function (e, t) { return e === t || e != e && t != t } }, 5694: (e, t, n) => { var r = n(9454), i = n(7005), a = Object.prototype, s = a.hasOwnProperty, o = a.propertyIsEnumerable, l = r(function () { return arguments }()) ? r : function (e) { return i(e) && s.call(e, "callee") && !o.call(e, "callee") }; e.exports = l }, 1469: e => { var t = Array.isArray; e.exports = t }, 8612: (e, t, n) => { var r = n(3560), i = n(1780); e.exports = function (e) { return null != e && i(e.length) && !r(e) } }, 4144: (e, t, n) => { e = n.nmd(e); var r = n(5639), i = n(5062), a = t && !t.nodeType && t, s = a && e && !e.nodeType && e, o = s && s.exports === a ? r.Buffer : void 0, l = (o ? o.isBuffer : void 0) || i; e.exports = l }, 8446: (e, t, n) => { var r = n(939); e.exports = function (e, t) { return r(e, t) } }, 3560: (e, t, n) => { var r = n(4239), i = n(3218); e.exports = function (e) { if (!i(e)) return !1; var t = r(e); return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t } }, 1780: e => { e.exports = function (e) { return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991 } }, 3218: e => { e.exports = function (e) { var t = typeof e; return null != e && ("object" == t || "function" == t) } }, 7005: e => { e.exports = function (e) { return null != e && "object" == typeof e } }, 6719: (e, t, n) => { var r = n(8749), i = n(1717), a = n(1167), s = a && a.isTypedArray, o = s ? i(s) : r; e.exports = o }, 3674: (e, t, n) => { var r = n(4636), i = n(280), a = n(8612); e.exports = function (e) { return a(e) ? r(e) : i(e) } }, 479: e => { e.exports = function () { return [] } }, 5062: e => { e.exports = function () { return !1 } }, 75: function (e) { (function () { var t, n, r, i, a, s; "undefined" != typeof performance && null !== performance && performance.now ? e.exports = function () { return performance.now() } : "undefined" != typeof process && null !== process && process.hrtime ? (e.exports = function () { return (t() - a) / 1e6 }, n = process.hrtime, i = (t = function () { var e; return 1e9 * (e = n())[0] + e[1] })(), s = 1e9 * process.uptime(), a = i - s) : Date.now ? (e.exports = function () { return Date.now() - r }, r = Date.now()) : (e.exports = function () { return (new Date).getTime() - r }, r = (new Date).getTime()) }).call(this) }, 4087: (e, t, n) => { for (var r = n(75), i = "undefined" == typeof window ? n.g : window, a = ["moz", "webkit"], s = "AnimationFrame", o = i["request" + s], l = i["cancel" + s] || i["cancelRequest" + s], c = 0; !o && c < a.length; c++)o = i[a[c] + "Request" + s], l = i[a[c] + "Cancel" + s] || i[a[c] + "CancelRequest" + s]; if (!o || !l) { var u = 0, d = 0, h = []; o = function (e) { if (0 === h.length) { var t = r(), n = Math.max(0, 16.666666666666668 - (t - u)); u = n + t, setTimeout((function () { var e = h.slice(0); h.length = 0; for (var t = 0; t < e.length; t++)if (!e[t].cancelled) try { e[t].callback(u) } catch (e) { setTimeout((function () { throw e }), 0) } }), Math.round(n)) } return h.push({ handle: ++d, callback: e, cancelled: !1 }), d }, l = function (e) { for (var t = 0; t < h.length; t++)h[t].handle === e && (h[t].cancelled = !0) } } e.exports = function (e) { return o.call(i, e) }, e.exports.cancel = function () { l.apply(i, arguments) }, e.exports.polyfill = function (e) { e || (e = i), e.requestAnimationFrame = o, e.cancelAnimationFrame = l } }, 8156: t => { "use strict"; t.exports = e } }, n = {}; function r(e) { var i = n[e]; if (void 0 !== i) return i.exports; var a = n[e] = { id: e, loaded: !1, exports: {} }; return t[e].call(a.exports, a, a.exports, r), a.loaded = !0, a.exports } r.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return r.d(t, { a: t }), t }, r.d = (e, t) => { for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, r.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" == typeof window) return window } }(), r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.nmd = e => (e.paths = [], e.children || (e.children = []), e); var i = {}; return (() => { "use strict"; r.d(i, { default: () => f }); var e = r(8156), t = r.n(e), n = r(7403), a = r(8446), s = r.n(a); function o(e) { return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, o(e) } function l(e, t) { return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e }, l(e, t) } function c(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function u(e) { return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, u(e) } function d(e) { var t = function (e) { if ("object" !== o(e) || null === e) return e; var t = e[Symbol.toPrimitive]; if (void 0 !== t) { var n = t.call(e, "string"); if ("object" !== o(n)) return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e); return "symbol" === o(t) ? t : String(t) } var h = function (e) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && l(e, t) }(p, e); var r, i, a, h, f = (a = p, h = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(), function () { var e, t = u(a); if (h) { var n = u(this).constructor; e = Reflect.construct(t, arguments, n) } else e = t.apply(this, arguments); return function (e, t) { if (t && ("object" === o(t) || "function" == typeof t)) return t; if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined"); return c(e) }(this, e) }); function p() { var e, t, n, r; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, p); for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)a[s] = arguments[s]; return t = c(e = f.call.apply(f, [this].concat(a))), r = { instance: null }, (n = d(n = "state")) in t ? Object.defineProperty(t, n, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = r, e } return r = p, (i = [{ key: "componentDidMount", value: function () { var e = this, t = new n.default(this.typewriter, this.props.options); this.setState({ instance: t }, (function () { var n = e.props.onInit; n && n(t) })) } }, { key: "componentDidUpdate", value: function (e) { s()(this.props.options, e.options) || this.setState({ instance: new n.default(this.typewriter, this.props.options) }) } }, { key: "componentWillUnmount", value: function () { this.state.instance && this.state.instance.stop() } }, { key: "render", value: function () { var e = this, n = this.props.component; return t().createElement(n, { ref: function (t) { return e.typewriter = t }, className: "Typewriter", "data-testid": "typewriter-wrapper" }) } }]) && function (e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, d(r.key), r) } }(r.prototype, i), Object.defineProperty(r, "prototype", { writable: !1 }), p }(e.Component); h.defaultProps = { component: "div" }; const f = h })(), i.default })())) }, 440: e => { "use strict"; var t = function () { }; e.exports = t }, 299: (e, t, n) => { "use strict"; function r(e, t) { return function (e) { if (Array.isArray(e)) return e }(e) || function (e, t) { var n = [], r = !0, i = !1, a = void 0; try { for (var s, o = e[Symbol.iterator](); !(r = (s = o.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, a = e } finally { try { r || null == o.return || o.return() } finally { if (i) throw a } } return n }(e, t) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() } n.d(t, { xp: () => g, yX: () => b }); const i = 1e8, a = (Math.abs, Math.atan2, Math.cbrt, Math.cos, Math.exp, Math.floor, Math.max), s = Math.min, o = (Math.PI, Math.pow); Math.sin, Math.sqrt, o(6, 3), o(29, 3), o(29, 3), o(3, 3); function l(e, t) { return function (e, t) { const n = a(e, t), r = s(e, t); return (n * i + .05 * i) / (r * i + .05 * i) }(c(...e), c(...t)) } function c(e, t, n) { return (u(e) * f + u(t) * p + u(n) * m) / i } const u = e => e <= 3.928 ? e / h : d(e), d = e => o((e + 5.5) / 105.5, 2.4), h = 1292, f = .2126 * i, p = .7152 * i, m = .0722 * i; function g(e) { const t = r(e.match(v) || [], 9), n = t[1], i = t[2], a = t[3], s = t[4], o = t[5], l = t[6], c = t[7], u = t[8]; if (void 0 !== o || void 0 !== n) return [void 0 !== o ? parseInt(o, 16) : parseInt(n + n, 16), void 0 !== l ? parseInt(l, 16) : parseInt(i + i, 16), void 0 !== c ? parseInt(c, 16) : parseInt(a + a, 16), void 0 !== u ? parseInt(u, 16) : void 0 !== s ? parseInt(s + s, 16) : 255].map((e => 100 * e / 255)) } const v = /^#?(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i; function b(e, t) { return l(g(e), g(t)) } } }, __webpack_module_cache__ = {}; function __webpack_require__(e) { var t = __webpack_module_cache__[e]; if (void 0 !== t) return t.exports; var n = __webpack_module_cache__[e] = { exports: {} }; return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.exports } __webpack_require__.m = __webpack_modules__, __webpack_require__.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return __webpack_require__.d(t, { a: t }), t }, (() => { var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__; __webpack_require__.t = function (n, r) { if (1 & r && (n = this(n)), 8 & r) return n; if ("object" === typeof n && n) { if (4 & r && n.__esModule) return n; if (16 & r && "function" === typeof n.then) return n } var i = Object.create(null); __webpack_require__.r(i); var a = {}; e = e || [null, t({}), t([]), t(t)]; for (var s = 2 & r && n; "object" == typeof s && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach((e => a[e] = () => n[e])); return a.default = () => n, __webpack_require__.d(i, a), i } })(), __webpack_require__.d = (e, t) => { for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, __webpack_require__.f = {}, __webpack_require__.e = e => Promise.all(Object.keys(__webpack_require__.f).reduce(((t, n) => (__webpack_require__.f[n](e, t), t)), [])), __webpack_require__.u = e => "static/js/" + e + ".acca0757.chunk.js", __webpack_require__.miniCssF = e => { }, __webpack_require__.g = function () { if ("object" === typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" === typeof window) return window } }(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { var e = {}, t = "my-portfolio:"; __webpack_require__.l = (n, r, i, a) => { if (e[n]) e[n].push(r); else { var s, o; if (void 0 !== i) for (var l = document.getElementsByTagName("script"), c = 0; c < l.length; c++) { var u = l[c]; if (u.getAttribute("src") == n || u.getAttribute("data-webpack") == t + i) { s = u; break } } s || (o = !0, (s = document.createElement("script")).charset = "utf-8", s.timeout = 120, __webpack_require__.nc && s.setAttribute("nonce", __webpack_require__.nc), s.setAttribute("data-webpack", t + i), s.src = n), e[n] = [r]; var d = (t, r) => { s.onerror = s.onload = null, clearTimeout(h); var i = e[n]; if (delete e[n], s.parentNode && s.parentNode.removeChild(s), i && i.forEach((e => e(r))), t) return t(r) }, h = setTimeout(d.bind(null, void 0, { type: "timeout", target: s }), 12e4); s.onerror = d.bind(null, s.onerror), s.onload = d.bind(null, s.onload), o && document.head.appendChild(s) } } })(), __webpack_require__.r = e => { "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, __webpack_require__.p = "/Portfolio/", (() => { var e = { 792: 0 }; __webpack_require__.f.j = (t, n) => { var r = __webpack_require__.o(e, t) ? e[t] : void 0; if (0 !== r) if (r) n.push(r[2]); else { var i = new Promise(((n, i) => r = e[t] = [n, i])); n.push(r[2] = i); var a = __webpack_require__.p + __webpack_require__.u(t), s = new Error; __webpack_require__.l(a, (n => { if (__webpack_require__.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0), r)) { var i = n && ("load" === n.type ? "missing" : n.type), a = n && n.target && n.target.src; s.message = "Loading chunk " + t + " failed.\n(" + i + ": " + a + ")", s.name = "ChunkLoadError", s.type = i, s.request = a, r[1](s) } }), "chunk-" + t, t) } }; var t = (t, n) => { var r, i, a = n[0], s = n[1], o = n[2], l = 0; if (a.some((t => 0 !== e[t]))) { for (r in s) __webpack_require__.o(s, r) && (__webpack_require__.m[r] = s[r]); if (o) o(__webpack_require__) } for (t && t(n); l < a.length; l++)i = a[l], __webpack_require__.o(e, i) && e[i] && e[i][0](), e[i] = 0 }, n = self.webpackChunkPortfolio = self.webpackChunkPortfolio || []; n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n)) })(), __webpack_require__.nc = void 0; var __webpack_exports__ = {}; (() => { "use strict"; var e = {}; __webpack_require__.r(e), __webpack_require__.d(e, { dU: () => l_, ng: () => c_, EA: () => u_, Tm: () => d_, D6: () => h_, YE: () => f_, rE: () => p_ }); var t = __webpack_require__(43), n = __webpack_require__.t(t, 2), r = __webpack_require__(391), i = { outline: { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, filled: { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "currentColor", stroke: "none" } }; const a = (e, n, r, a) => { const s = (0, t.forwardRef)(((r, s) => { let { color: o = "currentColor", size: l = 24, stroke: c = 2, title: u, className: d, children: h, ...f } = r; return (0, t.createElement)("svg", { ref: s, ...i[e], width: l, height: l, className: ["tabler-icon", "tabler-icon-".concat(n), d].join(" "), ..."filled" === e ? { fill: o } : { strokeWidth: c, stroke: o }, ...f }, [u && (0, t.createElement)("title", { key: "svg-title" }, u), ...a.map((e => { let [n, r] = e; return (0, t.createElement)(n, r) })), ...Array.isArray(h) ? h : [h]]) })); return s.displayName = "".concat(r), s }; var s = a("outline", "brand-github", "IconBrandGithub", [["path", { d: "M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5", key: "svg-0" }]]), o = a("outline", "brand-linkedin", "IconBrandLinkedin", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M8 11l0 5", key: "svg-1" }], ["path", { d: "M8 8l0 .01", key: "svg-2" }], ["path", { d: "M12 16l0 -5", key: "svg-3" }], ["path", { d: "M16 16v-3a2 2 0 0 0 -4 0", key: "svg-4" }]]); const l = { name: "Aasmi C.", stack: ["Software Developer", "ReactJS Developer", "React Native Developer", "AngularJS Developer"], bio: "As a highly skilled and goal-oriented mobile and web developer, I bring 3 years of comprehensive experience in the complete development cycle. My expertise spans ReactJS, React Native, AngularJS, and NodeJS, with a proven ability to stay ahead of leading development trends and drive strategic, efficient product upgrades. I am adept at delivering high-quality, innovative solutions and continuously enhancing my skills in dynamic, collaborative environments. I am seeking a challenging role where I can leverage my extensive development experience and technical expertise to contribute effectively and grow professionally." }, c = [{ title: "Mogra Trips", desc: "This is a Trip management application integrated with email notifications and payment gateway for schools and other clients which is used for planning their trips for their proper destination", technologies: ["ReactJS", "Tailwind", "Redux", "NodeJS", "Prisma", "AWS"] }, { title: "Online Admission Form", desc: "This is a simple form developed for Online Admission Form which will be active only during the admission period.", technologies: ["ReactJS", "Tailwind", "Redux", "NodeJS", "Prisma", "AWS"] }, { title: "Mograsys UserApp", desc: "This is a mobile application completely developed for teachers to mark the Attendance and Mark Entry and several other advanced features are developed in this application.", technologies: ["React Native", "NodeJS", "Tailwind", "Prisma", "AWS"] }, { title: "Translation", desc: "Worked on Auto translate for communication Application reference from TWITTER. Got a good amount of experience in using AWS translate similar to Google translate", technologies: ["HTML", "CSS", "AngularJS", "C#", "MySQL", "AWS"] }, { title: "Logbook Dashboard", desc: "Have worked as a full stack developer intensively Developed many applications like Teacher timetable, Assignment Scheduler, Class Profile View, Triangulation etc. Production code deployment and debugging", technologies: ["HTML", "CSS", "AngularJS", "C#", "MySQL", "AWS"] }, { title: "Parent Portal Application and Teacher Web Application(Student Leave Application)", desc: "Created an application for parent portal where the student can apply their leaves and the teacher can approve and view the attachments attached by parents.", technologies: ["HTML", "CSS", "AngularJS", "C#", "MySQL", "AWS"] }, { title: "File/Photo upload, download and export Functionality in almost all the Applications", desc: "Managed the above case in almost all the applications which is redirected to S3 bucket and Images and uploaded after compression from original size", technologies: ["HTML", "CSS", "AngularJS", "C#", "MySQL", "AWS"] }], u = [{ title: "Frontend", skills: ["HTML", "CSS", "JavaScript", "React JS", "React Native", "AngularJS", "Redux", "Tailwind CSS", "Bootstrap"] }, { title: "Backend", skills: ["Node JS", "Express JS", "MySQL", "C#", "Prisma"] }, { title: "Languages", skills: ["JavaScript", "TypeScript"] }, { title: "Tools", skills: ["Git", "Github", "VS Code", "Postman"] }], d = [{ link: "https://github.com/aasmi27", icon: s }, { link: "https://linkedin.com/in/aasmi-c", icon: o }], h = [{ role: "Team Lead", company: "Mograsys Technologies", date: "May 2024 - Present", desc: "As a team lead, I actively participated in the ReactJS team, taking on responsibilities that included developing applications from scratch using ReactJS, Tailwind CSS, NodeJS, Postman, and Prisma. Additionally, I have worked on React Native projects. I collaborated on all stages of the systems development lifecycle, from requirement gathering to production releases. In my role, I supervised the work of programmers, designers, and technicians, assigned tasks, and monitored performance against targets. Furthermore, I explained project technical risks and benefits during project kick-offs, ensuring clear communication and understanding among all stakeholders.", skills: ["React JS", "React Native", "Node JS", "Tailwind CSS"] }, { role: "Software Developer", company: "Mograsys Technologies", date: "June 2021 - April 2024", desc: "As a software developer, my hands-on experience includes working with AngularJS, ReactJS, and NodeJS, alongside C# for API management and MySQL. I successfully implemented an AWS-S3 bucket system for seamless user document uploads, achieving a 50% reduction in upload errors and enhancing data integrity. My role involved reviewing code, debugging problems, and correcting issues, as well as coordinating with other engineers to evaluate and improve software and hardware interfaces. I am technically proficient, an analytical problem solver, and maintain a calm and focused demeanor. Additionally, I have updated legacy codebases to meet modern development standards, significantly improving functionality.", skills: ["React JS", "Angular JS", "Node JS", "MySQL", "C#", "Tailwind CSS", "AWS", "Jenkins"] }], f = ["typescript", "javascript", "react", "angular", "android", "html5", "css3", "nodedotjs", "express", "nextdotjs", "prisma", "mysql", "amazonaws", "firebase", "nginx", "jest", "cypress", "docker", "git", "jira", "github", "visualstudiocode", "androidstudio", "sonarqube", "figma"]; var p = __webpack_require__(23), m = __webpack_require__.n(p); function g(e, n) { let { getInitialValueInEffect: r } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { getInitialValueInEffect: !0 }; const [i, a] = (0, t.useState)(r ? n : function (e, t) { return "boolean" === typeof t ? t : "undefined" !== typeof window && "matchMedia" in window && window.matchMedia(e).matches }(e)), s = (0, t.useRef)(); return (0, t.useEffect)((() => { if ("matchMedia" in window) return s.current = window.matchMedia(e), a(s.current.matches), function (e, t) { try { return e.addEventListener("change", t), () => e.removeEventListener("change", t) } catch ($A) { return e.addListener(t), () => e.removeListener(t) } }(s.current, (e => a(e.matches))) }), [e]), i } var v = __webpack_require__(579); function b(e) { return "0rem" === e ? "0rem" : "calc(".concat(e, " * var(--mantine-scale))") } function y(e) { let { shouldScale: t = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return function n(r) { if (0 === r || "0" === r) return "0".concat(e); if ("number" === typeof r) { const n = "".concat(r / 16).concat(e); return t ? b(n) : n } if ("string" === typeof r) { if ("" === r) return r; if (r.startsWith("calc(") || r.startsWith("clamp(") || r.includes("rgba(")) return r; if (r.includes(",")) return r.split(",").map((e => n(e))).join(","); if (r.includes(" ")) return r.split(" ").map((e => n(e))).join(" "); if (r.includes(e)) return t ? b(r) : r; const i = r.replace("px", ""); if (!Number.isNaN(Number(i))) { const n = "".concat(Number(i) / 16).concat(e); return t ? b(n) : n } } return r } } const w = y("rem", { shouldScale: !0 }), x = y("em"); function _(e) { return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(e) ? function (e) { let t = e.replace("#", ""); if (3 === t.length) { const e = t.split(""); t = [e[0], e[0], e[1], e[1], e[2], e[2]].join("") } if (8 === t.length) { const e = parseInt(t.slice(6, 8), 16) / 255; return { r: parseInt(t.slice(0, 2), 16), g: parseInt(t.slice(2, 4), 16), b: parseInt(t.slice(4, 6), 16), a: e } } const n = parseInt(t, 16); return { r: n >> 16 & 255, g: n >> 8 & 255, b: 255 & n, a: 1 } }(e) : e.startsWith("rgb") ? function (e) { const [t, n, r, i] = e.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number); return { r: t, g: n, b: r, a: i || 1 } }(e) : e.startsWith("hsl") ? function (e) { const t = e.match(/^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i); if (!t) return { r: 0, g: 0, b: 0, a: 1 }; const n = parseInt(t[1], 10), r = parseInt(t[2], 10) / 100, i = parseInt(t[3], 10) / 100, a = t[5] ? parseFloat(t[5]) : void 0, s = (1 - Math.abs(2 * i - 1)) * r, o = n / 60, l = s * (1 - Math.abs(o % 2 - 1)), c = i - s / 2; let u, d, h; return o >= 0 && o < 1 ? (u = s, d = l, h = 0) : o >= 1 && o < 2 ? (u = l, d = s, h = 0) : o >= 2 && o < 3 ? (u = 0, d = s, h = l) : o >= 3 && o < 4 ? (u = 0, d = l, h = s) : o >= 4 && o < 5 ? (u = l, d = 0, h = s) : (u = s, d = 0, h = l), { r: Math.round(255 * (u + c)), g: Math.round(255 * (d + c)), b: Math.round(255 * (h + c)), a: a || 1 } }(e) : { r: 0, g: 0, b: 0, a: 1 } } function k(e, t) { if (e.startsWith("var(")) return "color-mix(in srgb, ".concat(e, ", black ").concat(100 * t, "%)"); const { r: n, g: r, b: i, a: a } = _(e), s = 1 - t, o = e => Math.round(e * s); return "rgba(".concat(o(n), ", ").concat(o(r), ", ").concat(o(i), ", ").concat(a, ")") } function S(e, t) { return "number" === typeof e.primaryShade ? e.primaryShade : "dark" === t ? e.primaryShade.dark : e.primaryShade.light } function A(e) { return e <= .03928 ? e / 12.92 : ((e + .055) / 1.055) ** 2.4 } function E(e) { if (e.startsWith("oklch(")) return (function (e) { const t = e.match(/oklch\((.*?)%\s/); return t ? parseFloat(t[1]) : null }(e) || 0) / 100; const { r: t, g: n, b: r } = _(e), i = n / 255, a = r / 255; return .2126 * A(t / 255) + .7152 * A(i) + .0722 * A(a) } function C(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .179; return !e.startsWith("var(") && E(e) > t } function M(e) { let { color: t, theme: n, colorScheme: r } = e; if ("string" !== typeof t) throw new Error("[@mantine/core] Failed to parse color. Expected color to be a string, instead got ".concat(typeof t)); if ("bright" === t) return { color: t, value: "dark" === r ? n.white : n.black, shade: void 0, isThemeColor: !1, isLight: C("dark" === r ? n.white : n.black, n.luminanceThreshold), variable: "--mantine-color-bright" }; if ("dimmed" === t) return { color: t, value: "dark" === r ? n.colors.dark[2] : n.colors.gray[7], shade: void 0, isThemeColor: !1, isLight: C("dark" === r ? n.colors.dark[2] : n.colors.gray[6], n.luminanceThreshold), variable: "--mantine-color-dimmed" }; if ("white" === t || "black" === t) return { color: t, value: "white" === t ? n.white : n.black, shade: void 0, isThemeColor: !1, isLight: C("white" === t ? n.white : n.black, n.luminanceThreshold), variable: "--mantine-color-".concat(t) }; const [i, a] = t.split("."), s = a ? Number(a) : void 0, o = i in n.colors; if (o) { const e = void 0 !== s ? n.colors[i][s] : n.colors[i][S(n, r || "light")]; return { color: i, value: e, shade: s, isThemeColor: o, isLight: C(e, n.luminanceThreshold), variable: a ? "--mantine-color-".concat(i, "-").concat(s) : "--mantine-color-".concat(i, "-filled") } } return { color: t, value: t, isThemeColor: o, isLight: C(t, n.luminanceThreshold), shade: s, variable: void 0 } } function T(e, t) { const n = M({ color: e || t.primaryColor, theme: t }); return n.variable ? "var(".concat(n.variable, ")") : e } function P(e, t) { const n = { from: (null === e || void 0 === e ? void 0 : e.from) || t.defaultGradient.from, to: (null === e || void 0 === e ? void 0 : e.to) || t.defaultGradient.to, deg: (null === e || void 0 === e ? void 0 : e.deg) || t.defaultGradient.deg || 0 }, r = T(n.from, t), i = T(n.to, t); return "linear-gradient(".concat(n.deg, "deg, ").concat(r, " 0%, ").concat(i, " 100%)") } function R(e, t) { if ("string" !== typeof e || t > 1 || t < 0) return "rgba(0, 0, 0, 1)"; if (e.startsWith("var(")) { const n = 100 * (1 - t); return "color-mix(in srgb, ".concat(e, ", transparent ").concat(n, "%)") } if (e.startsWith("oklch")) return e.includes("/") ? e.replace(/\/\s*[\d.]+\s*\)/, "/ ".concat(t, ")")) : e.replace(")", " / ".concat(t, ")")); const { r: n, g: r, b: i } = _(e); return "rgba(".concat(n, ", ").concat(r, ", ").concat(i, ", ").concat(t, ")") } const N = R, L = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", I = { scale: 1, fontSmoothing: !0, focusRing: "auto", white: "#fff", black: "#000", colors: { dark: ["#C9C9C9", "#b8b8b8", "#828282", "#696969", "#424242", "#3b3b3b", "#2e2e2e", "#242424", "#1f1f1f", "#141414"], gray: ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"], red: ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"], pink: ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"], grape: ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"], violet: ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"], indigo: ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"], blue: ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"], cyan: ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"], teal: ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"], green: ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"], lime: ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"], yellow: ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"], orange: ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"] }, primaryShade: { light: 6, dark: 8 }, primaryColor: "blue", variantColorResolver: e => { let { color: t, theme: n, variant: r, gradient: i, autoContrast: a } = e; const s = M({ color: t, theme: n }), o = "boolean" === typeof a ? a : n.autoContrast; if ("filled" === r) { const e = o && s.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)"; return s.isThemeColor ? void 0 === s.shade ? { background: "var(--mantine-color-".concat(t, "-filled)"), hover: "var(--mantine-color-".concat(t, "-filled-hover)"), color: e, border: "".concat(w(1), " solid transparent") } : { background: "var(--mantine-color-".concat(s.color, "-").concat(s.shade, ")"), hover: "var(--mantine-color-".concat(s.color, "-").concat(9 === s.shade ? 8 : s.shade + 1, ")"), color: e, border: "".concat(w(1), " solid transparent") } : { background: t, hover: k(t, .1), color: e, border: "".concat(w(1), " solid transparent") } } if ("light" === r) { if (s.isThemeColor) { if (void 0 === s.shade) return { background: "var(--mantine-color-".concat(t, "-light)"), hover: "var(--mantine-color-".concat(t, "-light-hover)"), color: "var(--mantine-color-".concat(t, "-light-color)"), border: "".concat(w(1), " solid transparent") }; const e = n.colors[s.color][s.shade]; return { background: R(e, .1), hover: R(e, .12), color: "var(--mantine-color-".concat(s.color, "-").concat(Math.min(s.shade, 6), ")"), border: "".concat(w(1), " solid transparent") } } return { background: R(t, .1), hover: R(t, .12), color: t, border: "".concat(w(1), " solid transparent") } } if ("outline" === r) return s.isThemeColor ? void 0 === s.shade ? { background: "transparent", hover: "var(--mantine-color-".concat(t, "-outline-hover)"), color: "var(--mantine-color-".concat(t, "-outline)"), border: "".concat(w(1), " solid var(--mantine-color-").concat(t, "-outline)") } : { background: "transparent", hover: R(n.colors[s.color][s.shade], .05), color: "var(--mantine-color-".concat(s.color, "-").concat(s.shade, ")"), border: "".concat(w(1), " solid var(--mantine-color-").concat(s.color, "-").concat(s.shade, ")") } : { background: "transparent", hover: R(t, .05), color: t, border: "".concat(w(1), " solid ").concat(t) }; if ("subtle" === r) { if (s.isThemeColor) { if (void 0 === s.shade) return { background: "transparent", hover: "var(--mantine-color-".concat(t, "-light-hover)"), color: "var(--mantine-color-".concat(t, "-light-color)"), border: "".concat(w(1), " solid transparent") }; return { background: "transparent", hover: R(n.colors[s.color][s.shade], .12), color: "var(--mantine-color-".concat(s.color, "-").concat(Math.min(s.shade, 6), ")"), border: "".concat(w(1), " solid transparent") } } return { background: "transparent", hover: R(t, .12), color: t, border: "".concat(w(1), " solid transparent") } } return "transparent" === r ? s.isThemeColor ? void 0 === s.shade ? { background: "transparent", hover: "transparent", color: "var(--mantine-color-".concat(t, "-light-color)"), border: "".concat(w(1), " solid transparent") } : { background: "transparent", hover: "transparent", color: "var(--mantine-color-".concat(s.color, "-").concat(Math.min(s.shade, 6), ")"), border: "".concat(w(1), " solid transparent") } : { background: "transparent", hover: "transparent", color: t, border: "".concat(w(1), " solid transparent") } : "white" === r ? s.isThemeColor ? void 0 === s.shade ? { background: "var(--mantine-color-white)", hover: k(n.white, .01), color: "var(--mantine-color-".concat(t, "-filled)"), border: "".concat(w(1), " solid transparent") } : { background: "var(--mantine-color-white)", hover: k(n.white, .01), color: "var(--mantine-color-".concat(s.color, "-").concat(s.shade, ")"), border: "".concat(w(1), " solid transparent") } : { background: "var(--mantine-color-white)", hover: k(n.white, .01), color: t, border: "".concat(w(1), " solid transparent") } : "gradient" === r ? { background: P(i, n), hover: P(i, n), color: "var(--mantine-color-white)", border: "none" } : "default" === r ? { background: "var(--mantine-color-default)", hover: "var(--mantine-color-default-hover)", color: "var(--mantine-color-default-color)", border: "".concat(w(1), " solid var(--mantine-color-default-border)") } : {} }, autoContrast: !1, luminanceThreshold: .3, fontFamily: L, fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace", respectReducedMotion: !1, cursorType: "default", defaultGradient: { from: "blue", to: "cyan", deg: 45 }, defaultRadius: "sm", activeClassName: "mantine-active", focusClassName: "", headings: { fontFamily: L, fontWeight: "700", textWrap: "wrap", sizes: { h1: { fontSize: w(34), lineHeight: "1.3" }, h2: { fontSize: w(26), lineHeight: "1.35" }, h3: { fontSize: w(22), lineHeight: "1.4" }, h4: { fontSize: w(18), lineHeight: "1.45" }, h5: { fontSize: w(16), lineHeight: "1.5" }, h6: { fontSize: w(14), lineHeight: "1.5" } } }, fontSizes: { xs: w(12), sm: w(14), md: w(16), lg: w(18), xl: w(20) }, lineHeights: { xs: "1.4", sm: "1.45", md: "1.55", lg: "1.6", xl: "1.65" }, radius: { xs: w(2), sm: w(4), md: w(8), lg: w(16), xl: w(32) }, spacing: { xs: w(10), sm: w(12), md: w(16), lg: w(20), xl: w(32) }, breakpoints: { xs: "36em", sm: "48em", md: "62em", lg: "75em", xl: "88em" }, shadows: { xs: "0 ".concat(w(1), " ").concat(w(3), " rgba(0, 0, 0, 0.05), 0 ").concat(w(1), " ").concat(w(2), " rgba(0, 0, 0, 0.1)"), sm: "0 ".concat(w(1), " ").concat(w(3), " rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ").concat(w(10), " ").concat(w(15), " ").concat(w(-5), ", rgba(0, 0, 0, 0.04) 0 ").concat(w(7), " ").concat(w(7), " ").concat(w(-5)), md: "0 ".concat(w(1), " ").concat(w(3), " rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ").concat(w(20), " ").concat(w(25), " ").concat(w(-5), ", rgba(0, 0, 0, 0.04) 0 ").concat(w(10), " ").concat(w(10), " ").concat(w(-5)), lg: "0 ".concat(w(1), " ").concat(w(3), " rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ").concat(w(28), " ").concat(w(23), " ").concat(w(-7), ", rgba(0, 0, 0, 0.04) 0 ").concat(w(12), " ").concat(w(12), " ").concat(w(-7)), xl: "0 ".concat(w(1), " ").concat(w(3), " rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ").concat(w(36), " ").concat(w(28), " ").concat(w(-7), ", rgba(0, 0, 0, 0.04) 0 ").concat(w(17), " ").concat(w(17), " ").concat(w(-7)) }, other: {}, components: {} }; function D(e) { return e && "object" === typeof e && !Array.isArray(e) } function O(e, t) { const n = { ...e }, r = t; return D(e) && D(t) && Object.keys(t).forEach((t => { D(r[t]) ? n[t] = t in e ? O(n[t], r[t]) : r[t] : n[t] = r[t] })), n } const j = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more \u2013 https://mantine.dev/theming/colors/#primary-color", F = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }"; function z(e) { return !(e < 0 || e > 9) && parseInt(e.toString(), 10) === e } function W(e) { if (!(e.primaryColor in e.colors)) throw new Error(j); if ("object" === typeof e.primaryShade && (!z(e.primaryShade.dark) || !z(e.primaryShade.light))) throw new Error(F); if ("number" === typeof e.primaryShade && !z(e.primaryShade)) throw new Error(F) } const B = (0, t.createContext)(null), H = () => (0, t.useContext)(B) || I; function U() { const e = (0, t.useContext)(B); if (!e) throw new Error("@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"); return e } function V(e) { let { theme: n, children: r, inherit: i = !0 } = e; const a = H(), s = (0, t.useMemo)((() => function (e, t) { var n; if (!t) return W(e), e; const r = O(e, t); return !t.fontFamily || null !== (n = t.headings) && void 0 !== n && n.fontFamily || (r.headings.fontFamily = t.fontFamily), W(r), r }(i ? a : I, n)), [n, a, i]); return (0, v.jsx)(B.Provider, { value: s, children: r }) } V.displayName = "@mantine/core/MantineThemeProvider"; const q = ["xs", "sm", "md", "lg", "xl"]; function G(e, t) { const n = U(), r = g("(min-width: ".concat(n.breakpoints.xs, ")"), !1, t), i = g("(min-width: ".concat(n.breakpoints.sm, ")"), !1, t), a = g("(min-width: ".concat(n.breakpoints.md, ")"), !1, t), s = g("(min-width: ".concat(n.breakpoints.lg, ")"), !1, t), o = g("(min-width: ".concat(n.breakpoints.xl, ")"), !1, t), l = [r, i, a, s, o].findLastIndex((e => e)); return function (e, t) { if (!t) return e.base; let n = q.indexOf(t); for (; n >= 0;) { if (q[n] in e) return e[q[n]]; n -= 1 } return e.base }(e, q[l]) } const X = { app: 100, modal: 200, popover: 300, overlay: 400, max: 9999 }; function Y(e) { return X[e] } function K(e) { return Object.keys(e).reduce(((t, n) => (void 0 !== e[n] && (t[n] = e[n]), t)), {}) } function Q(e, t, n) { var r; const i = U(), a = null === (r = i.components[e]) || void 0 === r ? void 0 : r.defaultProps; return { ...t, ..."function" === typeof a ? a(i) : a, ...K(n) } } function $(e) { return e } function J(e) { const n = (0, t.forwardRef)(e); return n.extend = $, n.withProps = e => { const r = (0, t.forwardRef)(((t, r) => (0, v.jsx)(n, { ...e, ...t, ref: r }))); return r.extend = n.extend, r.displayName = "WithProps(".concat(n.displayName, ")"), r }, n } function Z(e) { var t, n, r = ""; if ("string" == typeof e || "number" == typeof e) r += e; else if ("object" == typeof e) if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = Z(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function ee() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = Z(e)) && (r && (r += " "), r += t); return r } const te = ee; const ne = (0, t.createContext)(null); function re() { const e = (0, t.useContext)(ne); if (!e) throw new Error("[@mantine/core] MantineProvider was not found in tree"); return e } function ie() { return re().getStyleNonce } function ae(e) { return Object.keys(e) } function se(e) { return ae(e).reduce(((t, n) => { return void 0 !== e[n] ? "".concat(t).concat((r = n, r.replace(/[A-Z]/g, (e => "-".concat(e.toLowerCase())))), ":").concat(e[n], ";") : t; var r }), "").trim() } function oe(e) { let { selector: t, styles: n, media: r, container: i } = e; const a = n ? se(n) : "", s = Array.isArray(r) ? r.map((e => "@media".concat(e.query, "{").concat(t, "{").concat(se(e.styles), "}}"))) : [], o = Array.isArray(i) ? i.map((e => "@container ".concat(e.query, "{").concat(t, "{").concat(se(e.styles), "}}"))) : []; return "".concat(a ? "".concat(t, "{").concat(a, "}") : "").concat(s.join("")).concat(o.join("")).trim() } function le(e) { const t = ie(); return (0, v.jsx)("style", { "data-mantine-styles": "inline", nonce: null === t || void 0 === t ? void 0 : t(), dangerouslySetInnerHTML: { __html: oe(e) } }) } function ce(e) { return "number" === typeof e || "string" === typeof e && (!!(e.startsWith("calc(") || e.startsWith("var(") || e.includes(" ") && "" !== e.trim()) || /[0-9]/.test(e.trim().replace("-", "")[0])) } function ue(e) { return e.startsWith("data-") ? e : "data-".concat(e) } function de(e) { return e ? "string" === typeof e ? { [ue(e)]: !0 } : Array.isArray(e) ? [...e].reduce(((e, t) => ({ ...e, ...de(t) })), {}) : (t = e, Object.keys(t).reduce(((e, n) => { const r = t[n]; return void 0 === r || "" === r || !1 === r || null === r || (e[ue(n)] = t[n]), e }), {})) : null; var t } function he(e, t) { return Array.isArray(e) ? [...e].reduce(((e, n) => ({ ...e, ...he(n, t) })), {}) : "function" === typeof e ? e(t) : null == e ? {} : e } function fe(e) { let { theme: t, style: n, vars: r, styleProps: i } = e; return { ...he(n, t), ...he(r, t), ...i } } const pe = { m: { type: "spacing", property: "margin" }, mt: { type: "spacing", property: "marginTop" }, mb: { type: "spacing", property: "marginBottom" }, ml: { type: "spacing", property: "marginLeft" }, mr: { type: "spacing", property: "marginRight" }, ms: { type: "spacing", property: "marginInlineStart" }, me: { type: "spacing", property: "marginInlineEnd" }, mx: { type: "spacing", property: "marginInline" }, my: { type: "spacing", property: "marginBlock" }, p: { type: "spacing", property: "padding" }, pt: { type: "spacing", property: "paddingTop" }, pb: { type: "spacing", property: "paddingBottom" }, pl: { type: "spacing", property: "paddingLeft" }, pr: { type: "spacing", property: "paddingRight" }, ps: { type: "spacing", property: "paddingInlineStart" }, pe: { type: "spacing", property: "paddingInlineEnd" }, px: { type: "spacing", property: "paddingInline" }, py: { type: "spacing", property: "paddingBlock" }, bd: { type: "border", property: "border" }, bg: { type: "color", property: "background" }, c: { type: "textColor", property: "color" }, opacity: { type: "identity", property: "opacity" }, ff: { type: "fontFamily", property: "fontFamily" }, fz: { type: "fontSize", property: "fontSize" }, fw: { type: "identity", property: "fontWeight" }, lts: { type: "size", property: "letterSpacing" }, ta: { type: "identity", property: "textAlign" }, lh: { type: "lineHeight", property: "lineHeight" }, fs: { type: "identity", property: "fontStyle" }, tt: { type: "identity", property: "textTransform" }, td: { type: "identity", property: "textDecoration" }, w: { type: "spacing", property: "width" }, miw: { type: "spacing", property: "minWidth" }, maw: { type: "spacing", property: "maxWidth" }, h: { type: "spacing", property: "height" }, mih: { type: "spacing", property: "minHeight" }, mah: { type: "spacing", property: "maxHeight" }, bgsz: { type: "size", property: "backgroundSize" }, bgp: { type: "identity", property: "backgroundPosition" }, bgr: { type: "identity", property: "backgroundRepeat" }, bga: { type: "identity", property: "backgroundAttachment" }, pos: { type: "identity", property: "position" }, top: { type: "identity", property: "top" }, left: { type: "size", property: "left" }, bottom: { type: "size", property: "bottom" }, right: { type: "size", property: "right" }, inset: { type: "size", property: "inset" }, display: { type: "identity", property: "display" }, flex: { type: "identity", property: "flex" } }; function me(e, t) { const n = M({ color: e, theme: t }); return "dimmed" === n.color ? "var(--mantine-color-dimmed)" : "bright" === n.color ? "var(--mantine-color-bright)" : n.variable ? "var(".concat(n.variable, ")") : n.color } const ge = { text: "var(--mantine-font-family)", mono: "var(--mantine-font-family-monospace)", monospace: "var(--mantine-font-family-monospace)", heading: "var(--mantine-font-family-headings)", headings: "var(--mantine-font-family-headings)" }; const ve = ["h1", "h2", "h3", "h4", "h5", "h6"]; const be = ["h1", "h2", "h3", "h4", "h5", "h6"]; const ye = { color: me, textColor: function (e, t) { const n = M({ color: e, theme: t }); return n.isThemeColor && void 0 === n.shade ? "var(--mantine-color-".concat(n.color, "-text)") : me(e, t) }, fontSize: function (e, t) { return "string" === typeof e && e in t.fontSizes ? "var(--mantine-font-size-".concat(e, ")") : "string" === typeof e && ve.includes(e) ? "var(--mantine-".concat(e, "-font-size)") : "number" === typeof e || "string" === typeof e ? w(e) : e }, spacing: function (e, t) { if ("number" === typeof e) return w(e); if ("string" === typeof e) { const n = e.replace("-", ""); if (!(n in t.spacing)) return w(e); const r = "--mantine-spacing-".concat(n); return e.startsWith("-") ? "calc(var(".concat(r, ") * -1)") : "var(".concat(r, ")") } return e }, identity: function (e) { return e }, size: function (e) { return "number" === typeof e ? w(e) : e }, lineHeight: function (e, t) { return "string" === typeof e && e in t.lineHeights ? "var(--mantine-line-height-".concat(e, ")") : "string" === typeof e && be.includes(e) ? "var(--mantine-".concat(e, "-line-height)") : e }, fontFamily: function (e) { return "string" === typeof e && e in ge ? ge[e] : e }, border: function (e, t) { if ("number" === typeof e) return w(e); if ("string" === typeof e) { const [n, r, ...i] = e.split(" ").filter((e => "" !== e.trim())); let a = "".concat(w(n)); return r && (a += " ".concat(r)), i.length > 0 && (a += " ".concat(me(i.join(" "), t))), a.trim() } return e } }; function we(e) { return e.replace("(min-width: ", "").replace("em)", "") } function xe(e, t) { return "object" === typeof e && null !== e && t in e ? e[t] : e } function _e(e) { let { styleProps: t, data: n, theme: r } = e; return function (e) { let { media: t, ...n } = e; const r = Object.keys(t).sort(((e, t) => Number(we(e)) - Number(we(t)))).map((e => ({ query: e, styles: t[e] }))); return { ...n, media: r } }(ae(t).reduce(((e, i) => { if ("hiddenFrom" === i || "visibleFrom" === i || "sx" === i) return e; const a = n[i], s = Array.isArray(a.property) ? a.property : [a.property], o = "object" === typeof (l = t[i]) && null !== l ? "base" in l ? l.base : void 0 : l; var l; if (!function (e) { if ("object" !== typeof e || null === e) return !1; const t = Object.keys(e); return 1 !== t.length || "base" !== t[0] }(t[i])) return s.forEach((t => { e.inlineStyles[t] = ye[a.type](o, r) })), e; e.hasResponsiveStyles = !0; const c = function (e) { return "object" === typeof e && null !== e ? ae(e).filter((e => "base" !== e)) : [] }(t[i]); return s.forEach((n => { o && (e.styles[n] = ye[a.type](o, r)), c.forEach((s => { const o = "(min-width: ".concat(r.breakpoints[s], ")"); e.media[o] = { ...e.media[o], [n]: ye[a.type](xe(t[i], s), r) } })) })), e }), { hasResponsiveStyles: !1, styles: {}, inlineStyles: {}, media: {} })) } const ke = (0, t.forwardRef)(((e, n) => { var r; let { component: i, style: a, __vars: s, className: o, variant: l, mod: c, size: u, hiddenFrom: d, visibleFrom: h, lightHidden: f, darkHidden: p, renderRoot: m, __size: g, ...b } = e; const y = U(), w = i || "div", { styleProps: x, rest: _ } = function (e) { const { m: t, mx: n, my: r, mt: i, mb: a, ml: s, mr: o, me: l, ms: c, p: u, px: d, py: h, pt: f, pb: p, pl: m, pr: g, pe: v, ps: b, bd: y, bg: w, c: x, opacity: _, ff: k, fz: S, fw: A, lts: E, ta: C, lh: M, fs: T, tt: P, td: R, w: N, miw: L, maw: I, h: D, mih: O, mah: j, bgsz: F, bgp: z, bgr: W, bga: B, pos: H, top: U, left: V, bottom: q, right: G, inset: X, display: Y, flex: Q, hiddenFrom: $, visibleFrom: J, lightHidden: Z, darkHidden: ee, sx: te, ...ne } = e; return { styleProps: K({ m: t, mx: n, my: r, mt: i, mb: a, ml: s, mr: o, me: l, ms: c, p: u, px: d, py: h, pt: f, pb: p, pl: m, pr: g, pe: v, ps: b, bd: y, bg: w, c: x, opacity: _, ff: k, fz: S, fw: A, lts: E, ta: C, lh: M, fs: T, tt: P, td: R, w: N, miw: L, maw: I, h: D, mih: O, mah: j, bgsz: F, bgp: z, bgr: W, bga: B, pos: H, top: U, left: V, bottom: q, right: G, inset: X, display: Y, flex: Q, hiddenFrom: $, visibleFrom: J, lightHidden: Z, darkHidden: ee, sx: te }), rest: ne } }(b), k = function () { var e; return null === (e = re().stylesTransform) || void 0 === e ? void 0 : e.sx }(), S = null === k || void 0 === k || null === (r = k()) || void 0 === r ? void 0 : r(x.sx), A = function () { const e = (0, t.useId)().replace(/:/g, ""); return "__m__-".concat(e) }(), E = _e({ styleProps: x, theme: y, data: pe }), C = { ref: n, style: fe({ theme: y, style: a, vars: s, styleProps: E.inlineStyles }), className: te(o, S, { [A]: E.hasResponsiveStyles, "mantine-light-hidden": f, "mantine-dark-hidden": p, ["mantine-hidden-from-".concat(d)]: d, ["mantine-visible-from-".concat(h)]: h }), "data-variant": l, "data-size": ce(u) ? void 0 : u || void 0, size: g, ...de(c), ..._ }; return (0, v.jsxs)(v.Fragment, { children: [E.hasResponsiveStyles && (0, v.jsx)(le, { selector: ".".concat(A), styles: E.styles, media: E.media }), "function" === typeof m ? m(C) : (0, v.jsx)(w, { ...C })] }) })); ke.displayName = "@mantine/core/Box"; const Se = ke; function Ae(e) { const n = (0, t.createContext)(null); return [e => { let { children: t, value: r } = e; return (0, v.jsx)(n.Provider, { value: r, children: t }) }, () => { const r = (0, t.useContext)(n); if (null === r) throw new Error(e); return r }] } const [Ee, Ce] = Ae("ModalBase component was not found in tree"); var Me = "m_615af6c9", Te = "m_b5489c3c", Pe = "m_60c222c7", Re = "m_fd1ab0aa", Ne = "m_606cb269", Le = "m_5df29311"; const Ie = (0, t.forwardRef)(((e, n) => { let { className: r, ...i } = e; const a = function () { const e = Ce(); return (0, t.useEffect)((() => (e.setBodyMounted(!0), () => e.setBodyMounted(!1))), []), e.getBodyId() }(), s = Ce(); return (0, v.jsx)(Se, { ref: n, ...i, id: a, className: te({ [Le]: !s.unstyled }, r) }) })); Ie.displayName = "@mantine/core/ModalBaseBody"; const [De, Oe] = Ae("Modal component was not found in tree"); var je = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" }; const Fe = {}, ze = J(((e, t) => { const n = Q("ModalBody", Fe, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = Oe(); return (0, v.jsx)(Ie, { ref: t, ...c.getStyles("body", { classNames: r, style: a, styles: s, className: i }), ...l }) })); function We(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "size", n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (void 0 !== e) return ce(e) ? n ? w(e) : e : "var(--".concat(t, "-").concat(e, ")") } function Be(e) { return We(e, "mantine-spacing") } function He(e) { return void 0 === e ? "var(--mantine-radius-default)" : We(e, "mantine-radius") } function Ue(e) { return We(e, "mantine-font-size") } function Ve(e) { return We(e, "mantine-line-height", !1) } function qe(e) { if (e) return We(e, "mantine-shadow", !1) } ze.classes = je, ze.displayName = "@mantine/core/ModalBody"; const Ge = { always: "mantine-focus-always", auto: "mantine-focus-auto", never: "mantine-focus-never" }; const Xe = {}; function Ye(e) { let { theme: t, classNames: n, props: r, stylesCtx: i } = e; return function (e) { const t = {}; return e.forEach((e => { Object.entries(e).forEach((e => { let [n, r] = e; t[n] ? t[n] = te(t[n], r) : t[n] = r })) })), t }((Array.isArray(n) ? n : [n]).map((e => "function" === typeof e ? e(t, r, i) : e || Xe))) } function Ke(e) { let { selector: t, stylesCtx: n, theme: r, classNames: i, props: a } = e; return Ye({ theme: r, classNames: i, props: a, stylesCtx: n })[t] } function Qe(e) { let { theme: t, options: n, themeName: r, selector: i, classNamesPrefix: a, classNames: s, classes: o, unstyled: l, className: c, rootSelector: u, props: d, stylesCtx: h, withStaticClasses: f, headless: p, transformedStyles: m } = e; return te(function (e) { let { theme: t, options: n, unstyled: r } = e; return te((null === n || void 0 === n ? void 0 : n.focusable) && !r && (t.focusClassName || Ge[t.focusRing]), (null === n || void 0 === n ? void 0 : n.active) && !r && t.activeClassName) }({ theme: t, options: n, unstyled: l || p }), function (e) { let { themeName: t, theme: n, selector: r, props: i, stylesCtx: a } = e; return t.map((e => { var t, s; return null === (t = Ye({ theme: n, classNames: null === (s = n.components[e]) || void 0 === s ? void 0 : s.classNames, props: i, stylesCtx: a })) || void 0 === t ? void 0 : t[r] })) }({ theme: t, themeName: r, selector: i, props: d, stylesCtx: h }), function (e) { let { options: t, classes: n, selector: r, unstyled: i } = e; return null !== t && void 0 !== t && t.variant && !i ? n["".concat(r, "--").concat(t.variant)] : void 0 }({ options: n, classes: o, selector: i, unstyled: l }), Ke({ selector: i, stylesCtx: h, theme: t, classNames: s, props: d }), Ke({ selector: i, stylesCtx: h, theme: t, classNames: m, props: d }), function (e) { let { selector: t, stylesCtx: n, options: r, props: i, theme: a } = e; return Ye({ theme: a, classNames: null === r || void 0 === r ? void 0 : r.classNames, props: (null === r || void 0 === r ? void 0 : r.props) || i, stylesCtx: n })[t] }({ selector: i, stylesCtx: h, options: n, props: d, theme: t }), function (e) { let { rootSelector: t, selector: n, className: r } = e; return t === n ? r : void 0 }({ rootSelector: u, selector: i, className: c }), function (e) { let { selector: t, classes: n, unstyled: r } = e; return r ? void 0 : n[t] }({ selector: i, classes: o, unstyled: l || p }), f && !p && function (e) { let { themeName: t, classNamesPrefix: n, selector: r, withStaticClass: i } = e; return !1 === i ? [] : t.map((e => "".concat(n, "-").concat(e, "-").concat(r))) }({ themeName: r, classNamesPrefix: a, selector: i, withStaticClass: null === n || void 0 === n ? void 0 : n.withStaticClass }), null === n || void 0 === n ? void 0 : n.className) } function $e(e) { let { theme: t, styles: n, props: r, stylesCtx: i } = e; return (Array.isArray(n) ? n : [n]).reduce(((e, n) => "function" === typeof n ? { ...e, ...n(t, r, i) } : { ...e, ...n }), {}) } function Je(e) { let { theme: t, themeName: n, props: r, stylesCtx: i, selector: a } = e; return n.map((e => { var n; return $e({ theme: t, styles: null === (n = t.components[e]) || void 0 === n ? void 0 : n.styles, props: r, stylesCtx: i })[a] })).reduce(((e, t) => ({ ...e, ...t })), {}) } function Ze(e) { let { style: t, theme: n } = e; return Array.isArray(t) ? [...t].reduce(((e, t) => ({ ...e, ...Ze({ style: t, theme: n }) })), {}) : "function" === typeof t ? t(n) : null == t ? {} : t } function et(e) { var t; let { vars: n, varsResolver: r, theme: i, props: a, stylesCtx: s, selector: o, themeName: l, headless: c } = e; return null === (t = function (e) { return e.reduce(((e, t) => (t && Object.keys(t).forEach((n => { e[n] = { ...e[n], ...K(t[n]) } })), e)), {}) }([c ? {} : null === r || void 0 === r ? void 0 : r(i, a, s), ...l.map((e => { var t, n; return null === (t = i.components) || void 0 === t || null === (t = t[e]) || void 0 === t || null === (n = t.vars) || void 0 === n ? void 0 : n.call(t, i, a, s) })), null === n || void 0 === n ? void 0 : n(i, a, s)])) || void 0 === t ? void 0 : t[o] } function tt(e) { let { theme: t, themeName: n, selector: r, options: i, props: a, stylesCtx: s, rootSelector: o, styles: l, style: c, vars: u, varsResolver: d, headless: h, withStylesTransform: f } = e; return { ...!f && Je({ theme: t, themeName: n, props: a, stylesCtx: s, selector: r }), ...!f && $e({ theme: t, styles: l, props: a, stylesCtx: s })[r], ...!f && $e({ theme: t, styles: null === i || void 0 === i ? void 0 : i.styles, props: (null === i || void 0 === i ? void 0 : i.props) || a, stylesCtx: s })[r], ...et({ theme: t, props: a, stylesCtx: s, vars: u, varsResolver: d, selector: r, themeName: n, headless: h }), ...o === r ? Ze({ style: c, theme: t }) : null, ...Ze({ style: null === i || void 0 === i ? void 0 : i.style, theme: t }) } } function nt(e) { var t; let { props: n, stylesCtx: r, themeName: i } = e; const a = U(), s = null === (t = function () { var e; return null === (e = re().stylesTransform) || void 0 === e ? void 0 : e.styles }()) || void 0 === t ? void 0 : t(); return { getTransformedStyles: e => { if (!s) return []; return [...e.map((e => s(e, { props: n, theme: a, ctx: r }))), ...i.map((e => { var t; return s(null === (t = a.components[e]) || void 0 === t ? void 0 : t.styles, { props: n, theme: a, ctx: r }) }))].filter(Boolean) }, withStylesTransform: !!s } } function rt(e) { let { name: t, classes: n, props: r, stylesCtx: i, className: a, style: s, rootSelector: o = "root", unstyled: l, classNames: c, styles: u, vars: d, varsResolver: h } = e; const f = U(), p = re().classNamesPrefix, m = re().withStaticClasses, g = re().headless, v = (Array.isArray(t) ? t : [t]).filter((e => e)), { withStylesTransform: b, getTransformedStyles: y } = nt({ props: r, stylesCtx: i, themeName: v }); return (e, t) => ({ className: Qe({ theme: f, options: t, themeName: v, selector: e, classNamesPrefix: p, classNames: c, classes: n, unstyled: l, className: a, rootSelector: o, props: r, stylesCtx: i, withStaticClasses: m, headless: g, transformedStyles: y([null === t || void 0 === t ? void 0 : t.styles, u]) }), style: tt({ theme: f, themeName: v, selector: e, options: t, props: r, stylesCtx: i, rootSelector: o, styles: u, style: s, vars: d, varsResolver: h, headless: g, withStylesTransform: b }) }) } function it(e) { const n = (0, t.forwardRef)(e); return n.withProps = e => { const r = (0, t.forwardRef)(((t, r) => (0, v.jsx)(n, { ...e, ...t, ref: r }))); return r.extend = n.extend, r.displayName = "WithProps(".concat(n.displayName, ")"), r }, n.extend = $, n } var at = { root: "m_87cf2631" }; const st = { __staticSelector: "UnstyledButton" }, ot = it(((e, t) => { const n = Q("UnstyledButton", st, e), { className: r, component: i = "button", __staticSelector: a, unstyled: s, classNames: o, styles: l, style: c, ...u } = n, d = rt({ name: a, props: n, classes: at, className: r, style: c, classNames: o, styles: l, unstyled: s }); return (0, v.jsx)(Se, { ...d("root", { focusable: !0 }), component: i, ref: t, type: "button" === i ? "button" : void 0, ...u }) })); ot.classes = at, ot.displayName = "@mantine/core/UnstyledButton"; const lt = (0, t.forwardRef)(((e, t) => { let { size: n = "var(--cb-icon-size, 70%)", style: r, ...i } = e; return (0, v.jsx)("svg", { viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { ...r, width: n, height: n }, ref: t, ...i, children: (0, v.jsx)("path", { d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }) }) })); lt.displayName = "@mantine/core/CloseIcon"; var ct = { root: "m_86a44da5", "root--subtle": "m_220c80f2" }; const ut = { variant: "subtle" }, dt = (e, t) => { let { size: n, radius: r, iconSize: i } = t; return { root: { "--cb-size": We(n, "cb-size"), "--cb-radius": void 0 === r ? void 0 : He(r), "--cb-icon-size": w(i) } } }, ht = it(((e, t) => { const n = Q("CloseButton", ut, e), { iconSize: r, children: i, vars: a, radius: s, className: o, classNames: l, style: c, styles: u, unstyled: d, "data-disabled": h, disabled: f, variant: p, icon: m, mod: g, ...b } = n, y = rt({ name: "CloseButton", props: n, className: o, style: c, classes: ct, classNames: l, styles: u, unstyled: d, vars: a, varsResolver: dt }); return (0, v.jsxs)(ot, { ref: t, ...b, unstyled: d, variant: p, disabled: f, mod: [{ disabled: f || h }, g], ...y("root", { variant: p, active: !f && !h }), children: [m || (0, v.jsx)(lt, {}), i] }) })); ht.classes = ct, ht.displayName = "@mantine/core/CloseButton"; const ft = (0, t.forwardRef)(((e, t) => { let { className: n, onClick: r, ...i } = e; const a = Ce(); return (0, v.jsx)(ht, { ref: t, ...i, onClick: e => { a.onClose(), null === r || void 0 === r || r(e) }, className: te({ [Ne]: !a.unstyled }, n), unstyled: a.unstyled }) })); ft.displayName = "@mantine/core/ModalBaseCloseButton"; const pt = {}, mt = J(((e, t) => { const n = Q("ModalCloseButton", pt, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = Oe(); return (0, v.jsx)(ft, { ref: t, ...c.getStyles("close", { classNames: r, style: a, styles: s, className: i }), ...l }) })); function gt() { return "mantine-".concat(Math.random().toString(36).slice(2, 11)) } mt.classes = je, mt.displayName = "@mantine/core/ModalCloseButton"; const vt = /input|select|textarea|button|object/, bt = "a, input, select, textarea, button, object, [tabindex]"; function yt(e) { return "none" === e.style.display } function wt(e) { let t = e.getAttribute("tabindex"); return null === t && (t = void 0), parseInt(t, 10) } function xt(e) { const t = e.nodeName.toLowerCase(), n = !Number.isNaN(wt(e)); return (vt.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || n) && function (e) { if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || "hidden" === e.getAttribute("type")) return !1; let t = e; for (; t && t !== document.body && 11 !== t.nodeType;) { if (yt(t)) return !1; t = t.parentNode } return !0 }(e) } function _t(e) { const t = wt(e); return (Number.isNaN(t) || t >= 0) && xt(e) } function kt(e, t) { const n = (r = e, Array.from(r.querySelectorAll(bt)).filter(_t)); var r; if (!n.length) return void t.preventDefault(); const i = n[t.shiftKey ? 0 : n.length - 1], a = e.getRootNode(); let s = i === a.activeElement || e === a.activeElement; const o = a.activeElement; if ("INPUT" === o.tagName && "radio" === o.getAttribute("type")) { const e = n.filter((e => "radio" === e.getAttribute("type") && e.getAttribute("name") === o.getAttribute("name"))); s = e.includes(i) } if (!s) return; t.preventDefault(); const l = n[t.shiftKey ? n.length - 1 : 0]; l && l.focus() } function St() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const n = (0, t.useRef)(), r = (0, t.useRef)(null), i = e => { let t = e.querySelector("[data-autofocus]"); if (!t) { const n = Array.from(e.querySelectorAll(bt)); t = n.find(_t) || n.find(xt) || null, !t && xt(e) && (t = e) } t && t.focus({ preventScroll: !0 }) }, a = (0, t.useCallback)((t => { e && (null !== t ? (r.current = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body > :not(script)"; const n = gt(), r = Array.from(document.querySelectorAll(t)).map((t => { var r; if (null !== t && void 0 !== t && null !== (r = t.shadowRoot) && void 0 !== r && r.contains(e) || t.contains(e)) return; const i = t.getAttribute("aria-hidden"), a = t.getAttribute("data-hidden"), s = t.getAttribute("data-focus-id"); return t.setAttribute("data-focus-id", n), null === i || "false" === i ? t.setAttribute("aria-hidden", "true") : a || s || t.setAttribute("data-hidden", i), { node: t, ariaHidden: a || null } })); return () => { r.forEach((e => { e && n === e.node.getAttribute("data-focus-id") && (null === e.ariaHidden ? e.node.removeAttribute("aria-hidden") : e.node.setAttribute("aria-hidden", e.ariaHidden), e.node.removeAttribute("data-focus-id"), e.node.removeAttribute("data-hidden")) })) } }(t), n.current !== t && (t ? (setTimeout((() => { t.getRootNode() && i(t) })), n.current = t) : n.current = null)) : r.current && (r.current(), r.current = null)) }), [e]); return (0, t.useEffect)((() => { if (!e) return; n.current && setTimeout((() => i(n.current))); const t = e => { "Tab" === e.key && n.current && kt(n.current, e) }; return document.addEventListener("keydown", t), () => { document.removeEventListener("keydown", t), r.current && r.current() } }), [e]), a } function At(e, t) { "function" === typeof e ? e(t) : "object" === typeof e && null !== e && "current" in e && (e.current = t) } function Et() { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return (0, t.useCallback)(function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return e => { t.forEach((t => At(t, e))) } }(...n), n) } function Ct(e) { return !Array.isArray(e) && null !== e && ("object" === typeof e && e.type !== t.Fragment) } var Mt = { root: "m_515a97f8" }; const Tt = {}, Pt = J(((e, t) => { const n = Q("VisuallyHidden", Tt, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, ...c } = n, u = rt({ name: "VisuallyHidden", classes: Mt, props: n, className: i, style: a, classNames: r, styles: s, unstyled: o }); return (0, v.jsx)(Se, { component: "span", ref: t, ...u("root"), ...c }) })); function Rt(e) { let { children: n, active: r = !0, refProp: i = "ref", innerRef: a } = e; const s = Et(St(r), a); return Ct(n) ? (0, t.cloneElement)(n, { [i]: s }) : n } function Nt(e) { return (0, v.jsx)(Pt, { tabIndex: -1, "data-autofocus": !0, ...e }) } Pt.classes = Mt, Pt.displayName = "@mantine/core/VisuallyHidden", Rt.displayName = "@mantine/core/FocusTrap", Nt.displayName = "@mantine/core/FocusTrapInitialFocus", Rt.InitialFocus = Nt; var Lt = { root: "m_1b7284a3" }; const It = {}, Dt = (e, t) => { let { radius: n, shadow: r } = t; return { root: { "--paper-radius": void 0 === n ? void 0 : He(n), "--paper-shadow": qe(r) } } }, Ot = it(((e, t) => { const n = Q("Paper", It, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, withBorder: l, vars: c, radius: u, shadow: d, variant: h, mod: f, ...p } = n, m = rt({ name: "Paper", props: n, classes: Lt, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: c, varsResolver: Dt }); return (0, v.jsx)(Se, { ref: t, mod: [{ "data-with-border": l }, f], ...m("root"), variant: h, ...p }) })); Ot.classes = Lt, Ot.displayName = "@mantine/core/Paper"; const jt = e => ({ in: { opacity: 1, transform: "scale(1)" }, out: { opacity: 0, transform: "scale(.9) translateY(".concat(w("bottom" === e ? 10 : -10), ")") }, transitionProperty: "transform, opacity" }), Ft = { fade: { in: { opacity: 1 }, out: { opacity: 0 }, transitionProperty: "opacity" }, "fade-up": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(".concat(w(30)) }, transitionProperty: "opacity, transform" }, "fade-down": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(".concat(w(-30)) }, transitionProperty: "opacity, transform" }, "fade-left": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(".concat(w(30)) }, transitionProperty: "opacity, transform" }, "fade-right": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(".concat(w(-30)) }, transitionProperty: "opacity, transform" }, scale: { in: { opacity: 1, transform: "scale(1)" }, out: { opacity: 0, transform: "scale(0)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "scale-y": { in: { opacity: 1, transform: "scaleY(1)" }, out: { opacity: 0, transform: "scaleY(0)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "scale-x": { in: { opacity: 1, transform: "scaleX(1)" }, out: { opacity: 0, transform: "scaleX(0)" }, common: { transformOrigin: "left" }, transitionProperty: "transform, opacity" }, "skew-up": { in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" }, out: { opacity: 0, transform: "translateY(".concat(w(-20), ") skew(-10deg, -5deg)") }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "skew-down": { in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" }, out: { opacity: 0, transform: "translateY(".concat(w(20), ") skew(-10deg, -5deg)") }, common: { transformOrigin: "bottom" }, transitionProperty: "transform, opacity" }, "rotate-left": { in: { opacity: 1, transform: "translateY(0) rotate(0deg)" }, out: { opacity: 0, transform: "translateY(".concat(w(20), ") rotate(-5deg)") }, common: { transformOrigin: "bottom" }, transitionProperty: "transform, opacity" }, "rotate-right": { in: { opacity: 1, transform: "translateY(0) rotate(0deg)" }, out: { opacity: 0, transform: "translateY(".concat(w(20), ") rotate(5deg)") }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "slide-down": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(-100%)" }, common: { transformOrigin: "top" }, transitionProperty: "transform, opacity" }, "slide-up": { in: { opacity: 1, transform: "translateY(0)" }, out: { opacity: 0, transform: "translateY(100%)" }, common: { transformOrigin: "bottom" }, transitionProperty: "transform, opacity" }, "slide-left": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(100%)" }, common: { transformOrigin: "left" }, transitionProperty: "transform, opacity" }, "slide-right": { in: { opacity: 1, transform: "translateX(0)" }, out: { opacity: 0, transform: "translateX(-100%)" }, common: { transformOrigin: "right" }, transitionProperty: "transform, opacity" }, pop: { ...jt("bottom"), common: { transformOrigin: "center center" } }, "pop-bottom-left": { ...jt("bottom"), common: { transformOrigin: "bottom left" } }, "pop-bottom-right": { ...jt("bottom"), common: { transformOrigin: "bottom right" } }, "pop-top-left": { ...jt("top"), common: { transformOrigin: "top left" } }, "pop-top-right": { ...jt("top"), common: { transformOrigin: "top right" } } }, zt = { entering: "in", entered: "in", exiting: "out", exited: "out", "pre-exiting": "out", "pre-entering": "out" }; function Wt(e) { let { transition: t, state: n, duration: r, timingFunction: i } = e; const a = { transitionDuration: "".concat(r, "ms"), transitionTimingFunction: i }; return "string" === typeof t ? t in Ft ? { transitionProperty: Ft[t].transitionProperty, ...a, ...Ft[t].common, ...Ft[t][zt[n]] } : {} : { transitionProperty: t.transitionProperty, ...a, ...t.common, ...t[zt[n]] } } var Bt = __webpack_require__(950); function Ht(e, t) { return g("(prefers-reduced-motion: reduce)", e, t) } function Ut(e, n) { const r = (0, t.useRef)(!1); (0, t.useEffect)((() => () => { r.current = !1 }), []), (0, t.useEffect)((() => { if (r.current) return e(); r.current = !0 }), n) } function Vt(e) { let { duration: n, exitDuration: r, timingFunction: i, mounted: a, onEnter: s, onExit: o, onEntered: l, onExited: c, enterDelay: u, exitDelay: d } = e; const h = U(), f = Ht(), p = !!h.respectReducedMotion && f, [m, g] = (0, t.useState)(p ? 0 : n), [v, b] = (0, t.useState)(a ? "entered" : "exited"), y = (0, t.useRef)(-1), w = (0, t.useRef)(-1), x = (0, t.useRef)(-1), _ = e => { const t = e ? s : o, i = e ? l : c; window.clearTimeout(y.current); const a = p ? 0 : e ? n : r; g(a), 0 === a ? ("function" === typeof t && t(), "function" === typeof i && i(), b(e ? "entered" : "exited")) : x.current = requestAnimationFrame((() => { Bt.flushSync((() => { b(e ? "pre-entering" : "pre-exiting") })), x.current = requestAnimationFrame((() => { "function" === typeof t && t(), b(e ? "entering" : "exiting"), y.current = window.setTimeout((() => { "function" === typeof i && i(), b(e ? "entered" : "exited") }), a) })) })) }; return Ut((() => { var e; e = a, window.clearTimeout(w.current), "number" === typeof (e ? u : d) ? w.current = window.setTimeout((() => { _(e) }), e ? u : d) : _(e) }), [a]), (0, t.useEffect)((() => () => { window.clearTimeout(y.current), cancelAnimationFrame(x.current) }), []), { transitionDuration: m, transitionStatus: v, transitionTimingFunction: i || "ease" } } function qt(e) { let { keepMounted: t, transition: n = "fade", duration: r = 250, exitDuration: i = r, mounted: a, children: s, timingFunction: o = "ease", onExit: l, onEntered: c, onEnter: u, onExited: d, enterDelay: h, exitDelay: f } = e; const { transitionDuration: p, transitionStatus: m, transitionTimingFunction: g } = Vt({ mounted: a, exitDuration: i, duration: r, timingFunction: o, onExit: l, onEntered: c, onEnter: u, onExited: d, enterDelay: h, exitDelay: f }); return 0 === p ? a ? (0, v.jsx)(v.Fragment, { children: s({}) }) : t ? s({ display: "none" }) : null : "exited" === m ? t ? s({ display: "none" }) : null : (0, v.jsx)(v.Fragment, { children: s(Wt({ transition: n, duration: p, state: m, timingFunction: g })) }) } qt.displayName = "@mantine/core/Transition"; const Gt = (0, t.forwardRef)(((e, t) => { let { transitionProps: n, className: r, innerProps: i, onKeyDown: a, style: s, ...o } = e; const l = Ce(); return (0, v.jsx)(qt, { mounted: l.opened, transition: "pop", ...l.transitionProps, ...n, children: e => (0, v.jsx)("div", { ...i, className: te({ [Pe]: !l.unstyled }, i.className), children: (0, v.jsx)(Rt, { active: l.opened && l.trapFocus, innerRef: t, children: (0, v.jsx)(Ot, { ...o, component: "section", role: "dialog", tabIndex: -1, "aria-modal": !0, "aria-describedby": l.bodyMounted ? l.getBodyId() : void 0, "aria-labelledby": l.titleMounted ? l.getTitleId() : void 0, style: [s, e], className: te({ [Re]: !l.unstyled }, r), unstyled: l.unstyled, children: o.children }) }) }) }) })); function Xt(e) { let { children: t } = e; return (0, v.jsx)(v.Fragment, { children: t }) } const Yt = {}, Kt = J(((e, t) => { const n = Q("ModalContent", Yt, e), { classNames: r, className: i, style: a, styles: s, vars: o, children: l, ...c } = n, u = Oe(), d = u.scrollAreaComponent || Xt; return (0, v.jsx)(Gt, { ...u.getStyles("content", { className: i, style: a, styles: s, classNames: r }), innerProps: u.getStyles("inner", { className: i, style: a, styles: s, classNames: r }), "data-full-screen": u.fullScreen || void 0, "data-modal-content": !0, ref: t, ...c, children: (0, v.jsx)(d, { style: { maxHeight: u.fullScreen ? "100dvh" : "calc(100dvh - (".concat(w(u.yOffset), " * 2))") }, children: l }) }) })); Kt.classes = je, Kt.displayName = "@mantine/core/ModalContent"; const Qt = (0, t.forwardRef)(((e, t) => { let { className: n, ...r } = e; const i = Ce(); return (0, v.jsx)(Se, { component: "header", ref: t, className: te({ [Te]: !i.unstyled }, n), ...r }) })); Qt.displayName = "@mantine/core/ModalBaseHeader"; const $t = {}, Jt = J(((e, t) => { const n = Q("ModalHeader", $t, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = Oe(); return (0, v.jsx)(Qt, { ref: t, ...c.getStyles("header", { classNames: r, style: a, styles: s, className: i }), ...l }) })); Jt.classes = je, Jt.displayName = "@mantine/core/ModalHeader"; var Zt = { root: "m_9814e45f" }; const en = { zIndex: Y("modal") }, tn = (e, t) => { let { gradient: n, color: r, backgroundOpacity: i, blur: a, radius: s, zIndex: o } = t; return { root: { "--overlay-bg": n || (void 0 !== r || void 0 !== i) && R(r || "#000", null !== i && void 0 !== i ? i : .6) || void 0, "--overlay-filter": a ? "blur(".concat(w(a), ")") : void 0, "--overlay-radius": void 0 === s ? void 0 : He(s), "--overlay-z-index": null === o || void 0 === o ? void 0 : o.toString() } } }, nn = it(((e, t) => { const n = Q("Overlay", en, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, fixed: c, center: u, children: d, radius: h, zIndex: f, gradient: p, blur: m, color: g, backgroundOpacity: b, mod: y, ...w } = n, x = rt({ name: "Overlay", props: n, classes: Zt, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: l, varsResolver: tn }); return (0, v.jsx)(Se, { ref: t, ...x("root"), mod: [{ center: u, fixed: c }, y], ...w, children: d }) })); nn.classes = Zt, nn.displayName = "@mantine/core/Overlay"; const rn = { duration: 200, timingFunction: "ease", transition: "fade" }; const an = (0, t.forwardRef)(((e, t) => { let { onClick: n, transitionProps: r, style: i, ...a } = e; const s = Ce(), o = function (e) { const t = Ce(); return { ...rn, ...t.transitionProps, ...e } }(r); return (0, v.jsx)(qt, { mounted: s.opened, ...o, transition: "fade", children: e => (0, v.jsx)(nn, { ref: t, fixed: !0, style: [i, e], zIndex: s.zIndex, unstyled: s.unstyled, onClick: e => { null === n || void 0 === n || n(e), s.closeOnClickOutside && s.onClose() }, ...a }) }) })); an.displayName = "@mantine/core/ModalBaseOverlay"; const sn = {}, on = J(((e, t) => { const n = Q("ModalOverlay", sn, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = Oe(); return (0, v.jsx)(an, { ref: t, ...c.getStyles("overlay", { classNames: r, style: a, styles: s, className: i }), ...l }) })); on.classes = je, on.displayName = "@mantine/core/ModalOverlay"; var ln = function () { return ln = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, ln.apply(this, arguments) }; function cn(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" === typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n } Object.create; function un(e, t, n) { if (n || 2 === arguments.length) for (var r, i = 0, a = t.length; i < a; i++)!r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]); return e.concat(r || Array.prototype.slice.call(t)) } Object.create; "function" === typeof SuppressedError && SuppressedError; var dn = "right-scroll-bar-position", hn = "width-before-scroll-bar"; function fn(e, t) { return "function" === typeof e ? e(t) : e && (e.current = t), e } var pn = "undefined" !== typeof window ? t.useLayoutEffect : t.useEffect, mn = new WeakMap; function gn(e, n) { var r = function (e, n) { var r = (0, t.useState)((function () { return { value: e, callback: n, facade: { get current() { return r.value }, set current(e) { var t = r.value; t !== e && (r.value = e, r.callback(e, t)) } } } }))[0]; return r.callback = n, r.facade }(n || null, (function (t) { return e.forEach((function (e) { return fn(e, t) })) })); return pn((function () { var t = mn.get(r); if (t) { var n = new Set(t), i = new Set(e), a = r.current; n.forEach((function (e) { i.has(e) || fn(e, null) })), i.forEach((function (e) { n.has(e) || fn(e, a) })) } mn.set(r, e) }), [e]), r } function vn(e) { return e } function bn(e, t) { void 0 === t && (t = vn); var n = [], r = !1; return { read: function () { if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return n.length ? n[n.length - 1] : e }, useMedium: function (e) { var i = t(e, r); return n.push(i), function () { n = n.filter((function (e) { return e !== i })) } }, assignSyncMedium: function (e) { for (r = !0; n.length;) { var t = n; n = [], t.forEach(e) } n = { push: function (t) { return e(t) }, filter: function () { return n } } }, assignMedium: function (e) { r = !0; var t = []; if (n.length) { var i = n; n = [], i.forEach(e), t = n } var a = function () { var n = t; t = [], n.forEach(e) }, s = function () { return Promise.resolve().then(a) }; s(), n = { push: function (e) { t.push(e), s() }, filter: function (e) { return t = t.filter(e), n } } } } } var yn = function (e) { void 0 === e && (e = {}); var t = bn(null); return t.options = ln({ async: !0, ssr: !1 }, e), t }(), wn = function () { }, xn = t.forwardRef((function (e, n) { var r = t.useRef(null), i = t.useState({ onScrollCapture: wn, onWheelCapture: wn, onTouchMoveCapture: wn }), a = i[0], s = i[1], o = e.forwardProps, l = e.children, c = e.className, u = e.removeScrollBar, d = e.enabled, h = e.shards, f = e.sideCar, p = e.noIsolation, m = e.inert, g = e.allowPinchZoom, v = e.as, b = void 0 === v ? "div" : v, y = e.gapMode, w = cn(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = f, _ = gn([r, n]), k = ln(ln({}, w), a); return t.createElement(t.Fragment, null, d && t.createElement(x, { sideCar: yn, removeScrollBar: u, shards: h, noIsolation: p, inert: m, setCallbacks: s, allowPinchZoom: !!g, lockRef: r, gapMode: y }), o ? t.cloneElement(t.Children.only(l), ln(ln({}, k), { ref: _ })) : t.createElement(b, ln({}, k, { className: c, ref: _ }), l)) })); xn.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }, xn.classNames = { fullWidth: hn, zeroRight: dn }; var _n, kn = function (e) { var n = e.sideCar, r = cn(e, ["sideCar"]); if (!n) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var i = n.read(); if (!i) throw new Error("Sidecar medium not found"); return t.createElement(i, ln({}, r)) }; kn.isSideCarExport = !0; function Sn() { if (!document) return null; var e = document.createElement("style"); e.type = "text/css"; var t = _n || __webpack_require__.nc; return t && e.setAttribute("nonce", t), e } var An = function () { var e = 0, t = null; return { add: function (n) { var r, i; 0 == e && (t = Sn()) && (i = n, (r = t).styleSheet ? r.styleSheet.cssText = i : r.appendChild(document.createTextNode(i)), function (e) { (document.head || document.getElementsByTagName("head")[0]).appendChild(e) }(t)), e++ }, remove: function () { ! --e && t && (t.parentNode && t.parentNode.removeChild(t), t = null) } } }, En = function () { var e = function () { var e = An(); return function (n, r) { t.useEffect((function () { return e.add(n), function () { e.remove() } }), [n && r]) } }(); return function (t) { var n = t.styles, r = t.dynamic; return e(n, r), null } }, Cn = { left: 0, top: 0, right: 0, gap: 0 }, Mn = function (e) { return parseInt(e || "", 10) || 0 }, Tn = function (e) { if (void 0 === e && (e = "margin"), "undefined" === typeof window) return Cn; var t = function (e) { var t = window.getComputedStyle(document.body), n = t["padding" === e ? "paddingLeft" : "marginLeft"], r = t["padding" === e ? "paddingTop" : "marginTop"], i = t["padding" === e ? "paddingRight" : "marginRight"]; return [Mn(n), Mn(r), Mn(i)] }(e), n = document.documentElement.clientWidth, r = window.innerWidth; return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) } }, Pn = En(), Rn = "data-scroll-locked", Nn = function (e, t, n, r) { var i = e.left, a = e.top, s = e.right, o = e.gap; return void 0 === n && (n = "margin"), "\n  .".concat("with-scroll-bars-hidden", " {\n   overflow: hidden ").concat(r, ";\n   padding-right: ").concat(o, "px ").concat(r, ";\n  }\n  body[").concat(Rn, "] {\n    overflow: hidden ").concat(r, ";\n    overscroll-behavior: contain;\n    ").concat([t && "position: relative ".concat(r, ";"), "margin" === n && "\n    padding-left: ".concat(i, "px;\n    padding-top: ").concat(a, "px;\n    padding-right: ").concat(s, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(o, "px ").concat(r, ";\n    "), "padding" === n && "padding-right: ".concat(o, "px ").concat(r, ";")].filter(Boolean).join(""), "\n  }\n  \n  .").concat(dn, " {\n    right: ").concat(o, "px ").concat(r, ";\n  }\n  \n  .").concat(hn, " {\n    margin-right: ").concat(o, "px ").concat(r, ";\n  }\n  \n  .").concat(dn, " .").concat(dn, " {\n    right: 0 ").concat(r, ";\n  }\n  \n  .").concat(hn, " .").concat(hn, " {\n    margin-right: 0 ").concat(r, ";\n  }\n  \n  body[").concat(Rn, "] {\n    ").concat("--removed-body-scroll-bar-size", ": ").concat(o, "px;\n  }\n") }, Ln = function () { var e = parseInt(document.body.getAttribute(Rn) || "0", 10); return isFinite(e) ? e : 0 }, In = function (e) { var n = e.noRelative, r = e.noImportant, i = e.gapMode, a = void 0 === i ? "margin" : i; t.useEffect((function () { return document.body.setAttribute(Rn, (Ln() + 1).toString()), function () { var e = Ln() - 1; e <= 0 ? document.body.removeAttribute(Rn) : document.body.setAttribute(Rn, e.toString()) } }), []); var s = t.useMemo((function () { return Tn(a) }), [a]); return t.createElement(Pn, { styles: Nn(s, !n, a, r ? "" : "!important") }) }, Dn = !1; if ("undefined" !== typeof window) try { var On = Object.defineProperty({}, "passive", { get: function () { return Dn = !0, !0 } }); window.addEventListener("test", On, On), window.removeEventListener("test", On, On) } catch (TC) { Dn = !1 } var jn = !!Dn && { passive: !1 }, Fn = function (e, t) { if (!(e instanceof Element)) return !1; var n = window.getComputedStyle(e); return "hidden" !== n[t] && !(n.overflowY === n.overflowX && !function (e) { return "TEXTAREA" === e.tagName }(e) && "visible" === n[t]) }, zn = function (e, t) { var n = t.ownerDocument, r = t; do { if ("undefined" !== typeof ShadowRoot && r instanceof ShadowRoot && (r = r.host), Wn(e, r)) { var i = Bn(e, r); if (i[1] > i[2]) return !0 } r = r.parentNode } while (r && r !== n.body); return !1 }, Wn = function (e, t) { return "v" === e ? function (e) { return Fn(e, "overflowY") }(t) : function (e) { return Fn(e, "overflowX") }(t) }, Bn = function (e, t) { return "v" === e ? [(n = t).scrollTop, n.scrollHeight, n.clientHeight] : function (e) { return [e.scrollLeft, e.scrollWidth, e.clientWidth] }(t); var n }, Hn = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, Un = function (e) { return [e.deltaX, e.deltaY] }, Vn = function (e) { return e && "current" in e ? e.current : e }, qn = function (e) { return "\n  .block-interactivity-".concat(e, " {pointer-events: none;}\n  .allow-interactivity-").concat(e, " {pointer-events: all;}\n") }, Gn = 0, Xn = []; function Yn(e) { for (var t = null; null !== e;)e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode; return t } const Kn = (Qn = function (e) { var n = t.useRef([]), r = t.useRef([0, 0]), i = t.useRef(), a = t.useState(Gn++)[0], s = t.useState(En)[0], o = t.useRef(e); t.useEffect((function () { o.current = e }), [e]), t.useEffect((function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(a)); var t = un([e.lockRef.current], (e.shards || []).map(Vn), !0).filter(Boolean); return t.forEach((function (e) { return e.classList.add("allow-interactivity-".concat(a)) })), function () { document.body.classList.remove("block-interactivity-".concat(a)), t.forEach((function (e) { return e.classList.remove("allow-interactivity-".concat(a)) })) } } }), [e.inert, e.lockRef.current, e.shards]); var l = t.useCallback((function (e, t) { if ("touches" in e && 2 === e.touches.length) return !o.current.allowPinchZoom; var n, a = Hn(e), s = r.current, l = "deltaX" in e ? e.deltaX : s[0] - a[0], c = "deltaY" in e ? e.deltaY : s[1] - a[1], u = e.target, d = Math.abs(l) > Math.abs(c) ? "h" : "v"; if ("touches" in e && "h" === d && "range" === u.type) return !1; var h = zn(d, u); if (!h) return !0; if (h ? n = d : (n = "v" === d ? "h" : "v", h = zn(d, u)), !h) return !1; if (!i.current && "changedTouches" in e && (l || c) && (i.current = n), !n) return !0; var f = i.current || n; return function (e, t, n, r, i) { var a = function (e, t) { return "h" === e && "rtl" === t ? -1 : 1 }(e, window.getComputedStyle(t).direction), s = a * r, o = n.target, l = t.contains(o), c = !1, u = s > 0, d = 0, h = 0; do { var f = Bn(e, o), p = f[0], m = f[1] - f[2] - a * p; (p || m) && Wn(e, o) && (d += m, h += p), o = o instanceof ShadowRoot ? o.host : o.parentNode } while (!l && o !== document.body || l && (t.contains(o) || t === o)); return (u && (i && Math.abs(d) < 1 || !i && s > d) || !u && (i && Math.abs(h) < 1 || !i && -s > h)) && (c = !0), c }(f, t, e, "h" === f ? l : c, !0) }), []), c = t.useCallback((function (e) { var t = e; if (Xn.length && Xn[Xn.length - 1] === s) { var r = "deltaY" in t ? Un(t) : Hn(t), i = n.current.filter((function (e) { return e.name === t.type && (e.target === t.target || t.target === e.shadowParent) && (n = e.delta, i = r, n[0] === i[0] && n[1] === i[1]); var n, i }))[0]; if (i && i.should) t.cancelable && t.preventDefault(); else if (!i) { var a = (o.current.shards || []).map(Vn).filter(Boolean).filter((function (e) { return e.contains(t.target) })); (a.length > 0 ? l(t, a[0]) : !o.current.noIsolation) && t.cancelable && t.preventDefault() } } }), []), u = t.useCallback((function (e, t, r, i) { var a = { name: e, delta: t, target: r, should: i, shadowParent: Yn(r) }; n.current.push(a), setTimeout((function () { n.current = n.current.filter((function (e) { return e !== a })) }), 1) }), []), d = t.useCallback((function (e) { r.current = Hn(e), i.current = void 0 }), []), h = t.useCallback((function (t) { u(t.type, Un(t), t.target, l(t, e.lockRef.current)) }), []), f = t.useCallback((function (t) { u(t.type, Hn(t), t.target, l(t, e.lockRef.current)) }), []); t.useEffect((function () { return Xn.push(s), e.setCallbacks({ onScrollCapture: h, onWheelCapture: h, onTouchMoveCapture: f }), document.addEventListener("wheel", c, jn), document.addEventListener("touchmove", c, jn), document.addEventListener("touchstart", d, jn), function () { Xn = Xn.filter((function (e) { return e !== s })), document.removeEventListener("wheel", c, jn), document.removeEventListener("touchmove", c, jn), document.removeEventListener("touchstart", d, jn) } }), []); var p = e.removeScrollBar, m = e.inert; return t.createElement(t.Fragment, null, m ? t.createElement(s, { styles: qn(a) }) : null, p ? t.createElement(In, { gapMode: e.gapMode }) : null) }, yn.useMedium(Qn), kn); var Qn, $n = t.forwardRef((function (e, n) { return t.createElement(xn, ln({}, e, { ref: n, sideCar: Kn })) })); $n.classNames = xn.classNames; const Jn = $n, Zn = "undefined" !== typeof document ? t.useLayoutEffect : t.useEffect; const er = {}, tr = (0, t.forwardRef)(((e, n) => { const { children: r, target: i, ...a } = Q("Portal", er, e), [s, o] = (0, t.useState)(!1), l = (0, t.useRef)(null); return Zn((() => (o(!0), l.current = i ? "string" === typeof i ? document.querySelector(i) : i : function (e) { const t = document.createElement("div"); return t.setAttribute("data-portal", "true"), "string" === typeof e.className && t.classList.add(...e.className.split(" ").filter(Boolean)), "object" === typeof e.style && Object.assign(t.style, e.style), "string" === typeof e.id && t.setAttribute("id", e.id), t }(a), At(n, l.current), !i && l.current && document.body.appendChild(l.current), () => { !i && l.current && document.body.removeChild(l.current) })), [i]), s && l.current ? (0, Bt.createPortal)((0, v.jsx)(v.Fragment, { children: r }), l.current) : null })); function nr(e) { let { withinPortal: t = !0, children: n, ...r } = e; return t ? (0, v.jsx)(tr, { ...r, children: n }) : (0, v.jsx)(v.Fragment, { children: n }) } tr.displayName = "@mantine/core/Portal", nr.displayName = "@mantine/core/OptionalPortal"; const rr = t["useId".toString()] || (() => { }); function ir(e) { const n = function () { const e = rr(); return e ? "mantine-".concat(e.replace(/:/g, "")) : "" }(), [r, i] = (0, t.useState)(n); return Zn((() => { i(gt()) }), []), "string" === typeof e ? e : "undefined" === typeof window ? n : r } function ar(e) { let { id: n, transitionProps: r, opened: i, trapFocus: a, closeOnEscape: s, onClose: o, returnFocus: l } = e; const c = ir(n), [u, d] = (0, t.useState)(!1), [h, f] = (0, t.useState)(!1), p = "number" === typeof (null === r || void 0 === r ? void 0 : r.duration) ? null === r || void 0 === r ? void 0 : r.duration : 200, m = function (e) { let { opened: n, transitionDuration: r } = e; const [i, a] = (0, t.useState)(n), s = (0, t.useRef)(), o = Ht() ? 0 : r; return (0, t.useEffect)((() => (n ? (a(!0), window.clearTimeout(s.current)) : 0 === o ? a(!1) : s.current = window.setTimeout((() => a(!1)), o), () => window.clearTimeout(s.current))), [n, o]), i }({ opened: i, transitionDuration: p }); return function (e, n, r) { (0, t.useEffect)((() => (window.addEventListener(e, n, r), () => window.removeEventListener(e, n, r))), [e, n]) }("keydown", (e => { if ("Escape" === e.key && s && i) { var t; "true" !== (null === (t = e.target) || void 0 === t ? void 0 : t.getAttribute("data-mantine-stop-propagation")) && o() } }), { capture: !0 }), function (e) { let { opened: n, shouldReturnFocus: r = !0 } = e; const i = (0, t.useRef)(), a = () => { var e; i.current && "focus" in i.current && "function" === typeof i.current.focus && (null === (e = i.current) || void 0 === e || e.focus({ preventScroll: !0 })) }; Ut((() => { let e = -1; const t = t => { "Tab" === t.key && window.clearTimeout(e) }; return document.addEventListener("keydown", t), n ? i.current = document.activeElement : r && (e = window.setTimeout(a, 10)), () => { window.clearTimeout(e), document.removeEventListener("keydown", t) } }), [n, r]) }({ opened: i, shouldReturnFocus: a && l }), { _id: c, titleMounted: u, bodyMounted: h, shouldLockScroll: m, setTitleMounted: d, setBodyMounted: f } } const sr = (0, t.forwardRef)(((e, t) => { let { keepMounted: n, opened: r, onClose: i, id: a, transitionProps: s, trapFocus: o, closeOnEscape: l, returnFocus: c, closeOnClickOutside: u, withinPortal: d, portalProps: h, lockScroll: f, children: p, zIndex: m, shadow: g, padding: b, __vars: y, unstyled: w, removeScrollProps: x, ..._ } = e; const { _id: k, titleMounted: S, bodyMounted: A, shouldLockScroll: E, setTitleMounted: C, setBodyMounted: M } = ar({ id: a, transitionProps: s, opened: r, trapFocus: o, closeOnEscape: l, onClose: i, returnFocus: c }), { key: T, ...P } = x || {}; return (0, v.jsx)(nr, { ...h, withinPortal: d, children: (0, v.jsx)(Ee, { value: { opened: r, onClose: i, closeOnClickOutside: u, transitionProps: { ...s, keepMounted: n }, getTitleId: () => "".concat(k, "-title"), getBodyId: () => "".concat(k, "-body"), titleMounted: S, bodyMounted: A, setTitleMounted: C, setBodyMounted: M, trapFocus: o, closeOnEscape: l, zIndex: m, unstyled: w }, children: (0, v.jsx)(Jn, { enabled: E && f, ...P, children: (0, v.jsx)(Se, { ref: t, ..._, __vars: { ...y, "--mb-z-index": (m || Y("modal")).toString(), "--mb-shadow": qe(g), "--mb-padding": Be(b) }, children: p }) }, T) }) }) })), or = { __staticSelector: "Modal", closeOnClickOutside: !0, withinPortal: !0, lockScroll: !0, trapFocus: !0, returnFocus: !0, closeOnEscape: !0, keepMounted: !1, zIndex: Y("modal"), transitionProps: { duration: 200, transition: "pop" }, yOffset: "5dvh" }, lr = (e, t) => { let { radius: n, size: r, yOffset: i, xOffset: a } = t; return { root: { "--modal-radius": void 0 === n ? void 0 : He(n), "--modal-size": We(r, "modal-size"), "--modal-y-offset": w(i), "--modal-x-offset": w(a) } } }, cr = J(((e, t) => { const n = Q("ModalRoot", or, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, yOffset: c, scrollAreaComponent: u, radius: d, fullScreen: h, centered: f, xOffset: p, __staticSelector: m, ...g } = n, b = rt({ name: m, classes: je, props: n, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: l, varsResolver: lr }); return (0, v.jsx)(De, { value: { yOffset: c, scrollAreaComponent: u, getStyles: b, fullScreen: h }, children: (0, v.jsx)(sr, { ref: t, ...b("root"), "data-full-screen": h || void 0, "data-centered": f || void 0, unstyled: o, ...g }) }) })); cr.classes = je, cr.displayName = "@mantine/core/ModalRoot"; const ur = (0, t.forwardRef)(((e, n) => { let { className: r, ...i } = e; const a = function () { const e = Ce(); return (0, t.useEffect)((() => (e.setTitleMounted(!0), () => e.setTitleMounted(!1))), []), e.getTitleId() }(), s = Ce(); return (0, v.jsx)(Se, { component: "h2", ref: n, className: te({ [Me]: !s.unstyled }, r), ...i, id: a }) })); ur.displayName = "@mantine/core/ModalBaseTitle"; const dr = {}, hr = J(((e, t) => { const n = Q("ModalTitle", dr, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = Oe(); return (0, v.jsx)(ur, { ref: t, ...c.getStyles("title", { classNames: r, style: a, styles: s, className: i }), ...l }) })); hr.classes = je, hr.displayName = "@mantine/core/ModalTitle"; const fr = { closeOnClickOutside: !0, withinPortal: !0, lockScroll: !0, trapFocus: !0, returnFocus: !0, closeOnEscape: !0, keepMounted: !1, zIndex: Y("modal"), transitionProps: { duration: 200, transition: "fade-down" }, withOverlay: !0, withCloseButton: !0 }, pr = J(((e, t) => { const { title: n, withOverlay: r, overlayProps: i, withCloseButton: a, closeButtonProps: s, children: o, radius: l, ...c } = Q("Modal", fr, e), u = !!n || a; return (0, v.jsxs)(cr, { ref: t, radius: l, ...c, children: [r && (0, v.jsx)(on, { ...i }), (0, v.jsxs)(Kt, { radius: l, children: [u && (0, v.jsxs)(Jt, { children: [n && (0, v.jsx)(hr, { children: n }), a && (0, v.jsx)(mt, { ...s })] }), (0, v.jsx)(ze, { children: o })] })] }) })); pr.classes = je, pr.displayName = "@mantine/core/Modal", pr.Root = cr, pr.Overlay = on, pr.Content = Kt, pr.Body = ze, pr.Header = Jt, pr.Title = hr, pr.CloseButton = mt; const [mr, gr] = Ae("ScrollArea.Root component was not found in tree"); function vr(e) { const n = (0, t.useRef)(e); return (0, t.useEffect)((() => { n.current = e })), (0, t.useMemo)((() => function () { for (var e, t = arguments.length, r = new Array(t), i = 0; i < t; i++)r[i] = arguments[i]; return null === (e = n.current) || void 0 === e ? void 0 : e.call(n, ...r) }), []) } function br(e, t) { const n = vr(t); Zn((() => { let t = 0; if (e) { const r = new ResizeObserver((() => { cancelAnimationFrame(t), t = window.requestAnimationFrame(n) })); return r.observe(e), () => { window.cancelAnimationFrame(t), r.unobserve(e) } } }), [e, n]) } const yr = (0, t.forwardRef)(((e, n) => { const { style: r, ...i } = e, a = gr(), [s, o] = (0, t.useState)(0), [l, c] = (0, t.useState)(0), u = Boolean(s && l); return br(a.scrollbarX, (() => { var e; const t = (null === (e = a.scrollbarX) || void 0 === e ? void 0 : e.offsetHeight) || 0; a.onCornerHeightChange(t), c(t) })), br(a.scrollbarY, (() => { var e; const t = (null === (e = a.scrollbarY) || void 0 === e ? void 0 : e.offsetWidth) || 0; a.onCornerWidthChange(t), o(t) })), u ? (0, v.jsx)("div", { ...i, ref: n, style: { ...r, width: s, height: l } }) : null })), wr = (0, t.forwardRef)(((e, t) => { const n = gr(), r = Boolean(n.scrollbarX && n.scrollbarY); return "scroll" !== n.type && r ? (0, v.jsx)(yr, { ...e, ref: t }) : null })), xr = { scrollHideDelay: 1e3, type: "hover" }, _r = (0, t.forwardRef)(((e, n) => { const r = Q("ScrollAreaRoot", xr, e), { type: i, scrollHideDelay: a, scrollbars: s, ...o } = r, [l, c] = (0, t.useState)(null), [u, d] = (0, t.useState)(null), [h, f] = (0, t.useState)(null), [p, m] = (0, t.useState)(null), [g, b] = (0, t.useState)(null), [y, w] = (0, t.useState)(0), [x, _] = (0, t.useState)(0), [k, S] = (0, t.useState)(!1), [A, E] = (0, t.useState)(!1), C = Et(n, (e => c(e))); return (0, v.jsx)(mr, { value: { type: i, scrollHideDelay: a, scrollArea: l, viewport: u, onViewportChange: d, content: h, onContentChange: f, scrollbarX: p, onScrollbarXChange: m, scrollbarXEnabled: k, onScrollbarXEnabledChange: S, scrollbarY: g, onScrollbarYChange: b, scrollbarYEnabled: A, onScrollbarYEnabledChange: E, onCornerWidthChange: w, onCornerHeightChange: _ }, children: (0, v.jsx)(Se, { ...o, ref: C, __vars: { "--sa-corner-width": "xy" !== s ? "0px" : "".concat(y, "px"), "--sa-corner-height": "xy" !== s ? "0px" : "".concat(x, "px") } }) }) })); function kr(e, n) { const r = vr(e), i = (0, t.useRef)(0); return (0, t.useEffect)((() => () => window.clearTimeout(i.current)), []), (0, t.useCallback)((function () { for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; window.clearTimeout(i.current), i.current = window.setTimeout((() => r(...t)), n) }), [r, n]) } _r.displayName = "@mantine/core/ScrollAreaRoot"; const Sr = (0, t.createContext)({ dir: "ltr", toggleDirection: () => { }, setDirection: () => { } }); function Ar() { return (0, t.useContext)(Sr) } function Er(e, t) { const n = e / t; return Number.isNaN(n) ? 0 : n } function Cr(e) { const t = Er(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t; return Math.max(r, 18) } function Mr(e, t) { return n => { if (e[0] === e[1] || t[0] === t[1]) return t[0]; const r = (t[1] - t[0]) / (e[1] - e[0]); return t[0] + r * (n - e[0]) } } function Tr(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "ltr"; const r = Cr(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, a = t.scrollbar.size - i, s = t.content - t.viewport, o = a - r, l = function (e, t) { let [n, r] = t; return Math.min(r, Math.max(n, e)) }(e, "ltr" === n ? [0, s] : [-1 * s, 0]); return Mr([0, s], [0, o])(l) } function Pr(e, t) { return e > 0 && e < t } function Rr(e) { return e ? parseInt(e, 10) : 0 } function Nr(e, t) { let { checkForDefaultPrevented: n = !0 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return r => { null === e || void 0 === e || e(r), !1 !== n && r.defaultPrevented || null === t || void 0 === t || t(r) } } const [Lr, Ir] = Ae("ScrollAreaScrollbar was not found in tree"), Dr = (0, t.forwardRef)(((e, n) => { const { sizes: r, hasThumb: i, onThumbChange: a, onThumbPointerUp: s, onThumbPointerDown: o, onThumbPositionChange: l, onDragScroll: c, onWheelScroll: u, onResize: d, ...h } = e, f = gr(), [p, m] = (0, t.useState)(null), g = Et(n, (e => m(e))), b = (0, t.useRef)(null), y = (0, t.useRef)(""), { viewport: w } = f, x = r.content - r.viewport, _ = vr(u), k = vr(l), S = kr(d, 10), A = e => { if (b.current) { const t = e.clientX - b.current.left, n = e.clientY - b.current.top; c({ x: t, y: n }) } }; return (0, t.useEffect)((() => { const e = e => { const t = e.target; (null === p || void 0 === p ? void 0 : p.contains(t)) && _(e, x) }; return document.addEventListener("wheel", e, { passive: !1 }), () => document.removeEventListener("wheel", e, { passive: !1 }) }), [w, p, x, _]), (0, t.useEffect)(k, [r, k]), br(p, S), br(f.content, S), (0, v.jsx)(Lr, { value: { scrollbar: p, hasThumb: i, onThumbChange: vr(a), onThumbPointerUp: vr(s), onThumbPositionChange: k, onThumbPointerDown: vr(o) }, children: (0, v.jsx)("div", { ...h, ref: g, "data-mantine-scrollbar": !0, style: { position: "absolute", ...h.style }, onPointerDown: Nr(e.onPointerDown, (e => { e.preventDefault(); if (0 === e.button) { e.target.setPointerCapture(e.pointerId), b.current = p.getBoundingClientRect(), y.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", document.body.style.pointerEvents = "none", A(e) } })), onPointerMove: Nr(e.onPointerMove, A), onPointerUp: Nr(e.onPointerUp, (e => { e.preventDefault(); const t = e.target; t.hasPointerCapture(e.pointerId) && t.releasePointerCapture(e.pointerId), document.body.style.webkitUserSelect = y.current, document.body.style.pointerEvents = "auto", b.current = null })) }) }) })), Or = (0, t.forwardRef)(((e, n) => { const { sizes: r, onSizesChange: i, style: a, ...s } = e, o = gr(), [l, c] = (0, t.useState)(), u = (0, t.useRef)(null), d = Et(n, u, o.onScrollbarXChange); return (0, t.useEffect)((() => { u.current && c(getComputedStyle(u.current)) }), [u]), (0, v.jsx)(Dr, { "data-orientation": "horizontal", ...s, ref: d, sizes: r, style: { ...a, "--sa-thumb-width": "".concat(Cr(r), "px") }, onThumbPointerDown: t => e.onThumbPointerDown(t.x), onDragScroll: t => e.onDragScroll(t.x), onWheelScroll: (t, n) => { if (o.viewport) { const r = o.viewport.scrollLeft + t.deltaX; e.onWheelScroll(r), Pr(r, n) && t.preventDefault() } }, onResize: () => { u.current && o.viewport && l && i({ content: o.viewport.scrollWidth, viewport: o.viewport.offsetWidth, scrollbar: { size: u.current.clientWidth, paddingStart: Rr(l.paddingLeft), paddingEnd: Rr(l.paddingRight) } }) } }) })), jr = (0, t.forwardRef)(((e, n) => { const { sizes: r, onSizesChange: i, style: a, ...s } = e, o = gr(), [l, c] = (0, t.useState)(), u = (0, t.useRef)(null), d = Et(n, u, o.onScrollbarYChange); return (0, t.useEffect)((() => { u.current && c(window.getComputedStyle(u.current)) }), []), (0, v.jsx)(Dr, { ...s, "data-orientation": "vertical", ref: d, sizes: r, style: { "--sa-thumb-height": "".concat(Cr(r), "px"), ...a }, onThumbPointerDown: t => e.onThumbPointerDown(t.y), onDragScroll: t => e.onDragScroll(t.y), onWheelScroll: (t, n) => { if (o.viewport) { const r = o.viewport.scrollTop + t.deltaY; e.onWheelScroll(r), Pr(r, n) && t.preventDefault() } }, onResize: () => { u.current && o.viewport && l && i({ content: o.viewport.scrollHeight, viewport: o.viewport.offsetHeight, scrollbar: { size: u.current.clientHeight, paddingStart: Rr(l.paddingTop), paddingEnd: Rr(l.paddingBottom) } }) } }) })), Fr = (0, t.forwardRef)(((e, n) => { const { orientation: r = "vertical", ...i } = e, { dir: a } = Ar(), s = gr(), o = (0, t.useRef)(null), l = (0, t.useRef)(0), [c, u] = (0, t.useState)({ content: 0, viewport: 0, scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 } }), d = Er(c.viewport, c.content), h = { ...i, sizes: c, onSizesChange: u, hasThumb: Boolean(d > 0 && d < 1), onThumbChange: e => { o.current = e }, onThumbPointerUp: () => { l.current = 0 }, onThumbPointerDown: e => { l.current = e } }, f = (e, t) => function (e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "ltr"; const i = Cr(n), a = t || i / 2, s = i - a, o = n.scrollbar.paddingStart + a, l = n.scrollbar.size - n.scrollbar.paddingEnd - s, c = n.content - n.viewport; return Mr([o, l], "ltr" === r ? [0, c] : [-1 * c, 0])(e) }(e, l.current, c, t); return "horizontal" === r ? (0, v.jsx)(Or, { ...h, ref: n, onThumbPositionChange: () => { if (s.viewport && o.current) { const e = Tr(s.viewport.scrollLeft, c, a); o.current.style.transform = "translate3d(".concat(e, "px, 0, 0)") } }, onWheelScroll: e => { s.viewport && (s.viewport.scrollLeft = e) }, onDragScroll: e => { s.viewport && (s.viewport.scrollLeft = f(e, a)) } }) : "vertical" === r ? (0, v.jsx)(jr, { ...h, ref: n, onThumbPositionChange: () => { if (s.viewport && o.current) { const e = Tr(s.viewport.scrollTop, c); 0 === c.scrollbar.size ? o.current.style.opacity = "0" : o.current.style.opacity = "1", o.current.style.transform = "translate3d(0, ".concat(e, "px, 0)") } }, onWheelScroll: e => { s.viewport && (s.viewport.scrollTop = e) }, onDragScroll: e => { s.viewport && (s.viewport.scrollTop = f(e)) } }) : null })), zr = (0, t.forwardRef)(((e, n) => { const r = gr(), { forceMount: i, ...a } = e, [s, o] = (0, t.useState)(!1), l = "horizontal" === e.orientation, c = kr((() => { if (r.viewport) { const e = r.viewport.offsetWidth < r.viewport.scrollWidth, t = r.viewport.offsetHeight < r.viewport.scrollHeight; o(l ? e : t) } }), 10); return br(r.viewport, c), br(r.content, c), i || s ? (0, v.jsx)(Fr, { "data-state": s ? "visible" : "hidden", ...a, ref: n }) : null })), Wr = (0, t.forwardRef)(((e, n) => { const { forceMount: r, ...i } = e, a = gr(), [s, o] = (0, t.useState)(!1); return (0, t.useEffect)((() => { const { scrollArea: e } = a; let t = 0; if (e) { const n = () => { window.clearTimeout(t), o(!0) }, r = () => { t = window.setTimeout((() => o(!1)), a.scrollHideDelay) }; return e.addEventListener("pointerenter", n), e.addEventListener("pointerleave", r), () => { window.clearTimeout(t), e.removeEventListener("pointerenter", n), e.removeEventListener("pointerleave", r) } } }), [a.scrollArea, a.scrollHideDelay]), r || s ? (0, v.jsx)(zr, { "data-state": s ? "visible" : "hidden", ...i, ref: n }) : null })), Br = (0, t.forwardRef)(((e, n) => { const { forceMount: r, ...i } = e, a = gr(), s = "horizontal" === e.orientation, [o, l] = (0, t.useState)("hidden"), c = kr((() => l("idle")), 100); return (0, t.useEffect)((() => { if ("idle" === o) { const e = window.setTimeout((() => l("hidden")), a.scrollHideDelay); return () => window.clearTimeout(e) } }), [o, a.scrollHideDelay]), (0, t.useEffect)((() => { const { viewport: e } = a, t = s ? "scrollLeft" : "scrollTop"; if (e) { let n = e[t]; const r = () => { const r = e[t]; n !== r && (l("scrolling"), c()), n = r }; return e.addEventListener("scroll", r), () => e.removeEventListener("scroll", r) } }), [a.viewport, s, c]), r || "hidden" !== o ? (0, v.jsx)(Fr, { "data-state": "hidden" === o ? "hidden" : "visible", ...i, ref: n, onPointerEnter: Nr(e.onPointerEnter, (() => l("interacting"))), onPointerLeave: Nr(e.onPointerLeave, (() => l("idle"))) }) : null })), Hr = (0, t.forwardRef)(((e, n) => { const { forceMount: r, ...i } = e, a = gr(), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: o } = a, l = "horizontal" === e.orientation; return (0, t.useEffect)((() => (l ? s(!0) : o(!0), () => { l ? s(!1) : o(!1) })), [l, s, o]), "hover" === a.type ? (0, v.jsx)(Wr, { ...i, ref: n, forceMount: r }) : "scroll" === a.type ? (0, v.jsx)(Br, { ...i, ref: n, forceMount: r }) : "auto" === a.type ? (0, v.jsx)(zr, { ...i, ref: n, forceMount: r }) : "always" === a.type ? (0, v.jsx)(Fr, { ...i, ref: n }) : null })); const Ur = (0, t.forwardRef)(((e, n) => { const { style: r, ...i } = e, a = gr(), s = Ir(), { onThumbPositionChange: o } = s, l = Et(n, (e => s.onThumbChange(e))), c = (0, t.useRef)(), u = kr((() => { c.current && (c.current(), c.current = void 0) }), 100); return (0, t.useEffect)((() => { const { viewport: e } = a; if (e) { const t = () => { if (u(), !c.current) { const t = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : () => { }, n = { left: e.scrollLeft, top: e.scrollTop }, r = 0; return function i() { const a = { left: e.scrollLeft, top: e.scrollTop }, s = n.left !== a.left, o = n.top !== a.top; (s || o) && t(), n = a, r = window.requestAnimationFrame(i) }(), () => window.cancelAnimationFrame(r) }(e, o); c.current = t, o() } }; return o(), e.addEventListener("scroll", t), () => e.removeEventListener("scroll", t) } }), [a.viewport, u, o]), (0, v.jsx)("div", { "data-state": s.hasThumb ? "visible" : "hidden", ...i, ref: l, style: { width: "var(--sa-thumb-width)", height: "var(--sa-thumb-height)", ...r }, onPointerDownCapture: Nr(e.onPointerDownCapture, (e => { const t = e.target.getBoundingClientRect(), n = e.clientX - t.left, r = e.clientY - t.top; s.onThumbPointerDown({ x: n, y: r }) })), onPointerUp: Nr(e.onPointerUp, s.onThumbPointerUp) }) })), Vr = (0, t.forwardRef)(((e, t) => { const { forceMount: n, ...r } = e, i = Ir(); return n || i.hasThumb ? (0, v.jsx)(Ur, { ref: t, ...r }) : null })), qr = (0, t.forwardRef)(((e, t) => { let { children: n, style: r, ...i } = e; const a = gr(), s = Et(t, a.onViewportChange); return (0, v.jsx)(Se, { ...i, ref: s, style: { overflowX: a.scrollbarXEnabled ? "scroll" : "hidden", overflowY: a.scrollbarYEnabled ? "scroll" : "hidden", ...r }, children: (0, v.jsx)("div", { style: { minWidth: "100%", display: "table" }, ref: a.onContentChange, children: n }) }) })); qr.displayName = "@mantine/core/ScrollAreaViewport"; var Gr = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" }; const Xr = { scrollHideDelay: 1e3, type: "hover", scrollbars: "xy" }, Yr = (e, t) => { let { scrollbarSize: n } = t; return { root: { "--scrollarea-scrollbar-size": w(n) } } }, Kr = J(((e, n) => { const r = Q("ScrollArea", Xr, e), { classNames: i, className: a, style: s, styles: o, unstyled: l, scrollbarSize: c, vars: u, type: d, scrollHideDelay: h, viewportProps: f, viewportRef: p, onScrollPositionChange: m, children: g, offsetScrollbars: b, scrollbars: y, ...w } = r, [x, _] = (0, t.useState)(!1), k = rt({ name: "ScrollArea", props: r, classes: Gr, className: a, style: s, classNames: i, styles: o, unstyled: l, vars: u, varsResolver: Yr }); return (0, v.jsxs)(_r, { type: "never" === d ? "always" : d, scrollHideDelay: h, ref: n, scrollbars: y, ...k("root"), ...w, children: [(0, v.jsx)(qr, { ...f, ...k("viewport", { style: null === f || void 0 === f ? void 0 : f.style }), ref: p, "data-offset-scrollbars": !0 === b ? "xy" : b || void 0, "data-scrollbars": y || void 0, onScroll: e => { var t; null === f || void 0 === f || null === (t = f.onScroll) || void 0 === t || t.call(f, e), null === m || void 0 === m || m({ x: e.currentTarget.scrollLeft, y: e.currentTarget.scrollTop }) }, children: g }), ("xy" === y || "x" === y) && (0, v.jsx)(Hr, { ...k("scrollbar"), orientation: "horizontal", "data-hidden": "never" === d || void 0, forceMount: !0, onMouseEnter: () => _(!0), onMouseLeave: () => _(!1), children: (0, v.jsx)(Vr, { ...k("thumb") }) }), ("xy" === y || "y" === y) && (0, v.jsx)(Hr, { ...k("scrollbar"), orientation: "vertical", "data-hidden": "never" === d || void 0, forceMount: !0, onMouseEnter: () => _(!0), onMouseLeave: () => _(!1), children: (0, v.jsx)(Vr, { ...k("thumb") }) }), (0, v.jsx)(wr, { ...k("corner"), "data-hovered": x || void 0, "data-hidden": "never" === d || void 0 })] }) })); Kr.displayName = "@mantine/core/ScrollArea"; const Qr = J(((e, t) => { const { children: n, classNames: r, styles: i, scrollbarSize: a, scrollHideDelay: s, type: o, dir: l, offsetScrollbars: c, viewportRef: u, onScrollPositionChange: d, unstyled: h, variant: f, viewportProps: p, scrollbars: m, style: g, vars: b, ...y } = Q("ScrollAreaAutosize", Xr, e); return (0, v.jsx)(Se, { ...y, ref: t, style: [{ display: "flex", overflow: "auto" }, g], children: (0, v.jsx)(Se, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: (0, v.jsx)(Kr, { classNames: r, styles: i, scrollHideDelay: s, scrollbarSize: a, type: o, dir: l, offsetScrollbars: c, viewportRef: u, onScrollPositionChange: d, unstyled: h, variant: f, viewportProps: p, vars: b, scrollbars: m, children: n }) }) }) })); function $r(e, t) { if ("rtl" === e && (t.includes("right") || t.includes("left"))) { const [e, n] = t.split("-"), r = "right" === e ? "left" : "right"; return void 0 === n ? r : "".concat(r, "-").concat(n) } return t } function Jr(e, t, n, r) { return "center" === e || "center" === r ? { top: t } : "end" === e ? { bottom: n } : "start" === e ? { top: n } : {} } function Zr(e, t, n, r, i) { return "center" === e || "center" === r ? { left: t } : "end" === e ? { ["ltr" === i ? "right" : "left"]: n } : "start" === e ? { ["ltr" === i ? "left" : "right"]: n } : {} } Kr.classes = Gr, Qr.displayName = "@mantine/core/ScrollAreaAutosize", Qr.classes = Gr, Kr.Autosize = Qr; const ei = { bottom: "borderTopLeftRadius", left: "borderTopRightRadius", right: "borderBottomLeftRadius", top: "borderBottomRightRadius" }; function ti(e) { let { position: t, arrowSize: n, arrowOffset: r, arrowRadius: i, arrowPosition: a, arrowX: s, arrowY: o, dir: l } = e; const [c, u = "center"] = t.split("-"), d = { width: n, height: n, transform: "rotate(45deg)", position: "absolute", [ei[c]]: i }, h = -n / 2; return "left" === c ? { ...d, ...Jr(u, o, r, a), right: h, borderLeftColor: "transparent", borderBottomColor: "transparent" } : "right" === c ? { ...d, ...Jr(u, o, r, a), left: h, borderRightColor: "transparent", borderTopColor: "transparent" } : "top" === c ? { ...d, ...Zr(u, s, r, a, l), bottom: h, borderTopColor: "transparent", borderLeftColor: "transparent" } : "bottom" === c ? { ...d, ...Zr(u, s, r, a, l), top: h, borderBottomColor: "transparent", borderRightColor: "transparent" } : {} } const ni = (0, t.forwardRef)(((e, t) => { let { position: n, arrowSize: r, arrowOffset: i, arrowRadius: a, arrowPosition: s, visible: o, arrowX: l, arrowY: c, style: u, ...d } = e; const { dir: h } = Ar(); return o ? (0, v.jsx)("div", { ...d, ref: t, style: { ...u, ...ti({ position: n, arrowSize: r, arrowOffset: i, arrowRadius: a, arrowPosition: s, dir: h, arrowX: l, arrowY: c }) } }) : null })); ni.displayName = "@mantine/core/FloatingArrow"; const ri = { duration: 100, transition: "fade" }; function ii(e, t) { return Array.isArray(e) ? [...e].reduce(((e, n) => ({ ...e, ...ii(n, t) })), {}) : "function" === typeof e ? e(t) : null == e ? {} : e } function ai(e) { return li(e) ? (e.nodeName || "").toLowerCase() : "#document" } function si(e) { var t; return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window } function oi(e) { var t; return null == (t = (li(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement } function li(e) { return e instanceof Node || e instanceof si(e).Node } function ci(e) { return e instanceof Element || e instanceof si(e).Element } function ui(e) { return e instanceof HTMLElement || e instanceof si(e).HTMLElement } function di(e) { return "undefined" !== typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof si(e).ShadowRoot) } function hi(e) { const { overflow: t, overflowX: n, overflowY: r, display: i } = bi(e); return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i) } function fi(e) { return ["table", "td", "th"].includes(ai(e)) } function pi(e) { return [":popover-open", ":modal"].some((t => { try { return e.matches(t) } catch ($A) { return !1 } })) } function mi(e) { const t = gi(), n = ci(e) ? bi(e) : e; return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some((e => (n.willChange || "").includes(e))) || ["paint", "layout", "strict", "content"].some((e => (n.contain || "").includes(e))) } function gi() { return !("undefined" === typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none") } function vi(e) { return ["html", "body", "#document"].includes(ai(e)) } function bi(e) { return si(e).getComputedStyle(e) } function yi(e) { return ci(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function wi(e) { if ("html" === ai(e)) return e; const t = e.assignedSlot || e.parentNode || di(e) && e.host || oi(e); return di(t) ? t.host : t } function xi(e) { const t = wi(e); return vi(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ui(t) && hi(t) ? t : xi(t) } function _i(e, t, n) { var r; void 0 === t && (t = []), void 0 === n && (n = !0); const i = xi(e), a = i === (null == (r = e.ownerDocument) ? void 0 : r.body), s = si(i); return a ? t.concat(s, s.visualViewport || [], hi(i) ? i : [], s.frameElement && n ? _i(s.frameElement) : []) : t.concat(i, _i(i, [], n)) } function ki(e) { let t = e.activeElement; for (; null != (null == (n = t) || null == (n = n.shadowRoot) ? void 0 : n.activeElement);) { var n; t = t.shadowRoot.activeElement } return t } function Si(e, t) { if (!e || !t) return !1; const n = null == t.getRootNode ? void 0 : t.getRootNode(); if (e.contains(t)) return !0; if (n && di(n)) { let n = t; for (; n;) { if (e === n) return !0; n = n.parentNode || n.host } } return !1 } function Ai() { const e = navigator.userAgentData; return null != e && e.platform ? e.platform : navigator.platform } function Ei() { const e = navigator.userAgentData; return e && Array.isArray(e.brands) ? e.brands.map((e => { let { brand: t, version: n } = e; return t + "/" + n })).join(" ") : navigator.userAgent } function Ci(e) { return !Ei().includes("jsdom/") && (!Mi() && 0 === e.width && 0 === e.height || Mi() && 1 === e.width && 1 === e.height && 0 === e.pressure && 0 === e.detail && "mouse" === e.pointerType || e.width < 1 && e.height < 1 && 0 === e.pressure && 0 === e.detail && "touch" === e.pointerType) } function Mi() { const e = /android/i; return e.test(Ai()) || e.test(Ei()) } function Ti(e, t) { const n = ["mouse", "pen"]; return t || n.push("", void 0), n.includes(e) } function Pi(e) { return (null == e ? void 0 : e.ownerDocument) || document } function Ri(e, t) { if (null == t) return !1; if ("composedPath" in e) return e.composedPath().includes(t); const n = e; return null != n.target && t.contains(n.target) } function Ni(e) { return "composedPath" in e ? e.composedPath()[0] : e.target } const Li = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])"; function Ii(e) { return ui(e) && e.matches(Li) } const Di = Math.min, Oi = Math.max, ji = Math.round, Fi = Math.floor, zi = e => ({ x: e, y: e }), Wi = { left: "right", right: "left", bottom: "top", top: "bottom" }, Bi = { start: "end", end: "start" }; function Hi(e, t, n) { return Oi(e, Di(t, n)) } function Ui(e, t) { return "function" === typeof e ? e(t) : e } function Vi(e) { return e.split("-")[0] } function qi(e) { return e.split("-")[1] } function Gi(e) { return "x" === e ? "y" : "x" } function Xi(e) { return "y" === e ? "height" : "width" } function Yi(e) { return ["top", "bottom"].includes(Vi(e)) ? "y" : "x" } function Ki(e) { return Gi(Yi(e)) } function Qi(e) { return e.replace(/start|end/g, (e => Bi[e])) } function $i(e) { return e.replace(/left|right|bottom|top/g, (e => Wi[e])) } function Ji(e) { return "number" !== typeof e ? function (e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } }(e) : { top: e, right: e, bottom: e, left: e } } function Zi(e) { const { x: t, y: n, width: r, height: i } = e; return { width: r, height: i, top: n, left: t, right: t + r, bottom: n + i, x: t, y: n } } function ea(e, t, n) { let { reference: r, floating: i } = e; const a = Yi(t), s = Ki(t), o = Xi(s), l = Vi(t), c = "y" === a, u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, h = r[o] / 2 - i[o] / 2; let f; switch (l) { case "top": f = { x: u, y: r.y - i.height }; break; case "bottom": f = { x: u, y: r.y + r.height }; break; case "right": f = { x: r.x + r.width, y: d }; break; case "left": f = { x: r.x - i.width, y: d }; break; default: f = { x: r.x, y: r.y } }switch (qi(t)) { case "start": f[s] -= h * (n && c ? -1 : 1); break; case "end": f[s] += h * (n && c ? -1 : 1) }return f } async function ta(e, t) { var n; void 0 === t && (t = {}); const { x: r, y: i, platform: a, rects: s, elements: o, strategy: l } = e, { boundary: c = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: h = !1, padding: f = 0 } = Ui(t, e), p = Ji(f), m = o[h ? "floating" === d ? "reference" : "floating" : d], g = Zi(await a.getClippingRect({ element: null == (n = await (null == a.isElement ? void 0 : a.isElement(m))) || n ? m : m.contextElement || await (null == a.getDocumentElement ? void 0 : a.getDocumentElement(o.floating)), boundary: c, rootBoundary: u, strategy: l })), v = "floating" === d ? { x: r, y: i, width: s.floating.width, height: s.floating.height } : s.reference, b = await (null == a.getOffsetParent ? void 0 : a.getOffsetParent(o.floating)), y = await (null == a.isElement ? void 0 : a.isElement(b)) && await (null == a.getScale ? void 0 : a.getScale(b)) || { x: 1, y: 1 }, w = Zi(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: o, rect: v, offsetParent: b, strategy: l }) : v); return { top: (g.top - w.top + p.top) / y.y, bottom: (w.bottom - g.bottom + p.bottom) / y.y, left: (g.left - w.left + p.left) / y.x, right: (w.right - g.right + p.right) / y.x } } function na(e) { const t = Di(...e.map((e => e.left))), n = Di(...e.map((e => e.top))); return { x: t, y: n, width: Oi(...e.map((e => e.right))) - t, height: Oi(...e.map((e => e.bottom))) - n } } function ra(e) { const t = bi(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const i = ui(e), a = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, o = ji(n) !== a || ji(r) !== s; return o && (n = a, r = s), { width: n, height: r, $: o } } function ia(e) { return ci(e) ? e : e.contextElement } function aa(e) { const t = ia(e); if (!ui(t)) return zi(1); const n = t.getBoundingClientRect(), { width: r, height: i, $: a } = ra(t); let s = (a ? ji(n.width) : n.width) / r, o = (a ? ji(n.height) : n.height) / i; return s && Number.isFinite(s) || (s = 1), o && Number.isFinite(o) || (o = 1), { x: s, y: o } } const sa = zi(0); function oa(e) { const t = si(e); return gi() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : sa } function la(e, t, n, r) { void 0 === t && (t = !1), void 0 === n && (n = !1); const i = e.getBoundingClientRect(), a = ia(e); let s = zi(1); t && (r ? ci(r) && (s = aa(r)) : s = aa(e)); const o = function (e, t, n) { return void 0 === t && (t = !1), !(!n || t && n !== si(e)) && t }(a, n, r) ? oa(a) : zi(0); let l = (i.left + o.x) / s.x, c = (i.top + o.y) / s.y, u = i.width / s.x, d = i.height / s.y; if (a) { const e = si(a), t = r && ci(r) ? si(r) : r; let n = e, i = n.frameElement; for (; i && r && t !== n;) { const e = aa(i), t = i.getBoundingClientRect(), r = bi(i), a = t.left + (i.clientLeft + parseFloat(r.paddingLeft)) * e.x, s = t.top + (i.clientTop + parseFloat(r.paddingTop)) * e.y; l *= e.x, c *= e.y, u *= e.x, d *= e.y, l += a, c += s, n = si(i), i = n.frameElement } } return Zi({ width: u, height: d, x: l, y: c }) } function ca(e) { return la(oi(e)).left + yi(e).scrollLeft } function ua(e, t, n) { let r; if ("viewport" === t) r = function (e, t) { const n = si(e), r = oi(e), i = n.visualViewport; let a = r.clientWidth, s = r.clientHeight, o = 0, l = 0; if (i) { a = i.width, s = i.height; const e = gi(); (!e || e && "fixed" === t) && (o = i.offsetLeft, l = i.offsetTop) } return { width: a, height: s, x: o, y: l } }(e, n); else if ("document" === t) r = function (e) { const t = oi(e), n = yi(e), r = e.ownerDocument.body, i = Oi(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Oi(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let s = -n.scrollLeft + ca(e); const o = -n.scrollTop; return "rtl" === bi(r).direction && (s += Oi(t.clientWidth, r.clientWidth) - i), { width: i, height: a, x: s, y: o } }(oi(e)); else if (ci(t)) r = function (e, t) { const n = la(e, !0, "fixed" === t), r = n.top + e.clientTop, i = n.left + e.clientLeft, a = ui(e) ? aa(e) : zi(1); return { width: e.clientWidth * a.x, height: e.clientHeight * a.y, x: i * a.x, y: r * a.y } }(t, n); else { const n = oa(e); r = { ...t, x: t.x - n.x, y: t.y - n.y } } return Zi(r) } function da(e, t) { const n = wi(e); return !(n === t || !ci(n) || vi(n)) && ("fixed" === bi(n).position || da(n, t)) } function ha(e, t, n) { const r = ui(t), i = oi(t), a = "fixed" === n, s = la(e, !0, a, t); let o = { scrollLeft: 0, scrollTop: 0 }; const l = zi(0); if (r || !r && !a) if (("body" !== ai(t) || hi(i)) && (o = yi(t)), r) { const e = la(t, !0, a, t); l.x = e.x + t.clientLeft, l.y = e.y + t.clientTop } else i && (l.x = ca(i)); return { x: s.left + o.scrollLeft - l.x, y: s.top + o.scrollTop - l.y, width: s.width, height: s.height } } function fa(e) { return "static" === bi(e).position } function pa(e, t) { return ui(e) && "fixed" !== bi(e).position ? t ? t(e) : e.offsetParent : null } function ma(e, t) { const n = si(e); if (pi(e)) return n; if (!ui(e)) { let t = wi(e); for (; t && !vi(t);) { if (ci(t) && !fa(t)) return t; t = wi(t) } return n } let r = pa(e, t); for (; r && fi(r) && fa(r);)r = pa(r, t); return r && vi(r) && fa(r) && !mi(r) ? n : r || function (e) { let t = wi(e); for (; ui(t) && !vi(t);) { if (mi(t)) return t; if (pi(t)) return null; t = wi(t) } return null }(e) || n } const ga = { convertOffsetParentRelativeRectToViewportRelativeRect: function (e) { let { elements: t, rect: n, offsetParent: r, strategy: i } = e; const a = "fixed" === i, s = oi(r), o = !!t && pi(t.floating); if (r === s || o && a) return n; let l = { scrollLeft: 0, scrollTop: 0 }, c = zi(1); const u = zi(0), d = ui(r); if ((d || !d && !a) && (("body" !== ai(r) || hi(s)) && (l = yi(r)), ui(r))) { const e = la(r); c = aa(r), u.x = e.x + r.clientLeft, u.y = e.y + r.clientTop } return { width: n.width * c.x, height: n.height * c.y, x: n.x * c.x - l.scrollLeft * c.x + u.x, y: n.y * c.y - l.scrollTop * c.y + u.y } }, getDocumentElement: oi, getClippingRect: function (e) { let { element: t, boundary: n, rootBoundary: r, strategy: i } = e; const a = [..."clippingAncestors" === n ? pi(t) ? [] : function (e, t) { const n = t.get(e); if (n) return n; let r = _i(e, [], !1).filter((e => ci(e) && "body" !== ai(e))), i = null; const a = "fixed" === bi(e).position; let s = a ? wi(e) : e; for (; ci(s) && !vi(s);) { const t = bi(s), n = mi(s); n || "fixed" !== t.position || (i = null), (a ? !n && !i : !n && "static" === t.position && i && ["absolute", "fixed"].includes(i.position) || hi(s) && !n && da(e, s)) ? r = r.filter((e => e !== s)) : i = t, s = wi(s) } return t.set(e, r), r }(t, this._c) : [].concat(n), r], s = a[0], o = a.reduce(((e, n) => { const r = ua(t, n, i); return e.top = Oi(r.top, e.top), e.right = Di(r.right, e.right), e.bottom = Di(r.bottom, e.bottom), e.left = Oi(r.left, e.left), e }), ua(t, s, i)); return { width: o.right - o.left, height: o.bottom - o.top, x: o.left, y: o.top } }, getOffsetParent: ma, getElementRects: async function (e) { const t = this.getOffsetParent || ma, n = this.getDimensions, r = await n(e.floating); return { reference: ha(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }, getClientRects: function (e) { return Array.from(e.getClientRects()) }, getDimensions: function (e) { const { width: t, height: n } = ra(e); return { width: t, height: n } }, getScale: aa, isElement: ci, isRTL: function (e) { return "rtl" === bi(e).direction } }; function va(e, t, n, r) { void 0 === r && (r = {}); const { ancestorScroll: i = !0, ancestorResize: a = !0, elementResize: s = "function" === typeof ResizeObserver, layoutShift: o = "function" === typeof IntersectionObserver, animationFrame: l = !1 } = r, c = ia(e), u = i || a ? [...c ? _i(c) : [], ..._i(t)] : []; u.forEach((e => { i && e.addEventListener("scroll", n, { passive: !0 }), a && e.addEventListener("resize", n) })); const d = c && o ? function (e, t) { let n, r = null; const i = oi(e); function a() { var e; clearTimeout(n), null == (e = r) || e.disconnect(), r = null } return function s(o, l) { void 0 === o && (o = !1), void 0 === l && (l = 1), a(); const { left: c, top: u, width: d, height: h } = e.getBoundingClientRect(); if (o || t(), !d || !h) return; const f = { rootMargin: -Fi(u) + "px " + -Fi(i.clientWidth - (c + d)) + "px " + -Fi(i.clientHeight - (u + h)) + "px " + -Fi(c) + "px", threshold: Oi(0, Di(1, l)) || 1 }; let p = !0; function m(e) { const t = e[0].intersectionRatio; if (t !== l) { if (!p) return s(); t ? s(!1, t) : n = setTimeout((() => { s(!1, 1e-7) }), 1e3) } p = !1 } try { r = new IntersectionObserver(m, { ...f, root: i.ownerDocument }) } catch ($A) { r = new IntersectionObserver(m, f) } r.observe(e) }(!0), a }(c, n) : null; let h, f = -1, p = null; s && (p = new ResizeObserver((e => { let [r] = e; r && r.target === c && p && (p.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame((() => { var e; null == (e = p) || e.observe(t) }))), n() })), c && !l && p.observe(c), p.observe(t)); let m = l ? la(e) : null; return l && function t() { const r = la(e); !m || r.x === m.x && r.y === m.y && r.width === m.width && r.height === m.height || n(); m = r, h = requestAnimationFrame(t) }(), n(), () => { var e; u.forEach((e => { i && e.removeEventListener("scroll", n), a && e.removeEventListener("resize", n) })), null == d || d(), null == (e = p) || e.disconnect(), p = null, l && cancelAnimationFrame(h) } } const ba = function (e) { return void 0 === e && (e = 0), { name: "offset", options: e, async fn(t) { var n, r; const { x: i, y: a, placement: s, middlewareData: o } = t, l = await async function (e, t) { const { placement: n, platform: r, elements: i } = e, a = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)), s = Vi(n), o = qi(n), l = "y" === Yi(n), c = ["left", "top"].includes(s) ? -1 : 1, u = a && l ? -1 : 1, d = Ui(t, e); let { mainAxis: h, crossAxis: f, alignmentAxis: p } = "number" === typeof d ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d }; return o && "number" === typeof p && (f = "end" === o ? -1 * p : p), l ? { x: f * u, y: h * c } : { x: h * c, y: f * u } }(t, e); return s === (null == (n = o.offset) ? void 0 : n.placement) && null != (r = o.arrow) && r.alignmentOffset ? {} : { x: i + l.x, y: a + l.y, data: { ...l, placement: s } } } } }, ya = function (e) { return void 0 === e && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: i } = t, { mainAxis: a = !0, crossAxis: s = !1, limiter: o = { fn: e => { let { x: t, y: n } = e; return { x: t, y: n } } }, ...l } = Ui(e, t), c = { x: n, y: r }, u = await ta(t, l), d = Yi(Vi(i)), h = Gi(d); let f = c[h], p = c[d]; if (a) { const e = "y" === h ? "bottom" : "right"; f = Hi(f + u["y" === h ? "top" : "left"], f, f - u[e]) } if (s) { const e = "y" === d ? "bottom" : "right"; p = Hi(p + u["y" === d ? "top" : "left"], p, p - u[e]) } const m = o.fn({ ...t, [h]: f, [d]: p }); return { ...m, data: { x: m.x - n, y: m.y - r } } } } }, wa = function (e) { return void 0 === e && (e = {}), { name: "flip", options: e, async fn(t) { var n, r; const { placement: i, middlewareData: a, rects: s, initialPlacement: o, platform: l, elements: c } = t, { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: h, fallbackStrategy: f = "bestFit", fallbackAxisSideDirection: p = "none", flipAlignment: m = !0, ...g } = Ui(e, t); if (null != (n = a.arrow) && n.alignmentOffset) return {}; const v = Vi(i), b = Yi(o), y = Vi(o) === o, w = await (null == l.isRTL ? void 0 : l.isRTL(c.floating)), x = h || (y || !m ? [$i(o)] : function (e) { const t = $i(e); return [Qi(e), t, Qi(t)] }(o)), _ = "none" !== p; !h && _ && x.push(...function (e, t, n, r) { const i = qi(e); let a = function (e, t, n) { const r = ["left", "right"], i = ["right", "left"], a = ["top", "bottom"], s = ["bottom", "top"]; switch (e) { case "top": case "bottom": return n ? t ? i : r : t ? r : i; case "left": case "right": return t ? a : s; default: return [] } }(Vi(e), "start" === n, r); return i && (a = a.map((e => e + "-" + i)), t && (a = a.concat(a.map(Qi)))), a }(o, m, p, w)); const k = [o, ...x], S = await ta(t, g), A = []; let E = (null == (r = a.flip) ? void 0 : r.overflows) || []; if (u && A.push(S[v]), d) { const e = function (e, t, n) { void 0 === n && (n = !1); const r = qi(e), i = Ki(e), a = Xi(i); let s = "x" === i ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top"; return t.reference[a] > t.floating[a] && (s = $i(s)), [s, $i(s)] }(i, s, w); A.push(S[e[0]], S[e[1]]) } if (E = [...E, { placement: i, overflows: A }], !A.every((e => e <= 0))) { var C, M; const e = ((null == (C = a.flip) ? void 0 : C.index) || 0) + 1, t = k[e]; if (t) return { data: { index: e, overflows: E }, reset: { placement: t } }; let n = null == (M = E.filter((e => e.overflows[0] <= 0)).sort(((e, t) => e.overflows[1] - t.overflows[1]))[0]) ? void 0 : M.placement; if (!n) switch (f) { case "bestFit": { var T; const e = null == (T = E.filter((e => { if (_) { const t = Yi(e.placement); return t === b || "y" === t } return !0 })).map((e => [e.placement, e.overflows.filter((e => e > 0)).reduce(((e, t) => e + t), 0)])).sort(((e, t) => e[1] - t[1]))[0]) ? void 0 : T[0]; e && (n = e); break } case "initialPlacement": n = o }if (i !== n) return { reset: { placement: n } } } return {} } } }, xa = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: r, placement: i, rects: a, platform: s, elements: o, middlewareData: l } = t, { element: c, padding: u = 0 } = Ui(e, t) || {}; if (null == c) return {}; const d = Ji(u), h = { x: n, y: r }, f = Ki(i), p = Xi(f), m = await s.getDimensions(c), g = "y" === f, v = g ? "top" : "left", b = g ? "bottom" : "right", y = g ? "clientHeight" : "clientWidth", w = a.reference[p] + a.reference[f] - h[f] - a.floating[p], x = h[f] - a.reference[f], _ = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(c)); let k = _ ? _[y] : 0; k && await (null == s.isElement ? void 0 : s.isElement(_)) || (k = o.floating[y] || a.floating[p]); const S = w / 2 - x / 2, A = k / 2 - m[p] / 2 - 1, E = Di(d[v], A), C = Di(d[b], A), M = E, T = k - m[p] - C, P = k / 2 - m[p] / 2 + S, R = Hi(M, P, T), N = !l.arrow && null != qi(i) && P !== R && a.reference[p] / 2 - (P < M ? E : C) - m[p] / 2 < 0, L = N ? P < M ? P - M : P - T : 0; return { [f]: h[f] + L, data: { [f]: R, centerOffset: P - R - L, ...N && { alignmentOffset: L } }, reset: N } } }), _a = function (e) { return void 0 === e && (e = {}), { name: "inline", options: e, async fn(t) { const { placement: n, elements: r, rects: i, platform: a, strategy: s } = t, { padding: o = 2, x: l, y: c } = Ui(e, t), u = Array.from(await (null == a.getClientRects ? void 0 : a.getClientRects(r.reference)) || []), d = function (e) { const t = e.slice().sort(((e, t) => e.y - t.y)), n = []; let r = null; for (let i = 0; i < t.length; i++) { const e = t[i]; !r || e.y - r.y > r.height / 2 ? n.push([e]) : n[n.length - 1].push(e), r = e } return n.map((e => Zi(na(e)))) }(u), h = Zi(na(u)), f = Ji(o); const p = await a.getElementRects({ reference: { getBoundingClientRect: function () { if (2 === d.length && d[0].left > d[1].right && null != l && null != c) return d.find((e => l > e.left - f.left && l < e.right + f.right && c > e.top - f.top && c < e.bottom + f.bottom)) || h; if (d.length >= 2) { if ("y" === Yi(n)) { const e = d[0], t = d[d.length - 1], r = "top" === Vi(n), i = e.top, a = t.bottom, s = r ? e.left : t.left, o = r ? e.right : t.right; return { top: i, bottom: a, left: s, right: o, width: o - s, height: a - i, x: s, y: i } } const e = "left" === Vi(n), t = Oi(...d.map((e => e.right))), r = Di(...d.map((e => e.left))), i = d.filter((n => e ? n.left === r : n.right === t)), a = i[0].top, s = i[i.length - 1].bottom; return { top: a, bottom: s, left: r, right: t, width: t - r, height: s - a, x: r, y: a } } return h } }, floating: r.floating, strategy: s }); return i.reference.x !== p.reference.x || i.reference.y !== p.reference.y || i.reference.width !== p.reference.width || i.reference.height !== p.reference.height ? { reset: { rects: p } } : {} } } }, ka = (e, t, n) => { const r = new Map, i = { platform: ga, ...n }, a = { ...i.platform, _c: r }; return (async (e, t, n) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: a = [], platform: s } = n, o = a.filter(Boolean), l = await (null == s.isRTL ? void 0 : s.isRTL(t)); let c = await s.getElementRects({ reference: e, floating: t, strategy: i }), { x: u, y: d } = ea(c, r, l), h = r, f = {}, p = 0; for (let m = 0; m < o.length; m++) { const { name: n, fn: a } = o[m], { x: g, y: v, data: b, reset: y } = await a({ x: u, y: d, initialPlacement: r, placement: h, strategy: i, middlewareData: f, rects: c, platform: s, elements: { reference: e, floating: t } }); u = null != g ? g : u, d = null != v ? v : d, f = { ...f, [n]: { ...f[n], ...b } }, y && p <= 50 && (p++, "object" === typeof y && (y.placement && (h = y.placement), y.rects && (c = !0 === y.rects ? await s.getElementRects({ reference: e, floating: t, strategy: i }) : y.rects), ({ x: u, y: d } = ea(c, h, l))), m = -1) } return { x: u, y: d, placement: h, strategy: i, middlewareData: f } })(e, t, { ...i, platform: a }) }; var Sa = "undefined" !== typeof document ? t.useLayoutEffect : t.useEffect; function Aa(e, t) { if (e === t) return !0; if (typeof e !== typeof t) return !1; if ("function" === typeof e && e.toString() === t.toString()) return !0; let n, r, i; if (e && t && "object" === typeof e) { if (Array.isArray(e)) { if (n = e.length, n !== t.length) return !1; for (r = n; 0 !== r--;)if (!Aa(e[r], t[r])) return !1; return !0 } if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length) return !1; for (r = n; 0 !== r--;)if (!{}.hasOwnProperty.call(t, i[r])) return !1; for (r = n; 0 !== r--;) { const n = i[r]; if (("_owner" !== n || !e.$$typeof) && !Aa(e[n], t[n])) return !1 } return !0 } return e !== e && t !== t } function Ea(e) { if ("undefined" === typeof window) return 1; return (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function Ca(e, t) { const n = Ea(e); return Math.round(t * n) / n } function Ma(e) { const n = t.useRef(e); return Sa((() => { n.current = e })), n } const Ta = e => ({ name: "arrow", options: e, fn(t) { const { element: n, padding: r } = "function" === typeof e ? e(t) : e; return n && (i = n, {}.hasOwnProperty.call(i, "current")) ? null != n.current ? xa({ element: n.current, padding: r }).fn(t) : {} : n ? xa({ element: n, padding: r }).fn(t) : {}; var i } }), Pa = (e, t) => ({ ...ba(e), options: [e, t] }), Ra = (e, t) => ({ ...ya(e), options: [e, t] }), Na = (e, t) => ({ ...wa(e), options: [e, t] }), La = (e, t) => ({ ..._a(e), options: [e, t] }), Ia = (e, t) => ({ ...Ta(e), options: [e, t] }); const Da = { ...n }, Oa = Da.useInsertionEffect || (e => e()); function ja(e) { const n = t.useRef((() => { 0 })); return Oa((() => { n.current = e })), t.useCallback((function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return null == n.current ? void 0 : n.current(...t) }), []) } const Fa = "ArrowUp", za = "ArrowDown", Wa = "ArrowLeft", Ba = "ArrowRight"; var Ha = "undefined" !== typeof document ? t.useLayoutEffect : t.useEffect; const Ua = [Wa, Ba], Va = [Fa, za]; let qa = !1, Ga = 0; const Xa = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + Ga++; const Ya = Da.useId || function () { const [e, n] = t.useState((() => qa ? Xa() : void 0)); return Ha((() => { null == e && n(Xa()) }), []), t.useEffect((() => { qa = !0 }), []), e }; function Ka() { const e = new Map; return { emit(t, n) { var r; null == (r = e.get(t)) || r.forEach((e => e(n))) }, on(t, n) { e.set(t, [...e.get(t) || [], n]) }, off(t, n) { var r; e.set(t, (null == (r = e.get(t)) ? void 0 : r.filter((e => e !== n))) || []) } } } const Qa = t.createContext(null), $a = t.createContext(null), Ja = () => { var e; return (null == (e = t.useContext(Qa)) ? void 0 : e.id) || null }, Za = () => t.useContext($a); function es(e) { return "data-floating-ui-" + e } function ts(e) { const n = (0, t.useRef)(e); return Ha((() => { n.current = e })), n } const ns = es("safe-polygon"); function rs(e, t, n) { return n && !Ti(n) ? 0 : "number" === typeof e ? e : null == e ? void 0 : e[t] } function is(e, n) { void 0 === n && (n = {}); const { open: r, onOpenChange: i, dataRef: a, events: s, elements: o } = e, { enabled: l = !0, delay: c = 0, handleClose: u = null, mouseOnly: d = !1, restMs: h = 0, move: f = !0 } = n, p = Za(), m = Ja(), g = ts(u), v = ts(c), b = ts(r), y = t.useRef(), w = t.useRef(-1), x = t.useRef(), _ = t.useRef(-1), k = t.useRef(!0), S = t.useRef(!1), A = t.useRef((() => { })), E = t.useCallback((() => { var e; const t = null == (e = a.current.openEvent) ? void 0 : e.type; return (null == t ? void 0 : t.includes("mouse")) && "mousedown" !== t }), [a]); t.useEffect((() => { if (l) return s.on("openchange", e), () => { s.off("openchange", e) }; function e(e) { let { open: t } = e; t || (clearTimeout(w.current), clearTimeout(_.current), k.current = !0) } }), [l, s]), t.useEffect((() => { if (!l) return; if (!g.current) return; if (!r) return; function e(e) { E() && i(!1, e, "hover") } const t = Pi(o.floating).documentElement; return t.addEventListener("mouseleave", e), () => { t.removeEventListener("mouseleave", e) } }), [o.floating, r, i, l, g, E]); const C = t.useCallback((function (e, t, n) { void 0 === t && (t = !0), void 0 === n && (n = "hover"); const r = rs(v.current, "close", y.current); r && !x.current ? (clearTimeout(w.current), w.current = window.setTimeout((() => i(!1, e, n)), r)) : t && (clearTimeout(w.current), i(!1, e, n)) }), [v, i]), M = ja((() => { A.current(), x.current = void 0 })), T = ja((() => { if (S.current) { const e = Pi(o.floating).body; e.style.pointerEvents = "", e.removeAttribute(ns), S.current = !1 } })); t.useEffect((() => { if (l && ci(o.domReference)) { var e; const t = o.domReference; return r && t.addEventListener("mouseleave", c), null == (e = o.floating) || e.addEventListener("mouseleave", c), f && t.addEventListener("mousemove", n, { once: !0 }), t.addEventListener("mouseenter", n), t.addEventListener("mouseleave", s), () => { var e; r && t.removeEventListener("mouseleave", c), null == (e = o.floating) || e.removeEventListener("mouseleave", c), f && t.removeEventListener("mousemove", n), t.removeEventListener("mouseenter", n), t.removeEventListener("mouseleave", s) } } function t() { return !!a.current.openEvent && ["click", "mousedown"].includes(a.current.openEvent.type) } function n(e) { if (clearTimeout(w.current), k.current = !1, d && !Ti(y.current) || h > 0 && !rs(v.current, "open")) return; const t = rs(v.current, "open", y.current); t ? w.current = window.setTimeout((() => { b.current || i(!0, e, "hover") }), t) : i(!0, e, "hover") } function s(e) { if (t()) return; A.current(); const n = Pi(o.floating); if (clearTimeout(_.current), g.current && a.current.floatingContext) { r || clearTimeout(w.current), x.current = g.current({ ...a.current.floatingContext, tree: p, x: e.clientX, y: e.clientY, onClose() { T(), M(), C(e, !0, "safe-polygon") } }); const t = x.current; return n.addEventListener("mousemove", t), void (A.current = () => { n.removeEventListener("mousemove", t) }) } ("touch" !== y.current || !Si(o.floating, e.relatedTarget)) && C(e) } function c(e) { t() || a.current.floatingContext && (null == g.current || g.current({ ...a.current.floatingContext, tree: p, x: e.clientX, y: e.clientY, onClose() { T(), M(), C(e) } })(e)) } }), [o, l, e, d, h, f, C, M, T, i, r, b, p, v, g, a]), Ha((() => { var e; if (l && r && null != (e = g.current) && e.__options.blockPointerEvents && E()) { const e = Pi(o.floating).body; e.setAttribute(ns, ""), e.style.pointerEvents = "none", S.current = !0; const n = o.floating; if (ci(o.domReference) && n) { var t; const e = o.domReference, r = null == p || null == (t = p.nodesRef.current.find((e => e.id === m))) || null == (t = t.context) ? void 0 : t.elements.floating; return r && (r.style.pointerEvents = ""), e.style.pointerEvents = "auto", n.style.pointerEvents = "auto", () => { e.style.pointerEvents = "", n.style.pointerEvents = "" } } } }), [l, r, m, o, p, g, E]), Ha((() => { r || (y.current = void 0, M(), T()) }), [r, M, T]), t.useEffect((() => () => { M(), clearTimeout(w.current), clearTimeout(_.current), T() }), [l, o.domReference, M, T]); const P = t.useMemo((() => { function e(e) { y.current = e.pointerType } return { onPointerDown: e, onPointerEnter: e, onMouseMove(e) { const { nativeEvent: t } = e; function n() { k.current || b.current || i(!0, t, "hover") } d && !Ti(y.current) || r || 0 === h || (clearTimeout(_.current), "touch" === y.current ? n() : _.current = window.setTimeout(n, h)) } } }), [d, i, r, b, h]), R = t.useMemo((() => ({ onMouseEnter() { clearTimeout(w.current) }, onMouseLeave(e) { C(e.nativeEvent, !1) } })), [C]); return t.useMemo((() => l ? { reference: P, floating: R } : {}), [l, P, R]) } const as = () => { }, ss = t.createContext({ delay: 0, initialDelay: 0, timeoutMs: 0, currentId: null, setCurrentId: as, setState: as, isInstantPhase: !1 }), os = () => t.useContext(ss); function ls(e) { const { children: n, delay: r, timeoutMs: i = 0 } = e, [a, s] = t.useReducer(((e, t) => ({ ...e, ...t })), { delay: r, timeoutMs: i, initialDelay: r, currentId: null, isInstantPhase: !1 }), o = t.useRef(null), l = t.useCallback((e => { s({ currentId: e }) }), []); return Ha((() => { a.currentId ? null === o.current ? o.current = a.currentId : a.isInstantPhase || s({ isInstantPhase: !0 }) : (a.isInstantPhase && s({ isInstantPhase: !1 }), o.current = null) }), [a.currentId, a.isInstantPhase]), t.createElement(ss.Provider, { value: t.useMemo((() => ({ ...a, setState: s, setCurrentId: l })), [a, l]) }, n) } function cs(e, t) { void 0 === t && (t = {}); const { open: n, onOpenChange: r, floatingId: i } = e, { id: a } = t, s = null != a ? a : i, o = os(), { currentId: l, setCurrentId: c, initialDelay: u, setState: d, timeoutMs: h } = o; return Ha((() => { l && (d({ delay: { open: 1, close: rs(u, "close") } }), l !== s && r(!1)) }), [s, r, d, l, u]), Ha((() => { function e() { r(!1), d({ delay: u, currentId: null }) } if (l && !n && l === s) { if (h) { const t = window.setTimeout(e, h); return () => { clearTimeout(t) } } e() } }), [n, d, l, s, r, u, h]), Ha((() => { c !== as && n && c(s) }), [n, c, s]), o } function us(e, t) { let n = e.filter((e => { var n; return e.parentId === t && (null == (n = e.context) ? void 0 : n.open) })), r = n; for (; r.length;)r = e.filter((e => { var t; return null == (t = r) ? void 0 : t.some((t => { var n; return e.parentId === t.id && (null == (n = e.context) ? void 0 : n.open) })) })), n = n.concat(r); return n } const ds = { pointerdown: "onPointerDown", mousedown: "onMouseDown", click: "onClick" }, hs = { pointerdown: "onPointerDownCapture", mousedown: "onMouseDownCapture", click: "onClickCapture" }, fs = e => { var t, n; return { escapeKey: "boolean" === typeof e ? e : null != (t = null == e ? void 0 : e.escapeKey) && t, outsidePress: "boolean" === typeof e ? e : null == (n = null == e ? void 0 : e.outsidePress) || n } }; function ps(e, n) { void 0 === n && (n = {}); const { open: r, onOpenChange: i, elements: a, dataRef: s } = e, { enabled: o = !0, escapeKey: l = !0, outsidePress: c = !0, outsidePressEvent: u = "pointerdown", referencePress: d = !1, referencePressEvent: h = "pointerdown", ancestorScroll: f = !1, bubbles: p, capture: m } = n, g = Za(), v = ja("function" === typeof c ? c : () => !1), b = "function" === typeof c ? v : c, y = t.useRef(!1), w = t.useRef(!1), { escapeKey: x, outsidePress: _ } = fs(p), { escapeKey: k, outsidePress: S } = fs(m), A = ja((e => { var t; if (!r || !o || !l || "Escape" !== e.key) return; const n = null == (t = s.current.floatingContext) ? void 0 : t.nodeId, a = g ? us(g.nodesRef.current, n) : []; if (!x && (e.stopPropagation(), a.length > 0)) { let e = !0; if (a.forEach((t => { var n; null == (n = t.context) || !n.open || t.context.dataRef.current.__escapeKeyBubbles || (e = !1) })), !e) return } i(!1, function (e) { return "nativeEvent" in e }(e) ? e.nativeEvent : e, "escape-key") })), E = ja((e => { var t; const n = () => { var t; A(e), null == (t = Ni(e)) || t.removeEventListener("keydown", n) }; null == (t = Ni(e)) || t.addEventListener("keydown", n) })), C = ja((e => { var t; const n = y.current; y.current = !1; const r = w.current; if (w.current = !1, "click" === u && r) return; if (n) return; if ("function" === typeof b && !b(e)) return; const o = Ni(e), l = "[" + es("inert") + "]", c = Pi(a.floating).querySelectorAll(l); let d = ci(o) ? o : null; for (; d && !vi(d);) { const e = wi(d); if (vi(e) || !ci(e)) break; d = e } if (c.length && ci(o) && !o.matches("html,body") && !Si(o, a.floating) && Array.from(c).every((e => !Si(d, e)))) return; if (ui(o) && P) { const t = o.clientWidth > 0 && o.scrollWidth > o.clientWidth, n = o.clientHeight > 0 && o.scrollHeight > o.clientHeight; let r = n && e.offsetX > o.clientWidth; if (n) { "rtl" === bi(o).direction && (r = e.offsetX <= o.offsetWidth - o.clientWidth) } if (r || t && e.offsetY > o.clientHeight) return } const h = null == (t = s.current.floatingContext) ? void 0 : t.nodeId, f = g && us(g.nodesRef.current, h).some((t => { var n; return Ri(e, null == (n = t.context) ? void 0 : n.elements.floating) })); if (Ri(e, a.floating) || Ri(e, a.domReference) || f) return; const p = g ? us(g.nodesRef.current, h) : []; if (p.length > 0) { let e = !0; if (p.forEach((t => { var n; null == (n = t.context) || !n.open || t.context.dataRef.current.__outsidePressBubbles || (e = !1) })), !e) return } i(!1, e, "outside-press") })), M = ja((e => { var t; const n = () => { var t; C(e), null == (t = Ni(e)) || t.removeEventListener(u, n) }; null == (t = Ni(e)) || t.addEventListener(u, n) })); t.useEffect((() => { if (!r || !o) return; function e(e) { i(!1, e, "ancestor-scroll") } s.current.__escapeKeyBubbles = x, s.current.__outsidePressBubbles = _; const t = Pi(a.floating); l && t.addEventListener("keydown", k ? E : A, k), b && t.addEventListener(u, S ? M : C, S); let n = []; return f && (ci(a.domReference) && (n = _i(a.domReference)), ci(a.floating) && (n = n.concat(_i(a.floating))), !ci(a.reference) && a.reference && a.reference.contextElement && (n = n.concat(_i(a.reference.contextElement)))), n = n.filter((e => { var n; return e !== (null == (n = t.defaultView) ? void 0 : n.visualViewport) })), n.forEach((t => { t.addEventListener("scroll", e, { passive: !0 }) })), () => { l && t.removeEventListener("keydown", k ? E : A, k), b && t.removeEventListener(u, S ? M : C, S), n.forEach((t => { t.removeEventListener("scroll", e) })) } }), [s, a, l, b, u, r, i, f, o, x, _, A, k, E, C, S, M]), t.useEffect((() => { y.current = !1 }), [b, u]); const T = t.useMemo((() => ({ onKeyDown: A, [ds[h]]: e => { d && i(!1, e.nativeEvent, "reference-press") } })), [A, i, d, h]), P = t.useMemo((() => ({ onKeyDown: A, onMouseDown() { w.current = !0 }, onMouseUp() { w.current = !0 }, [hs[u]]: () => { y.current = !0 } })), [A, u]); return t.useMemo((() => o ? { reference: T, floating: P } : {}), [o, T, P]) } function ms(e) { void 0 === e && (e = {}); const { nodeId: n } = e, r = function (e) { const { open: n = !1, onOpenChange: r, elements: i } = e, a = Ya(), s = t.useRef({}), [o] = t.useState((() => Ka())), l = null != Ja(), [c, u] = t.useState(i.reference), d = ja(((e, t, n) => { s.current.openEvent = e ? t : void 0, o.emit("openchange", { open: e, event: t, reason: n, nested: l }), null == r || r(e, t, n) })), h = t.useMemo((() => ({ setPositionReference: u })), []), f = t.useMemo((() => ({ reference: c || i.reference || null, floating: i.floating || null, domReference: i.reference })), [c, i.reference, i.floating]); return t.useMemo((() => ({ dataRef: s, open: n, onOpenChange: d, elements: f, events: o, floatingId: a, refs: h })), [n, d, f, o, a, h]) }({ ...e, elements: { reference: null, floating: null, ...e.elements } }), i = e.rootContext || r, a = i.elements, [s, o] = t.useState(null), [l, c] = t.useState(null), u = (null == a ? void 0 : a.reference) || s, d = t.useRef(null), h = Za(); Ha((() => { u && (d.current = u) }), [u]); const f = function (e) { void 0 === e && (e = {}); const { placement: n = "bottom", strategy: r = "absolute", middleware: i = [], platform: a, elements: { reference: s, floating: o } = {}, transform: l = !0, whileElementsMounted: c, open: u } = e, [d, h] = t.useState({ x: 0, y: 0, strategy: r, placement: n, middlewareData: {}, isPositioned: !1 }), [f, p] = t.useState(i); Aa(f, i) || p(i); const [m, g] = t.useState(null), [v, b] = t.useState(null), y = t.useCallback((e => { e !== k.current && (k.current = e, g(e)) }), []), w = t.useCallback((e => { e !== S.current && (S.current = e, b(e)) }), []), x = s || m, _ = o || v, k = t.useRef(null), S = t.useRef(null), A = t.useRef(d), E = null != c, C = Ma(c), M = Ma(a), T = t.useCallback((() => { if (!k.current || !S.current) return; const e = { placement: n, strategy: r, middleware: f }; M.current && (e.platform = M.current), ka(k.current, S.current, e).then((e => { const t = { ...e, isPositioned: !0 }; P.current && !Aa(A.current, t) && (A.current = t, Bt.flushSync((() => { h(t) }))) })) }), [f, n, r, M]); Sa((() => { !1 === u && A.current.isPositioned && (A.current.isPositioned = !1, h((e => ({ ...e, isPositioned: !1 })))) }), [u]); const P = t.useRef(!1); Sa((() => (P.current = !0, () => { P.current = !1 })), []), Sa((() => { if (x && (k.current = x), _ && (S.current = _), x && _) { if (C.current) return C.current(x, _, T); T() } }), [x, _, T, C, E]); const R = t.useMemo((() => ({ reference: k, floating: S, setReference: y, setFloating: w })), [y, w]), N = t.useMemo((() => ({ reference: x, floating: _ })), [x, _]), L = t.useMemo((() => { const e = { position: r, left: 0, top: 0 }; if (!N.floating) return e; const t = Ca(N.floating, d.x), n = Ca(N.floating, d.y); return l ? { ...e, transform: "translate(" + t + "px, " + n + "px)", ...Ea(N.floating) >= 1.5 && { willChange: "transform" } } : { position: r, left: t, top: n } }), [r, l, N.floating, d.x, d.y]); return t.useMemo((() => ({ ...d, update: T, refs: R, elements: N, floatingStyles: L })), [d, T, R, N, L]) }({ ...e, elements: { ...a, ...l && { reference: l } } }), p = t.useCallback((e => { const t = ci(e) ? { getBoundingClientRect: () => e.getBoundingClientRect(), contextElement: e } : e; c(t), f.refs.setReference(t) }), [f.refs]), m = t.useCallback((e => { (ci(e) || null === e) && (d.current = e, o(e)), (ci(f.refs.reference.current) || null === f.refs.reference.current || null !== e && !ci(e)) && f.refs.setReference(e) }), [f.refs]), g = t.useMemo((() => ({ ...f.refs, setReference: m, setPositionReference: p, domReference: d })), [f.refs, m, p]), v = t.useMemo((() => ({ ...f.elements, domReference: u })), [f.elements, u]), b = t.useMemo((() => ({ ...f, ...i, refs: g, elements: v, nodeId: n })), [f, g, v, n, i]); return Ha((() => { i.dataRef.current.floatingContext = b; const e = null == h ? void 0 : h.nodesRef.current.find((e => e.id === n)); e && (e.context = b) })), t.useMemo((() => ({ ...f, context: b, refs: g, elements: v })), [f, g, v, b]) } function gs(e, n) { void 0 === n && (n = {}); const { open: r, onOpenChange: i, events: a, dataRef: s, elements: o } = e, { enabled: l = !0, visibleOnly: c = !0 } = n, u = t.useRef(!1), d = t.useRef(), h = t.useRef(!0); t.useEffect((() => { if (!l) return; const e = si(o.domReference); function t() { !r && ui(o.domReference) && o.domReference === ki(Pi(o.domReference)) && (u.current = !0) } function n() { h.current = !0 } return e.addEventListener("blur", t), e.addEventListener("keydown", n, !0), () => { e.removeEventListener("blur", t), e.removeEventListener("keydown", n, !0) } }), [o.domReference, r, l]), t.useEffect((() => { if (l) return a.on("openchange", e), () => { a.off("openchange", e) }; function e(e) { let { reason: t } = e; "reference-press" !== t && "escape-key" !== t || (u.current = !0) } }), [a, l]), t.useEffect((() => () => { clearTimeout(d.current) }), []); const f = t.useMemo((() => ({ onPointerDown(e) { Ci(e.nativeEvent) || (h.current = !1) }, onMouseLeave() { u.current = !1 }, onFocus(e) { if (u.current) return; const t = Ni(e.nativeEvent); if (c && ci(t)) try { if (/apple/i.test(navigator.vendor) && Ai().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints) throw Error(); if (!t.matches(":focus-visible")) return } catch ($A) { if (!h.current && !Ii(t)) return } i(!0, e.nativeEvent, "focus") }, onBlur(e) { u.current = !1; const t = e.relatedTarget, n = e.nativeEvent, r = ci(t) && t.hasAttribute(es("focus-guard")) && "outside" === t.getAttribute("data-type"); d.current = window.setTimeout((() => { var e; const a = ki(o.domReference ? o.domReference.ownerDocument : document); (t || a !== o.domReference) && (Si(null == (e = s.current.floatingContext) ? void 0 : e.refs.floating.current, a) || Si(o.domReference, a) || r || i(!1, n, "focus")) })) } })), [s, o.domReference, i, c]); return t.useMemo((() => l ? { reference: f } : {}), [l, f]) } const vs = "active", bs = "selected"; function ys(e, t, n) { const r = new Map, i = "item" === n; let a = e; if (i && e) { const { [vs]: t, [bs]: n, ...r } = e; a = r } return { ..."floating" === n && { tabIndex: -1 }, ...a, ...t.map((t => { const r = t ? t[n] : null; return "function" === typeof r ? e ? r(e) : null : r })).concat(e).reduce(((e, t) => t ? (Object.entries(t).forEach((t => { let [n, a] = t; var s; i && [vs, bs].includes(n) || (0 === n.indexOf("on") ? (r.has(n) || r.set(n, []), "function" === typeof a && (null == (s = r.get(n)) || s.push(a), e[n] = function () { for (var e, t = arguments.length, i = new Array(t), a = 0; a < t; a++)i[a] = arguments[a]; return null == (e = r.get(n)) ? void 0 : e.map((e => e(...i))).find((e => void 0 !== e)) })) : e[n] = a) })), e) : e), {}) } } const ws = new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]); function xs(e, n) { var r; void 0 === n && (n = {}); const { open: i, floatingId: a } = e, { enabled: s = !0, role: o = "dialog" } = n, l = null != (r = ws.get(o)) ? r : o, c = Ya(), u = null != Ja(), d = t.useMemo((() => "tooltip" === l || "label" === o ? { ["aria-" + ("label" === o ? "labelledby" : "describedby")]: i ? a : void 0 } : { "aria-expanded": i ? "true" : "false", "aria-haspopup": "alertdialog" === l ? "dialog" : l, "aria-controls": i ? a : void 0, ..."listbox" === l && { role: "combobox" }, ..."menu" === l && { id: c }, ..."menu" === l && u && { role: "menuitem" }, ..."select" === o && { "aria-autocomplete": "none" }, ..."combobox" === o && { "aria-autocomplete": "list" } }), [l, a, u, i, c, o]), h = t.useMemo((() => { const e = { id: a, ...l && { role: l } }; return "tooltip" === l || "label" === o ? e : { ...e, ..."menu" === l && { "aria-labelledby": c } } }), [l, a, c, o]), f = t.useCallback((e => { let { active: t, selected: n } = e; const r = { role: "option", ...t && { id: a + "-option" } }; switch (o) { case "select": return { ...r, "aria-selected": t && n }; case "combobox": return { ...r, ...t && { "aria-selected": !0 } } }return {} }), [a, o]); return t.useMemo((() => s ? { reference: d, floating: h, item: f } : {}), [s, d, h, f]) } var _s = { tooltip: "m_1b3c8819", arrow: "m_f898399f" }; const ks = { refProp: "ref", withinPortal: !0, offset: 10, defaultOpened: !1, position: "right", zIndex: Y("popover") }, Ss = (e, t) => { let { radius: n, color: r } = t; return { tooltip: { "--tooltip-radius": void 0 === n ? void 0 : He(n), "--tooltip-bg": r ? T(r, e) : void 0, "--tooltip-color": r ? "var(--mantine-color-white)" : void 0 } } }, As = J(((e, n) => { var r, i; const a = Q("TooltipFloating", ks, e), { children: s, refProp: o, withinPortal: l, style: c, className: u, classNames: d, styles: h, unstyled: f, radius: p, color: m, label: g, offset: b, position: y, multiline: w, zIndex: x, disabled: _, defaultOpened: k, variant: S, vars: A, portalProps: E, ...C } = a, M = U(), T = rt({ name: "TooltipFloating", props: a, classes: _s, className: u, style: c, classNames: d, styles: h, unstyled: f, rootSelector: "tooltip", vars: A, varsResolver: Ss }), { handleMouseMove: P, x: R, y: N, opened: L, boundaryRef: I, floating: D, setOpened: O } = function (e) { let { offset: n, position: r, defaultOpened: i } = e; const [a, s] = (0, t.useState)(i), o = (0, t.useRef)(), { x: l, y: c, elements: u, refs: d, update: h, placement: f } = ms({ placement: r, middleware: [Ra({ crossAxis: !0, padding: 5, rootBoundary: "document" })] }), p = f.includes("right") ? n : r.includes("left") ? -1 * n : 0, m = f.includes("bottom") ? n : r.includes("top") ? -1 * n : 0, g = (0, t.useCallback)((e => { let { clientX: t, clientY: n } = e; d.setPositionReference({ getBoundingClientRect: () => ({ width: 0, height: 0, x: t, y: n, left: t + p, top: n + m, right: t, bottom: n }) }) }), [u.reference]); return (0, t.useEffect)((() => { if (d.floating.current) { const e = o.current; e.addEventListener("mousemove", g); const t = _i(d.floating.current); return t.forEach((e => { e.addEventListener("scroll", h) })), () => { e.removeEventListener("mousemove", g), t.forEach((e => { e.removeEventListener("scroll", h) })) } } }), [u.reference, d.floating.current, h, g, a]), { handleMouseMove: g, x: l, y: c, opened: a, setOpened: s, boundaryRef: o, floating: d.setFloating } }({ offset: b, position: y, defaultOpened: k }); if (!Ct(s)) throw new Error("[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"); const j = Et(I, s.ref, n); return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(nr, { ...E, withinPortal: l, children: (0, v.jsx)(Se, { ...C, ...T("tooltip", { style: { ...ii(c, M), zIndex: x, display: !_ && L ? "block" : "none", top: null !== (r = N && Math.round(N)) && void 0 !== r ? r : "", left: null !== (i = R && Math.round(R)) && void 0 !== i ? i : "" } }), variant: S, ref: D, mod: { multiline: w }, children: g }) }), (0, t.cloneElement)(s, { ...s.props, [o]: j, onMouseEnter: e => { var t, n; null === (t = (n = s.props).onMouseEnter) || void 0 === t || t.call(n, e), P(e), O(!0) }, onMouseLeave: e => { var t, n; null === (t = (n = s.props).onMouseLeave) || void 0 === t || t.call(n, e), O(!1) } })] }) })); As.classes = _s, As.displayName = "@mantine/core/TooltipFloating"; const Es = (0, t.createContext)(!1), Cs = Es.Provider, Ms = { openDelay: 0, closeDelay: 0 }; function Ts(e) { const { openDelay: t, closeDelay: n, children: r } = Q("TooltipGroup", Ms, e); return (0, v.jsx)(Cs, { value: !0, children: (0, v.jsx)(ls, { delay: { open: t, close: n }, children: r }) }) } function Ps(e) { var n, r, i; const [a, s] = (0, t.useState)(e.defaultOpened), o = "boolean" === typeof e.opened ? e.opened : a, l = (0, t.useContext)(Es), c = ir(), { delay: u, currentId: d, setCurrentId: h } = os(), f = (0, t.useCallback)((e => { s(e), e && h(c) }), [h, c]), { x: p, y: m, context: g, refs: v, update: b, placement: y, middlewareData: { arrow: { x: w, y: x } = {} } } = ms({ strategy: e.strategy, placement: e.position, open: o, onOpenChange: f, middleware: [Pa(e.offset), Ra({ padding: 8 }), Na(), Ia({ element: e.arrowRef, padding: e.arrowOffset }), ...e.inline ? [La()] : []] }), { getReferenceProps: _, getFloatingProps: k } = function (e) { void 0 === e && (e = []); const n = e.map((e => null == e ? void 0 : e.reference)), r = e.map((e => null == e ? void 0 : e.floating)), i = e.map((e => null == e ? void 0 : e.item)), a = t.useCallback((t => ys(t, e, "reference")), n), s = t.useCallback((t => ys(t, e, "floating")), r), o = t.useCallback((t => ys(t, e, "item")), i); return t.useMemo((() => ({ getReferenceProps: a, getFloatingProps: s, getItemProps: o })), [a, s, o]) }([is(g, { enabled: null === (n = e.events) || void 0 === n ? void 0 : n.hover, delay: l ? u : { open: e.openDelay, close: e.closeDelay }, mouseOnly: !(null !== (r = e.events) && void 0 !== r && r.touch) }), gs(g, { enabled: null === (i = e.events) || void 0 === i ? void 0 : i.focus, visibleOnly: !0 }), xs(g, { role: "tooltip" }), ps(g, { enabled: "undefined" === typeof e.opened }), cs(g, { id: c })]); !function (e) { let { opened: n, floating: r, position: i, positionDependencies: a } = e; const [s, o] = (0, t.useState)(0); (0, t.useEffect)((() => { if (r.refs.reference.current && r.refs.floating.current) return va(r.refs.reference.current, r.refs.floating.current, r.update) }), [r.refs.reference.current, r.refs.floating.current, n, s, i]), Ut((() => { r.update() }), a), Ut((() => { o((e => e + 1)) }), [n]) }({ opened: o, position: e.position, positionDependencies: e.positionDependencies, floating: { refs: v, update: b } }), Ut((() => { var t; null === (t = e.onPositionChange) || void 0 === t || t.call(e, y) }), [y]); const S = o && d && d !== c; return { x: p, y: m, arrowX: w, arrowY: x, reference: v.setReference, floating: v.setFloating, getFloatingProps: k, getReferenceProps: _, isGroupPhase: S, opened: o, placement: y } } Ts.displayName = "@mantine/core/TooltipGroup"; const Rs = { position: "top", refProp: "ref", withinPortal: !0, inline: !1, defaultOpened: !1, arrowSize: 4, arrowOffset: 5, arrowRadius: 0, arrowPosition: "side", offset: 5, transitionProps: { duration: 100, transition: "fade" }, events: { hover: !0, focus: !1, touch: !1 }, zIndex: Y("popover"), positionDependencies: [] }, Ns = (e, t) => { let { radius: n, color: r } = t; return { tooltip: { "--tooltip-radius": void 0 === n ? void 0 : He(n), "--tooltip-bg": r ? T(r, e) : void 0, "--tooltip-color": r ? "var(--mantine-color-white)" : void 0 } } }, Ls = J(((e, n) => { const r = Q("Tooltip", Rs, e), { children: i, position: a, refProp: s, label: o, openDelay: l, closeDelay: c, onPositionChange: u, opened: d, defaultOpened: h, withinPortal: f, radius: p, color: m, classNames: g, styles: b, unstyled: y, style: w, className: x, withArrow: _, arrowSize: k, arrowOffset: S, arrowRadius: A, arrowPosition: E, offset: C, transitionProps: M, multiline: T, events: P, zIndex: R, disabled: N, positionDependencies: L, onClick: I, onMouseEnter: D, onMouseLeave: O, inline: j, variant: F, keepMounted: z, vars: W, portalProps: B, mod: H, floatingStrategy: U, ...V } = Q("Tooltip", Rs, r), { dir: q } = Ar(), G = (0, t.useRef)(null), X = Ps({ position: $r(q, a), closeDelay: c, openDelay: l, onPositionChange: u, opened: d, defaultOpened: h, events: P, arrowRef: G, arrowOffset: S, offset: "number" === typeof C ? C + (_ ? k / 2 : 0) : C, positionDependencies: [...L, i], inline: j, strategy: U }), Y = rt({ name: "Tooltip", props: r, classes: _s, className: x, style: w, classNames: g, styles: b, unstyled: y, rootSelector: "tooltip", vars: W, varsResolver: Ns }); if (!Ct(i)) throw new Error("[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"); const K = Et(X.reference, i.ref, n), $ = function (e, t) { return { ...ri, ...t, ...e } }(M, { duration: 100, transition: "fade" }); return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(nr, { ...B, withinPortal: f, children: (0, v.jsx)(qt, { ...$, keepMounted: z, mounted: !N && !!X.opened, duration: X.isGroupPhase ? 10 : $.duration, children: e => { var t, n; return (0, v.jsxs)(Se, { ...V, "data-fixed": "fixed" === U || void 0, variant: F, mod: [{ multiline: T }, H], ...X.getFloatingProps({ ref: X.floating, className: Y("tooltip").className, style: { ...Y("tooltip").style, ...e, zIndex: R, top: null !== (t = X.y) && void 0 !== t ? t : 0, left: null !== (n = X.x) && void 0 !== n ? n : 0 } }), children: [o, (0, v.jsx)(ni, { ref: G, arrowX: X.arrowX, arrowY: X.arrowY, visible: _, position: X.placement, arrowSize: k, arrowOffset: S, arrowRadius: A, arrowPosition: E, ...Y("arrow") })] }) } }) }), (0, t.cloneElement)(i, X.getReferenceProps({ onClick: I, onMouseEnter: D, onMouseLeave: O, onMouseMove: r.onMouseMove, onPointerDown: r.onPointerDown, onPointerEnter: r.onPointerEnter, [s]: K, className: te(x, i.props.className), ...i.props }))] }) })); Ls.classes = _s, Ls.displayName = "@mantine/core/Tooltip", Ls.Floating = As, Ls.Group = Ts; var Is = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" }; const Ds = (0, t.forwardRef)(((e, t) => { let { className: n, ...r } = e; return (0, v.jsxs)(Se, { component: "span", className: te(Is.barsLoader, n), ...r, ref: t, children: [(0, v.jsx)("span", { className: Is.bar }), (0, v.jsx)("span", { className: Is.bar }), (0, v.jsx)("span", { className: Is.bar })] }) })), Os = (0, t.forwardRef)(((e, t) => { let { className: n, ...r } = e; return (0, v.jsxs)(Se, { component: "span", className: te(Is.dotsLoader, n), ...r, ref: t, children: [(0, v.jsx)("span", { className: Is.dot }), (0, v.jsx)("span", { className: Is.dot }), (0, v.jsx)("span", { className: Is.dot })] }) })), js = { bars: Ds, oval: (0, t.forwardRef)(((e, t) => { let { className: n, ...r } = e; return (0, v.jsx)(Se, { component: "span", className: te(Is.ovalLoader, n), ...r, ref: t }) })), dots: Os }, Fs = { loaders: js, type: "oval" }, zs = (e, t) => { let { size: n, color: r } = t; return { root: { "--loader-size": We(n, "loader-size"), "--loader-color": r ? T(r, e) : void 0 } } }, Ws = J(((e, t) => { const n = Q("Loader", Fs, e), { size: r, color: i, type: a, vars: s, className: o, style: l, classNames: c, styles: u, unstyled: d, loaders: h, variant: f, children: p, ...m } = n, g = rt({ name: "Loader", props: n, classes: Is, className: o, style: l, classNames: c, styles: u, unstyled: d, vars: s, varsResolver: zs }); return p ? (0, v.jsx)(Se, { ...g("root"), ref: t, ...m, children: p }) : (0, v.jsx)(Se, { ...g("root"), ref: t, component: h[a], variant: f, size: r, ...m }) })); Ws.defaultLoaders = js, Ws.classes = Is, Ws.displayName = "@mantine/core/Loader"; var Bs = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21" }; const Hs = { orientation: "horizontal" }, Us = (e, t) => { let { borderWidth: n } = t; return { group: { "--ai-border-width": w(n) } } }, Vs = J(((e, t) => { const n = Q("ActionIconGroup", Hs, e), { className: r, style: i, classNames: a, styles: s, unstyled: o, orientation: l, vars: c, borderWidth: u, variant: d, mod: h, ...f } = Q("ActionIconGroup", Hs, e), p = rt({ name: "ActionIconGroup", props: n, classes: Bs, className: r, style: i, classNames: a, styles: s, unstyled: o, vars: c, varsResolver: Us, rootSelector: "group" }); return (0, v.jsx)(Se, { ...p("group"), ref: t, variant: d, mod: [{ "data-orientation": l }, h], role: "group", ...f }) })); Vs.classes = Bs, Vs.displayName = "@mantine/core/ActionIconGroup"; const qs = {}, Gs = (e, t) => { let { size: n, radius: r, variant: i, gradient: a, color: s, autoContrast: o } = t; const l = e.variantColorResolver({ color: s || e.primaryColor, theme: e, gradient: a, variant: i || "filled", autoContrast: o }); return { root: { "--ai-size": We(n, "ai-size"), "--ai-radius": void 0 === r ? void 0 : He(r), "--ai-bg": s || i ? l.background : void 0, "--ai-hover": s || i ? l.hover : void 0, "--ai-hover-color": s || i ? l.hoverColor : void 0, "--ai-color": l.color, "--ai-bd": s || i ? l.border : void 0 } } }, Xs = it(((e, t) => { const n = Q("ActionIcon", qs, e), { className: r, unstyled: i, variant: a, classNames: s, styles: o, style: l, loading: c, loaderProps: u, size: d, color: h, radius: f, __staticSelector: p, gradient: m, vars: g, children: b, disabled: y, "data-disabled": w, autoContrast: x, mod: _, ...k } = n, S = rt({ name: ["ActionIcon", p], props: n, className: r, style: l, classes: Bs, classNames: s, styles: o, unstyled: i, vars: g, varsResolver: Gs }); return (0, v.jsxs)(ot, { ...S("root", { active: !y && !c && !w }), ...k, unstyled: i, variant: a, size: d, disabled: y || c, ref: t, mod: [{ loading: c, disabled: y || w }, _], children: [(0, v.jsx)(qt, { mounted: !!c, transition: "slide-down", duration: 150, children: e => (0, v.jsx)(Se, { component: "span", ...S("loader", { style: e }), "aria-hidden": !0, children: (0, v.jsx)(Ws, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...u }) }) }), (0, v.jsx)(Se, { component: "span", mod: { loading: c }, ...S("icon"), children: b })] }) })); Xs.classes = Bs, Xs.displayName = "@mantine/core/ActionIcon", Xs.Group = Vs; var Ys = a("filled", "arrow-big-down-line-filled", "IconArrowBigDownLineFilled", [["path", { d: "M9 5l-.117 .007a1 1 0 0 0 -.883 .993v4.999l-2.586 .001a2 2 0 0 0 -1.414 3.414l6.586 6.586a2 2 0 0 0 2.828 0l6.586 -6.586a2 2 0 0 0 .434 -2.18l-.068 -.145a2 2 0 0 0 -1.78 -1.089l-2.586 -.001v-4.999a1 1 0 0 0 -1 -1h-6z", key: "svg-0" }], ["path", { d: "M15 2a1 1 0 0 1 .117 1.993l-.117 .007h-6a1 1 0 0 1 -.117 -1.993l.117 -.007h6z", key: "svg-1" }]]), Ks = function (e, t, n) { if (n || 2 === arguments.length) for (var r, i = 0, a = t.length; i < a; i++)!r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]); return e.concat(r || Array.prototype.slice.call(t)) }, Qs = Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks(Ks([], ["onCopy", "onCut", "onPaste"], !0), ["onCompositionEnd", "onCompositionStart", "onCompositionUpdate"], !0), ["onFocus", "onBlur"], !0), ["onInput", "onInvalid", "onReset", "onSubmit"], !0), ["onLoad", "onError"], !0), ["onKeyDown", "onKeyPress", "onKeyUp"], !0), ["onAbort", "onCanPlay", "onCanPlayThrough", "onDurationChange", "onEmptied", "onEncrypted", "onEnded", "onError", "onLoadedData", "onLoadedMetadata", "onLoadStart", "onPause", "onPlay", "onPlaying", "onProgress", "onRateChange", "onSeeked", "onSeeking", "onStalled", "onSuspend", "onTimeUpdate", "onVolumeChange", "onWaiting"], !0), ["onClick", "onContextMenu", "onDoubleClick", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp"], !0), ["onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop"], !0), ["onSelect"], !0), ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], !0), ["onPointerDown", "onPointerMove", "onPointerUp", "onPointerCancel", "onGotPointerCapture", "onLostPointerCapture", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut"], !0), ["onScroll"], !0), ["onWheel"], !0), ["onAnimationStart", "onAnimationEnd", "onAnimationIteration"], !0), ["onTransitionEnd"], !0), ["onChange"], !0), ["onToggle"], !0); function $s(e, t) { var n = {}; return Qs.forEach((function (r) { var i = e[r]; i && (n[r] = t ? function (e) { return i(e, t(r)) } : i) })), n } function Js(e) { var t = !1, n = new Promise((function (n, r) { e.then((function (e) { return !t && n(e) })).catch((function (e) { return !t && r(e) })) })); return { promise: n, cancel: function () { t = !0 } } } var Zs = !0, eo = "Invariant failed"; function to(e, t) { if (!e) { if (Zs) throw new Error(eo); var n = "function" === typeof t ? t() : t, r = n ? "".concat(eo, ": ").concat(n) : eo; throw new Error(r) } } var no, ro, io, ao, so, oo, lo, co, uo, ho, fo, po, mo = __webpack_require__(440), go = Object.prototype.hasOwnProperty; function vo(e, t, n) { for (n of e.keys()) if (bo(n, t)) return n } function bo(e, t) { var n, r, i; if (e === t) return !0; if (e && t && (n = e.constructor) === t.constructor) { if (n === Date) return e.getTime() === t.getTime(); if (n === RegExp) return e.toString() === t.toString(); if (n === Array) { if ((r = e.length) === t.length) for (; r-- && bo(e[r], t[r]);); return -1 === r } if (n === Set) { if (e.size !== t.size) return !1; for (r of e) { if ((i = r) && "object" === typeof i && !(i = vo(t, i))) return !1; if (!t.has(i)) return !1 } return !0 } if (n === Map) { if (e.size !== t.size) return !1; for (r of e) { if ((i = r[0]) && "object" === typeof i && !(i = vo(t, i))) return !1; if (!bo(r[1], t.get(i))) return !1 } return !0 } if (n === ArrayBuffer) e = new Uint8Array(e), t = new Uint8Array(t); else if (n === DataView) { if ((r = e.byteLength) === t.byteLength) for (; r-- && e.getInt8(r) === t.getInt8(r);); return -1 === r } if (ArrayBuffer.isView(e)) { if ((r = e.byteLength) === t.byteLength) for (; r-- && e[r] === t[r];); return -1 === r } if (!n || "object" === typeof e) { for (n in r = 0, e) { if (go.call(e, n) && ++r && !go.call(t, n)) return !1; if (!(n in t) || !bo(e[n], t[n])) return !1 } return Object.keys(t).length === r } } return e !== e && t !== t } function yo(e, t, n) { t || (t = []); var r = t.length++; return Object.defineProperty({}, "_", { set: function (i) { t[r] = i, e.apply(n, t) } }) } function wo(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object") } function xo(e, t) { wo(e, t), t.add(e) } function _o(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object") } function ko(e, t, n) { return n(_o(e, t)) } function So(e) { return So = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, So(e) } function Ao(e) { var t = function (e, t) { if ("object" != So(e) || !e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" != So(r)) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" == So(t) ? t : t + "" } function Eo(e, t, n) { return (t = Ao(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function Co(e, t, n) { wo(e, t), t.set(e, n) } function Mo(e, t) { return e.get(_o(e, t)) } function To(e, t, n) { return e.set(_o(e, t), n), n } var Po = { d: (e, t) => { for (var n in t) Po.o(t, n) && !Po.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t) }, Ro = globalThis.pdfjsLib = {}; Po.d(Ro, { AbortException: () => Ul, AnnotationEditorLayer: () => Gx, AnnotationEditorParamsType: () => qo, AnnotationEditorType: () => Vo, AnnotationEditorUIManager: () => Dd, AnnotationLayer: () => ib, AnnotationMode: () => Uo, CMapCompressionType: () => Sl, ColorPicker: () => Ny, DOMSVGFactory: () => Wc, DrawLayer: () => i_, FeatureTest: () => Xl, GlobalWorkerOptions: () => Yf, ImageKind: () => Zo, InvalidPDFException: () => zl, MissingPDFException: () => Wl, OPS: () => Al, Outliner: () => Lb, PDFDataRangeTransport: () => qm, PDFDateString: () => Jc, PDFWorker: () => ig, PasswordResponses: () => El, PermissionFlag: () => Go, PixelsPerInch: () => bc, RenderingCancelledException: () => Hc, TextLayer: () => _m, UnexpectedResponseException: () => Bl, Util: () => Kl, VerbosityLevel: () => kl, XfaLayer: () => Rg, build: () => Cg, createValidAbsoluteUrl: () => Il, fetchData: () => jc, getDocument: () => Bm, getFilenameFromUrl: () => qc, getPdfFilenameFromUrl: () => Gc, getXfaPageViewport: () => Zc, isDataScheme: () => Uc, isPdfFile: () => Vc, noContextMenu: () => Kc, normalizeUnicode: () => ec, renderTextLayer: () => Lm, setLayerDimensions: () => ru, shadow: () => Dl, updateTextLayer: () => Im, version: () => Eg }); const No = "object" === typeof process && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && "browser" !== process.type), Lo = [1, 0, 0, 1, 0, 0], Io = [.001, 0, 0, .001, 0, 0], Do = 1.35, Oo = 1, jo = 2, Fo = 4, zo = 16, Wo = 32, Bo = 64, Ho = 256, Uo = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }, Vo = { DISABLE: -1, NONE: 0, FREETEXT: 3, HIGHLIGHT: 9, STAMP: 13, INK: 15 }, qo = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23, HIGHLIGHT_COLOR: 31, HIGHLIGHT_DEFAULT_COLOR: 32, HIGHLIGHT_THICKNESS: 33, HIGHLIGHT_FREE: 34, HIGHLIGHT_SHOW_ALL: 35 }, Go = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, Xo = 0, Yo = 1, Ko = 2, Qo = 3, $o = 3, Jo = 4, Zo = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }, el = 1, tl = 2, nl = 3, rl = 4, il = 5, al = 6, sl = 7, ol = 8, ll = 9, cl = 10, ul = 11, dl = 12, hl = 13, fl = 14, pl = 15, ml = 16, gl = 17, vl = 20, bl = 1, yl = 2, wl = 3, xl = 4, _l = 5, kl = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }, Sl = { NONE: 0, BINARY: 1 }, Al = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }, El = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; let Cl = kl.WARNINGS; function Ml(e) { Number.isInteger(e) && (Cl = e) } function Tl() { return Cl } function Pl(e) { Cl >= kl.INFOS && console.log("Info: ".concat(e)) } function Rl(e) { Cl >= kl.WARNINGS && console.log("Warning: ".concat(e)) } function Nl(e) { throw new Error(e) } function Ll(e, t) { e || Nl(t) } function Il(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; if (!e) return null; try { if (n && "string" === typeof e) { if (n.addDefaultProtocol && e.startsWith("www.")) { const t = e.match(/\./g); (null === t || void 0 === t ? void 0 : t.length) >= 2 && (e = "http://".concat(e)) } if (n.tryConvertEncoding) try { e = decodeURIComponent(escape(e)) } catch { } } const r = t ? new URL(e, t) : new URL(e); if (function (e) { switch (null === e || void 0 === e ? void 0 : e.protocol) { case "http:": case "https:": case "ftp:": case "mailto:": case "tel:": return !0; default: return !1 } }(r)) return r } catch { } return null } function Dl(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return Object.defineProperty(e, t, { value: n, enumerable: !r, configurable: !0, writable: !1 }), n } const Ol = function () { function e(t, n) { this.constructor === e && Nl("Cannot initialize BaseException."), this.message = t, this.name = n } return e.prototype = new Error, e.constructor = e, e }(); class jl extends Ol { constructor(e, t) { super(e, "PasswordException"), this.code = t } } class Fl extends Ol { constructor(e, t) { super(e, "UnknownErrorException"), this.details = t } } class zl extends Ol { constructor(e) { super(e, "InvalidPDFException") } } class Wl extends Ol { constructor(e) { super(e, "MissingPDFException") } } class Bl extends Ol { constructor(e, t) { super(e, "UnexpectedResponseException"), this.status = t } } class Hl extends Ol { constructor(e) { super(e, "FormatError") } } class Ul extends Ol { constructor(e) { super(e, "AbortException") } } function Vl(e) { "object" === typeof e && void 0 !== (null === e || void 0 === e ? void 0 : e.length) || Nl("Invalid argument for bytesToString"); const t = e.length, n = 8192; if (t < n) return String.fromCharCode.apply(null, e); const r = []; for (let i = 0; i < t; i += n) { const a = Math.min(i + n, t), s = e.subarray(i, a); r.push(String.fromCharCode.apply(null, s)) } return r.join("") } function ql(e) { "string" !== typeof e && Nl("Invalid argument for stringToBytes"); const t = e.length, n = new Uint8Array(t); for (let r = 0; r < t; ++r)n[r] = 255 & e.charCodeAt(r); return n } function Gl(e) { const t = Object.create(null); for (const [n, r] of e) t[n] = r; return t } class Xl { static get isLittleEndian() { return Dl(this, "isLittleEndian", function () { const e = new Uint8Array(4); return e[0] = 1, 1 === new Uint32Array(e.buffer, 0, 1)[0] }()) } static get isEvalSupported() { return Dl(this, "isEvalSupported", function () { try { return new Function(""), !0 } catch { return !1 } }()) } static get isOffscreenCanvasSupported() { return Dl(this, "isOffscreenCanvasSupported", "undefined" !== typeof OffscreenCanvas) } static get platform() { var e; return "undefined" !== typeof navigator && "string" === typeof (null === (e = navigator) || void 0 === e ? void 0 : e.platform) ? Dl(this, "platform", { isMac: navigator.platform.includes("Mac") }) : Dl(this, "platform", { isMac: !1 }) } static get isCSSRoundSupported() { var e, t; return Dl(this, "isCSSRoundSupported", null === (e = globalThis.CSS) || void 0 === e || null === (t = e.supports) || void 0 === t ? void 0 : t.call(e, "width: round(1.5px, 1px)")) } } const Yl = Array.from(Array(256).keys(), (e => e.toString(16).padStart(2, "0"))); class Kl { static makeHexColor(e, t, n) { return "#".concat(Yl[e]).concat(Yl[t]).concat(Yl[n]) } static scaleMinMax(e, t) { let n; e[0] ? (e[0] < 0 && (n = t[0], t[0] = t[2], t[2] = n), t[0] *= e[0], t[2] *= e[0], e[3] < 0 && (n = t[1], t[1] = t[3], t[3] = n), t[1] *= e[3], t[3] *= e[3]) : (n = t[0], t[0] = t[1], t[1] = n, n = t[2], t[2] = t[3], t[3] = n, e[1] < 0 && (n = t[1], t[1] = t[3], t[3] = n), t[1] *= e[1], t[3] *= e[1], e[2] < 0 && (n = t[0], t[0] = t[2], t[2] = n), t[0] *= e[2], t[2] *= e[2]), t[0] += e[4], t[1] += e[5], t[2] += e[4], t[3] += e[5] } static transform(e, t) { return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]] } static applyTransform(e, t) { return [e[0] * t[0] + e[1] * t[2] + t[4], e[0] * t[1] + e[1] * t[3] + t[5]] } static applyInverseTransform(e, t) { const n = t[0] * t[3] - t[1] * t[2]; return [(e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / n, (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / n] } static getAxialAlignedBoundingBox(e, t) { const n = this.applyTransform(e, t), r = this.applyTransform(e.slice(2, 4), t), i = this.applyTransform([e[0], e[3]], t), a = this.applyTransform([e[2], e[1]], t); return [Math.min(n[0], r[0], i[0], a[0]), Math.min(n[1], r[1], i[1], a[1]), Math.max(n[0], r[0], i[0], a[0]), Math.max(n[1], r[1], i[1], a[1])] } static inverseTransform(e) { const t = e[0] * e[3] - e[1] * e[2]; return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t] } static singularValueDecompose2dScale(e) { const t = [e[0], e[2], e[1], e[3]], n = e[0] * t[0] + e[1] * t[2], r = e[0] * t[1] + e[1] * t[3], i = e[2] * t[0] + e[3] * t[2], a = e[2] * t[1] + e[3] * t[3], s = (n + a) / 2, o = Math.sqrt((n + a) ** 2 - 4 * (n * a - i * r)) / 2, l = s + o || 1, c = s - o || 1; return [Math.sqrt(l), Math.sqrt(c)] } static normalizeRect(e) { const t = e.slice(0); return e[0] > e[2] && (t[0] = e[2], t[2] = e[0]), e[1] > e[3] && (t[1] = e[3], t[3] = e[1]), t } static intersect(e, t) { const n = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])), r = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2])); if (n > r) return null; const i = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])), a = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3])); return i > a ? null : [n, i, r, a] } static bezierBoundingBox(e, t, n, r, i, a, s, o, l) { return l ? (l[0] = Math.min(l[0], e, s), l[1] = Math.min(l[1], t, o), l[2] = Math.max(l[2], e, s), l[3] = Math.max(l[3], t, o)) : l = [Math.min(e, s), Math.min(t, o), Math.max(e, s), Math.max(t, o)], _o(Kl, this, $l).call(this, e, n, i, s, t, r, a, o, 3 * (3 * (n - i) - e + s), 6 * (e - 2 * n + i), 3 * (n - e), l), _o(Kl, this, $l).call(this, e, n, i, s, t, r, a, o, 3 * (3 * (r - a) - t + o), 6 * (t - 2 * r + a), 3 * (r - t), l), l } } function Ql(e, t, n, r, i, a, s, o, l, c) { if (l <= 0 || l >= 1) return; const u = 1 - l, d = l * l, h = d * l, f = u * (u * (u * e + 3 * l * t) + 3 * d * n) + h * r, p = u * (u * (u * i + 3 * l * a) + 3 * d * s) + h * o; c[0] = Math.min(c[0], f), c[1] = Math.min(c[1], p), c[2] = Math.max(c[2], f), c[3] = Math.max(c[3], p) } function $l(e, t, n, r, i, a, s, o, l, c, u, d) { if (Math.abs(l) < 1e-12) return void (Math.abs(c) >= 1e-12 && _o(no, this, Ql).call(this, e, t, n, r, i, a, s, o, -u / c, d)); const h = c ** 2 - 4 * u * l; if (h < 0) return; const f = Math.sqrt(h), p = 2 * l; _o(no, this, Ql).call(this, e, t, n, r, i, a, s, o, (-c + f) / p, d), _o(no, this, Ql).call(this, e, t, n, r, i, a, s, o, (-c - f) / p, d) } no = Kl; let Jl = null, Zl = null; function ec(e) { return Jl || (Jl = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Zl = new Map([["\ufb05", "\u017ft"]])), e.replaceAll(Jl, ((e, t, n) => t ? t.normalize("NFKC") : Zl.get(n))) } const tc = "pdfjs_internal_id_", nc = 0, rc = 1, ic = 2, ac = 3, sc = 4, oc = 5, lc = 6, cc = 7, uc = 8; class dc { constructor() { this.constructor === dc && Nl("Cannot initialize BaseFilterFactory.") } addFilter(e) { return "none" } addHCMFilter(e, t) { return "none" } addAlphaFilter(e) { return "none" } addLuminosityFilter(e) { return "none" } addHighlightHCMFilter(e, t, n, r, i) { return "none" } destroy() { } } var hc = new WeakMap; class fc { constructor() { let { enableHWA: e = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; Co(this, hc, !1), this.constructor === fc && Nl("Cannot initialize BaseCanvasFactory."), To(hc, this, e) } create(e, t) { if (e <= 0 || t <= 0) throw new Error("Invalid canvas size"); const n = this._createCanvas(e, t); return { canvas: n, context: n.getContext("2d", { willReadFrequently: !Mo(hc, this) }) } } reset(e, t, n) { if (!e.canvas) throw new Error("Canvas is not specified"); if (t <= 0 || n <= 0) throw new Error("Invalid canvas size"); e.canvas.width = t, e.canvas.height = n } destroy(e) { if (!e.canvas) throw new Error("Canvas is not specified"); e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null } _createCanvas(e, t) { Nl("Abstract method `_createCanvas` called.") } } class pc { constructor(e) { let { baseUrl: t = null, isCompressed: n = !0 } = e; this.constructor === pc && Nl("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = n } async fetch(e) { let { name: t } = e; if (!this.baseUrl) throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.'); if (!t) throw new Error("CMap name must be specified."); const n = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), r = this.isCompressed ? Sl.BINARY : Sl.NONE; return this._fetchData(n, r).catch((e => { throw new Error("Unable to load ".concat(this.isCompressed ? "binary " : "", "CMap at: ").concat(n)) })) } _fetchData(e, t) { Nl("Abstract method `_fetchData` called.") } } class mc { constructor(e) { let { baseUrl: t = null } = e; this.constructor === mc && Nl("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t } async fetch(e) { let { filename: t } = e; if (!this.baseUrl) throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.'); if (!t) throw new Error("Font filename must be specified."); const n = "".concat(this.baseUrl).concat(t); return this._fetchData(n).catch((e => { throw new Error("Unable to load font data at: ".concat(n)) })) } _fetchData(e) { Nl("Abstract method `_fetchData` called.") } } class gc { constructor() { this.constructor === gc && Nl("Cannot initialize BaseSVGFactory.") } create(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (e <= 0 || t <= 0) throw new Error("Invalid SVG dimensions"); const r = this._createSVG("svg:svg"); return r.setAttribute("version", "1.1"), n || (r.setAttribute("width", "".concat(e, "px")), r.setAttribute("height", "".concat(t, "px"))), r.setAttribute("preserveAspectRatio", "none"), r.setAttribute("viewBox", "0 0 ".concat(e, " ").concat(t)), r } createElement(e) { if ("string" !== typeof e) throw new Error("Invalid SVG element type"); return this._createSVG(e) } _createSVG(e) { Nl("Abstract method `_createSVG` called.") } } const vc = "http://www.w3.org/2000/svg"; class bc { } ro = bc, Eo(bc, "CSS", 96), Eo(bc, "PDF", 72), Eo(bc, "PDF_TO_CSS_UNITS", ro.CSS / ro.PDF); var yc = new WeakMap, wc = new WeakMap, xc = new WeakMap, _c = new WeakMap, kc = new WeakMap, Sc = new WeakMap, Ac = new WeakSet; function Ec(e) { return Mo(yc, e) || To(yc, e, new Map) } function Cc(e) { return Mo(kc, e) || To(kc, e, new Map) } function Mc(e) { if (!Mo(wc, e)) { const t = Mo(_c, e).createElement("div"), { style: n } = t; n.visibility = "hidden", n.contain = "strict", n.width = n.height = 0, n.position = "absolute", n.top = n.left = 0, n.zIndex = -1; const r = Mo(_c, e).createElementNS(vc, "svg"); r.setAttribute("width", 0), r.setAttribute("height", 0), To(wc, e, Mo(_c, e).createElementNS(vc, "defs")), t.append(r), r.append(Mo(wc, e)), Mo(_c, e).body.append(t) } return Mo(wc, e) } function Tc(e) { if (1 === e.length) { const t = e[0], n = new Array(256); for (let e = 0; e < 256; e++)n[e] = t[e] / 255; const r = n.join(","); return [r, r, r] } const [t, n, r] = e, i = new Array(256), a = new Array(256), s = new Array(256); for (let o = 0; o < 256; o++)i[o] = t[o] / 255, a[o] = n[o] / 255, s[o] = r[o] / 255; return [i.join(","), a.join(","), s.join(",")] } function Pc(e) { const t = Mo(_c, this).createElementNS(vc, "feColorMatrix"); t.setAttribute("type", "matrix"), t.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e.append(t) } function Rc(e) { const t = Mo(_c, this).createElementNS(vc, "feColorMatrix"); t.setAttribute("type", "matrix"), t.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e.append(t) } function Nc(e) { const t = Mo(_c, this).createElementNS(vc, "filter"); return t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("id", e), ko(Ac, this, Mc).append(t), t } function Lc(e, t, n) { const r = Mo(_c, this).createElementNS(vc, t); r.setAttribute("type", "discrete"), r.setAttribute("tableValues", n), e.append(r) } function Ic(e, t, n, r) { const i = Mo(_c, this).createElementNS(vc, "feComponentTransfer"); r.append(i), _o(Ac, this, Lc).call(this, i, "feFuncR", e), _o(Ac, this, Lc).call(this, i, "feFuncG", t), _o(Ac, this, Lc).call(this, i, "feFuncB", n) } function Dc(e, t) { const n = Mo(_c, this).createElementNS(vc, "feComponentTransfer"); t.append(n), _o(Ac, this, Lc).call(this, n, "feFuncA", e) } function Oc(e) { return ko(Ac, this, Mc).style.color = e, eu(getComputedStyle(ko(Ac, this, Mc)).getPropertyValue("color")) } async function jc(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "text"; if (Yc(e, document.baseURI)) { const n = await fetch(e); if (!n.ok) throw new Error(n.statusText); switch (t) { case "arraybuffer": return n.arrayBuffer(); case "blob": return n.blob(); case "json": return n.json() }return n.text() } return new Promise(((n, r) => { const i = new XMLHttpRequest; i.open("GET", e, !0), i.responseType = t, i.onreadystatechange = () => { if (i.readyState === XMLHttpRequest.DONE) if (200 !== i.status && 0 !== i.status) r(new Error(i.statusText)); else { switch (t) { case "arraybuffer": case "blob": case "json": return void n(i.response) }n(i.responseText) } }, i.send(null) })) } class Fc extends pc { _fetchData(e, t) { return jc(e, this.isCompressed ? "arraybuffer" : "text").then((e => ({ cMapData: e instanceof ArrayBuffer ? new Uint8Array(e) : ql(e), compressionType: t }))) } } class zc extends mc { _fetchData(e) { return jc(e, "arraybuffer").then((e => new Uint8Array(e))) } } class Wc extends gc { _createSVG(e) { return document.createElementNS(vc, e) } } class Bc { constructor(e) { let { viewBox: t, scale: n, rotation: r, offsetX: i = 0, offsetY: a = 0, dontFlip: s = !1 } = e; this.viewBox = t, this.scale = n, this.rotation = r, this.offsetX = i, this.offsetY = a; const o = (t[2] + t[0]) / 2, l = (t[3] + t[1]) / 2; let c, u, d, h, f, p, m, g; switch (r %= 360, r < 0 && (r += 360), r) { case 180: c = -1, u = 0, d = 0, h = 1; break; case 90: c = 0, u = 1, d = 1, h = 0; break; case 270: c = 0, u = -1, d = -1, h = 0; break; case 0: c = 1, u = 0, d = 0, h = -1; break; default: throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.") }s && (d = -d, h = -h), 0 === c ? (f = Math.abs(l - t[1]) * n + i, p = Math.abs(o - t[0]) * n + a, m = (t[3] - t[1]) * n, g = (t[2] - t[0]) * n) : (f = Math.abs(o - t[0]) * n + i, p = Math.abs(l - t[1]) * n + a, m = (t[2] - t[0]) * n, g = (t[3] - t[1]) * n), this.transform = [c * n, u * n, d * n, h * n, f - c * n * o - d * n * l, p - u * n * o - h * n * l], this.width = m, this.height = g } get rawDims() { const { viewBox: e } = this; return Dl(this, "rawDims", { pageWidth: e[2] - e[0], pageHeight: e[3] - e[1], pageX: e[0], pageY: e[1] }) } clone() { let { scale: e = this.scale, rotation: t = this.rotation, offsetX: n = this.offsetX, offsetY: r = this.offsetY, dontFlip: i = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return new Bc({ viewBox: this.viewBox.slice(), scale: e, rotation: t, offsetX: n, offsetY: r, dontFlip: i }) } convertToViewportPoint(e, t) { return Kl.applyTransform([e, t], this.transform) } convertToViewportRectangle(e) { const t = Kl.applyTransform([e[0], e[1]], this.transform), n = Kl.applyTransform([e[2], e[3]], this.transform); return [t[0], t[1], n[0], n[1]] } convertToPdfPoint(e, t) { return Kl.applyInverseTransform([e, t], this.transform) } } class Hc extends Ol { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; super(e, "RenderingCancelledException"), this.extraDelay = t } } function Uc(e) { const t = e.length; let n = 0; for (; n < t && "" === e[n].trim();)n++; return "data:" === e.substring(n, n + 5).toLowerCase() } function Vc(e) { return "string" === typeof e && /\.pdf$/i.test(e) } function qc(e) { return [e] = e.split(/[#?]/, 1), e.substring(e.lastIndexOf("/") + 1) } function Gc(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "document.pdf"; if ("string" !== typeof e) return t; if (Uc(e)) return Rl('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t; const n = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, r = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(e); let i = n.exec(r[1]) || n.exec(r[2]) || n.exec(r[3]); if (i && (i = i[0], i.includes("%"))) try { i = n.exec(decodeURIComponent(i))[0] } catch { } return i || t } class Xc { constructor() { Eo(this, "started", Object.create(null)), Eo(this, "times", []) } time(e) { e in this.started && Rl("Timer is already running for ".concat(e)), this.started[e] = Date.now() } timeEnd(e) { e in this.started || Rl("Timer has not been started for ".concat(e)), this.times.push({ name: e, start: this.started[e], end: Date.now() }), delete this.started[e] } toString() { const e = []; let t = 0; for (const { name: n } of this.times) t = Math.max(n.length, t); for (const { name: n, start: r, end: i } of this.times) e.push("".concat(n.padEnd(t), " ").concat(i - r, "ms\n")); return e.join("") } } function Yc(e, t) { try { const { protocol: n } = t ? new URL(e, t) : new URL(e); return "http:" === n || "https:" === n } catch { return !1 } } function Kc(e) { e.preventDefault() } function Qc(e) { console.log("Deprecated API usage: " + e) } let $c; class Jc { static toDateObject(e) { if (!e || "string" !== typeof e) return null; $c || ($c = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?")); const t = $c.exec(e); if (!t) return null; const n = parseInt(t[1], 10); let r = parseInt(t[2], 10); r = r >= 1 && r <= 12 ? r - 1 : 0; let i = parseInt(t[3], 10); i = i >= 1 && i <= 31 ? i : 1; let a = parseInt(t[4], 10); a = a >= 0 && a <= 23 ? a : 0; let s = parseInt(t[5], 10); s = s >= 0 && s <= 59 ? s : 0; let o = parseInt(t[6], 10); o = o >= 0 && o <= 59 ? o : 0; const l = t[7] || "Z"; let c = parseInt(t[8], 10); c = c >= 0 && c <= 23 ? c : 0; let u = parseInt(t[9], 10) || 0; return u = u >= 0 && u <= 59 ? u : 0, "-" === l ? (a += c, s += u) : "+" === l && (a -= c, s -= u), new Date(Date.UTC(n, r, i, a, s, o)) } } function Zc(e, t) { let { scale: n = 1, rotation: r = 0 } = t; const { width: i, height: a } = e.attributes.style, s = [0, 0, parseInt(i), parseInt(a)]; return new Bc({ viewBox: s, scale: n, rotation: r }) } function eu(e) { if (e.startsWith("#")) { const t = parseInt(e.slice(1), 16); return [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t] } return e.startsWith("rgb(") ? e.slice(4, -1).split(",").map((e => parseInt(e))) : e.startsWith("rgba(") ? e.slice(5, -1).split(",").map((e => parseInt(e))).slice(0, 3) : (Rl('Not a valid color format: "'.concat(e, '"')), [0, 0, 0]) } function tu(e) { const { a: t, b: n, c: r, d: i, e: a, f: s } = e.getTransform(); return [t, n, r, i, a, s] } function nu(e) { const { a: t, b: n, c: r, d: i, e: a, f: s } = e.getTransform().invertSelf(); return [t, n, r, i, a, s] } function ru(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; if (t instanceof Bc) { const { pageWidth: r, pageHeight: i } = t.rawDims, { style: a } = e, s = Xl.isCSSRoundSupported, o = "var(--scale-factor) * ".concat(r, "px"), l = "var(--scale-factor) * ".concat(i, "px"), c = s ? "round(".concat(o, ", 1px)") : "calc(".concat(o, ")"), u = s ? "round(".concat(l, ", 1px)") : "calc(".concat(l, ")"); n && t.rotation % 180 !== 0 ? (a.width = u, a.height = c) : (a.width = c, a.height = u) } r && e.setAttribute("data-main-rotation", t.rotation) } var iu = new WeakMap, au = new WeakMap, su = new WeakMap, ou = new WeakMap, lu = new WeakSet; class cu { constructor(e) { xo(this, lu), Co(this, iu, null), Co(this, au, null), Co(this, su, void 0), Co(this, ou, null), To(su, this, e) } render() { const e = To(iu, this, document.createElement("div")); e.className = "editToolbar", e.setAttribute("role", "toolbar"); const t = Mo(su, this)._uiManager._signal; e.addEventListener("contextmenu", Kc, { signal: t }), e.addEventListener("pointerdown", uu, { signal: t }); const n = To(ou, this, document.createElement("div")); n.className = "buttons", e.append(n); const r = Mo(su, this).toolbarPosition; if (r) { const { style: t } = e, n = "ltr" === Mo(su, this)._uiManager.direction ? 1 - r[0] : r[0]; t.insetInlineEnd = "".concat(100 * n, "%"), t.top = "calc(".concat(100 * r[1], "% + var(--editor-toolbar-vert-offset))") } return _o(lu, this, pu).call(this), e } hide() { var e; Mo(iu, this).classList.add("hidden"), null === (e = Mo(au, this)) || void 0 === e || e.hideDropdown() } show() { Mo(iu, this).classList.remove("hidden") } addAltTextButton(e) { _o(lu, this, fu).call(this, e), Mo(ou, this).prepend(e, ko(lu, this, mu)) } addColorPicker(e) { To(au, this, e); const t = e.renderButton(); _o(lu, this, fu).call(this, t), Mo(ou, this).prepend(t, ko(lu, this, mu)) } remove() { var e; Mo(iu, this).remove(), null === (e = Mo(au, this)) || void 0 === e || e.destroy(), To(au, this, null) } } function uu(e) { e.stopPropagation() } function du(e) { Mo(su, this)._focusEventsAllowed = !1, e.preventDefault(), e.stopPropagation() } function hu(e) { Mo(su, this)._focusEventsAllowed = !0, e.preventDefault(), e.stopPropagation() } function fu(e) { const t = Mo(su, this)._uiManager._signal; e.addEventListener("focusin", _o(lu, this, du).bind(this), { capture: !0, signal: t }), e.addEventListener("focusout", _o(lu, this, hu).bind(this), { capture: !0, signal: t }), e.addEventListener("contextmenu", Kc, { signal: t }) } function pu() { const e = document.createElement("button"); e.className = "delete", e.tabIndex = 0, e.setAttribute("data-l10n-id", "pdfjs-editor-remove-".concat(Mo(su, this).editorType, "-button")), _o(lu, this, fu).call(this, e), e.addEventListener("click", (e => { Mo(su, this)._uiManager.delete() }), { signal: Mo(su, this)._uiManager._signal }), Mo(ou, this).append(e) } function mu(e) { const t = document.createElement("div"); return t.className = "divider", t } var gu = new WeakMap, vu = new WeakMap, bu = new WeakMap, yu = new WeakSet; class wu { constructor(e) { xo(this, yu), Co(this, gu, null), Co(this, vu, null), Co(this, bu, void 0), To(bu, this, e) } show(e, t, n) { const [r, i] = _o(yu, this, _u).call(this, t, n), { style: a } = Mo(vu, this) || To(vu, this, _o(yu, this, xu).call(this)); e.append(Mo(vu, this)), a.insetInlineEnd = "".concat(100 * r, "%"), a.top = "calc(".concat(100 * i, "% + var(--editor-toolbar-vert-offset))") } hide() { Mo(vu, this).remove() } } function xu() { const e = To(vu, this, document.createElement("div")); e.className = "editToolbar", e.setAttribute("role", "toolbar"), e.addEventListener("contextmenu", Kc, { signal: Mo(bu, this)._signal }); const t = To(gu, this, document.createElement("div")); return t.className = "buttons", e.append(t), _o(yu, this, ku).call(this), e } function _u(e, t) { let n = 0, r = 0; for (const i of e) { const e = i.y + i.height; if (e < n) continue; const a = i.x + (t ? i.width : 0); e > n ? (r = a, n = e) : t ? a > r && (r = a) : a < r && (r = a) } return [t ? 1 - r : r, n] } function ku() { const e = document.createElement("button"); e.className = "highlightButton", e.tabIndex = 0, e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1"); const t = document.createElement("span"); e.append(t), t.className = "visuallyHidden", t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label"); const n = Mo(bu, this)._signal; e.addEventListener("contextmenu", Kc, { signal: n }), e.addEventListener("click", (() => { Mo(bu, this).highlightSelection("floating_button") }), { signal: n }), Mo(gu, this).append(e) } function Su(e, t, n) { for (const r of n) t.addEventListener(r, e[r].bind(e)) } var Au = new WeakMap; class Eu { constructor() { Co(this, Au, 0) } get id() { var e, t; return "".concat("pdfjs_internal_editor_").concat((To(Au, this, (e = Mo(Au, this), t = e++, e)), t)) } } var Cu = new WeakMap, Mu = new WeakMap, Tu = new WeakMap, Pu = new WeakSet; class Ru { constructor() { xo(this, Pu), Co(this, Cu, function () { var e, t; if ("undefined" !== typeof crypto && "function" === typeof (null === (e = crypto) || void 0 === e ? void 0 : e.randomUUID)) return crypto.randomUUID(); const n = new Uint8Array(32); if ("undefined" !== typeof crypto && "function" === typeof (null === (t = crypto) || void 0 === t ? void 0 : t.getRandomValues)) crypto.getRandomValues(n); else for (let r = 0; r < 32; r++)n[r] = Math.floor(255 * Math.random()); return Vl(n) }()), Co(this, Mu, 0), Co(this, Tu, null) } static get _isSVGFittingCanvas() { const e = new OffscreenCanvas(1, 3).getContext("2d", { willReadFrequently: !0 }), t = new Image; t.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>'; return Dl(this, "_isSVGFittingCanvas", t.decode().then((() => (e.drawImage(t, 0, 0, 1, 1, 0, 0, 1, 3), 0 === new Uint32Array(e.getImageData(0, 0, 1, 1).data.buffer)[0])))) } async getFromFile(e) { const { lastModified: t, name: n, size: r, type: i } = e; return _o(Pu, this, Nu).call(this, "".concat(t, "_").concat(n, "_").concat(r, "_").concat(i), e) } async getFromUrl(e) { return _o(Pu, this, Nu).call(this, e, e) } async getFromId(e) { Mo(Tu, this) || To(Tu, this, new Map); const t = Mo(Tu, this).get(e); return t ? t.bitmap ? (t.refCounter += 1, t) : t.file ? this.getFromFile(t.file) : this.getFromUrl(t.url) : null } getSvgUrl(e) { const t = Mo(Tu, this).get(e); return null !== t && void 0 !== t && t.isSvg ? t.svgUrl : null } deleteId(e) { Mo(Tu, this) || To(Tu, this, new Map); const t = Mo(Tu, this).get(e); t && (t.refCounter -= 1, 0 === t.refCounter && (t.bitmap = null)) } isValidId(e) { return e.startsWith("image_".concat(Mo(Cu, this), "_")) } } async function Nu(e, t) { var n; Mo(Tu, this) || To(Tu, this, new Map); let r = Mo(Tu, this).get(e); if (null === r) return null; if (null !== (n = r) && void 0 !== n && n.bitmap) return r.refCounter += 1, r; try { var i, a; let e; if (r || (r = { bitmap: null, id: "image_".concat(Mo(Cu, this), "_").concat((To(Mu, this, (i = Mo(Mu, this), a = i++, i)), a)), refCounter: 0, isSvg: !1 }), "string" === typeof t ? (r.url = t, e = await jc(t, "blob")) : e = r.file = t, "image/svg+xml" === e.type) { const t = io._isSVGFittingCanvas, n = new FileReader, i = new Image, a = new Promise(((e, a) => { i.onload = () => { r.bitmap = i, r.isSvg = !0, e() }, n.onload = async () => { const e = r.svgUrl = n.result; i.src = await t ? "".concat(e, "#svgView(preserveAspectRatio(none))") : e }, i.onerror = n.onerror = a })); n.readAsDataURL(e), await a } else r.bitmap = await createImageBitmap(e); r.refCounter = 1 } catch ($A) { console.error($A), r = null } return Mo(Tu, this).set(e, r), r && Mo(Tu, this).set(r.id, r), r } io = Ru; var Lu = new WeakMap, Iu = new WeakMap, Du = new WeakMap, Ou = new WeakMap; class ju { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 128; Co(this, Lu, []), Co(this, Iu, !1), Co(this, Du, void 0), Co(this, Ou, -1), To(Du, this, e) } add(e) { let { cmd: t, undo: n, post: r, mustExec: i, type: a = NaN, overwriteIfSameType: s = !1, keepUndo: o = !1 } = e; if (i && t(), Mo(Iu, this)) return; const l = { cmd: t, undo: n, post: r, type: a }; if (-1 === Mo(Ou, this)) return Mo(Lu, this).length > 0 && (Mo(Lu, this).length = 0), To(Ou, this, 0), void Mo(Lu, this).push(l); if (s && Mo(Lu, this)[Mo(Ou, this)].type === a) return o && (l.undo = Mo(Lu, this)[Mo(Ou, this)].undo), void (Mo(Lu, this)[Mo(Ou, this)] = l); const c = Mo(Ou, this) + 1; c === Mo(Du, this) ? Mo(Lu, this).splice(0, 1) : (To(Ou, this, c), c < Mo(Lu, this).length && Mo(Lu, this).splice(c)), Mo(Lu, this).push(l) } undo() { if (-1 === Mo(Ou, this)) return; To(Iu, this, !0); const { undo: e, post: t } = Mo(Lu, this)[Mo(Ou, this)]; e(), null === t || void 0 === t || t(), To(Iu, this, !1), To(Ou, this, Mo(Ou, this) - 1) } redo() { if (Mo(Ou, this) < Mo(Lu, this).length - 1) { To(Ou, this, Mo(Ou, this) + 1), To(Iu, this, !0); const { cmd: e, post: t } = Mo(Lu, this)[Mo(Ou, this)]; e(), null === t || void 0 === t || t(), To(Iu, this, !1) } } hasSomethingToUndo() { return -1 !== Mo(Ou, this) } hasSomethingToRedo() { return Mo(Ou, this) < Mo(Lu, this).length - 1 } destroy() { To(Lu, this, null) } } var Fu = new WeakSet; class zu { constructor(e) { xo(this, Fu), this.buffer = [], this.callbacks = new Map, this.allKeys = new Set; const { isMac: t } = Xl.platform; for (const [n, r, i = {}] of e) for (const e of n) { const n = e.startsWith("mac+"); t && n ? (this.callbacks.set(e.slice(4), { callback: r, options: i }), this.allKeys.add(e.split("+").at(-1))) : t || n || (this.callbacks.set(e, { callback: r, options: i }), this.allKeys.add(e.split("+").at(-1))) } } exec(e, t) { if (!this.allKeys.has(t.key)) return; const n = this.callbacks.get(_o(Fu, this, Wu).call(this, t)); if (!n) return; const { callback: r, options: { bubbles: i = !1, args: a = [], checker: s = null } } = n; s && !s(e, t) || (r.bind(e, ...a, t)(), i || (t.stopPropagation(), t.preventDefault())) } } function Wu(e) { e.altKey && this.buffer.push("alt"), e.ctrlKey && this.buffer.push("ctrl"), e.metaKey && this.buffer.push("meta"), e.shiftKey && this.buffer.push("shift"), this.buffer.push(e.key); const t = this.buffer.join("+"); return this.buffer.length = 0, t } class Bu { get _colors() { const e = new Map([["CanvasText", null], ["Canvas", null]]); return function (e) { const t = document.createElement("span"); t.style.visibility = "hidden", document.body.append(t); for (const n of e.keys()) { t.style.color = n; const r = window.getComputedStyle(t).color; e.set(n, eu(r)) } t.remove() }(e), Dl(this, "_colors", e) } convert(e) { const t = eu(e); if (!window.matchMedia("(forced-colors: active)").matches) return t; for (const [n, r] of this._colors) if (r.every(((e, n) => e === t[n]))) return Bu._colorsMapping.get(n); return t } getHexCode(e) { const t = this._colors.get(e); return t ? Kl.makeHexColor(...t) : e } } Eo(Bu, "_colorsMapping", new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]])); var Hu = new WeakMap, Uu = new WeakMap, Vu = new WeakMap, qu = new WeakMap, Gu = new WeakMap, Xu = new WeakMap, Yu = new WeakMap, Ku = new WeakMap, Qu = new WeakMap, $u = new WeakMap, Ju = new WeakMap, Zu = new WeakMap, ed = new WeakMap, td = new WeakMap, nd = new WeakMap, rd = new WeakMap, id = new WeakMap, ad = new WeakMap, sd = new WeakMap, od = new WeakMap, ld = new WeakMap, cd = new WeakMap, ud = new WeakMap, dd = new WeakMap, hd = new WeakMap, fd = new WeakMap, pd = new WeakMap, md = new WeakMap, gd = new WeakMap, vd = new WeakMap, bd = new WeakMap, yd = new WeakMap, wd = new WeakMap, xd = new WeakMap, _d = new WeakMap, kd = new WeakMap, Sd = new WeakMap, Ad = new WeakMap, Ed = new WeakMap, Cd = new WeakMap, Md = new WeakMap, Td = new WeakMap, Pd = new WeakMap, Rd = new WeakMap, Nd = new WeakMap, Ld = new WeakMap, Id = new WeakSet; class Dd { static get _keyboardManager() { const e = Dd.prototype, t = e => Mo(Nd, e).contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && e.hasSomethingToControl(), n = (e, t) => { let { target: n } = t; if (n instanceof HTMLInputElement) { const { type: e } = n; return "text" !== e && "number" !== e } return !0 }, r = this.TRANSLATE_SMALL, i = this.TRANSLATE_BIG; return Dl(this, "_keyboardManager", new zu([[["ctrl+a", "mac+meta+a"], e.selectAll, { checker: n }], [["ctrl+z", "mac+meta+z"], e.undo, { checker: n }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e.redo, { checker: n }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e.delete, { checker: n }], [["Enter", "mac+Enter"], e.addNewEditorFromKeyboard, { checker: (e, t) => { let { target: n } = t; return !(n instanceof HTMLButtonElement) && Mo(Nd, e).contains(n) && !e.isEnterHandled } }], [[" ", "mac+ "], e.addNewEditorFromKeyboard, { checker: (e, t) => { let { target: n } = t; return !(n instanceof HTMLButtonElement) && Mo(Nd, e).contains(document.activeElement) } }], [["Escape", "mac+Escape"], e.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e.translateSelectedEditors, { args: [-r, 0], checker: t }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e.translateSelectedEditors, { args: [-i, 0], checker: t }], [["ArrowRight", "mac+ArrowRight"], e.translateSelectedEditors, { args: [r, 0], checker: t }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e.translateSelectedEditors, { args: [i, 0], checker: t }], [["ArrowUp", "mac+ArrowUp"], e.translateSelectedEditors, { args: [0, -r], checker: t }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e.translateSelectedEditors, { args: [0, -i], checker: t }], [["ArrowDown", "mac+ArrowDown"], e.translateSelectedEditors, { args: [0, r], checker: t }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e.translateSelectedEditors, { args: [0, i], checker: t }]])) } constructor(e, t, n, r, i, a, s, o, l) { xo(this, Id), Co(this, Hu, new AbortController), Co(this, Uu, null), Co(this, Vu, new Map), Co(this, qu, new Map), Co(this, Gu, null), Co(this, Xu, null), Co(this, Yu, null), Co(this, Ku, new ju), Co(this, Qu, 0), Co(this, $u, new Set), Co(this, Ju, null), Co(this, Zu, null), Co(this, ed, new Set), Co(this, td, !1), Co(this, nd, null), Co(this, rd, null), Co(this, id, null), Co(this, ad, !1), Co(this, sd, null), Co(this, od, new Eu), Co(this, ld, !1), Co(this, cd, !1), Co(this, ud, null), Co(this, dd, null), Co(this, hd, null), Co(this, fd, Vo.NONE), Co(this, pd, new Set), Co(this, md, null), Co(this, gd, null), Co(this, vd, null), Co(this, bd, this.blur.bind(this)), Co(this, yd, this.focus.bind(this)), Co(this, wd, this.copy.bind(this)), Co(this, xd, this.cut.bind(this)), Co(this, _d, this.paste.bind(this)), Co(this, kd, this.keydown.bind(this)), Co(this, Sd, this.keyup.bind(this)), Co(this, Ad, this.onEditingAction.bind(this)), Co(this, Ed, this.onPageChanging.bind(this)), Co(this, Cd, this.onScaleChanging.bind(this)), Co(this, Md, this.onRotationChanging.bind(this)), Co(this, Td, { isEditing: !1, isEmpty: !0, hasSomethingToUndo: !1, hasSomethingToRedo: !1, hasSelectedEditor: !1, hasSelectedText: !1 }), Co(this, Pd, [0, 0]), Co(this, Rd, null), Co(this, Nd, null), Co(this, Ld, null), this._signal = Mo(Hu, this).signal, To(Nd, this, e), To(Ld, this, t), To(Gu, this, n), this._eventBus = r, this._eventBus._on("editingaction", Mo(Ad, this)), this._eventBus._on("pagechanging", Mo(Ed, this)), this._eventBus._on("scalechanging", Mo(Cd, this)), this._eventBus._on("rotationchanging", Mo(Md, this)), _o(Id, this, Wd).call(this), _o(Id, this, Xd).call(this), _o(Id, this, Ud).call(this), To(Xu, this, i.annotationStorage), To(nd, this, i.filterFactory), To(gd, this, a), To(id, this, s || null), To(td, this, o), To(hd, this, l || null), this.viewParameters = { realScale: bc.PDF_TO_CSS_UNITS, rotation: 0 }, this.isShiftKeyDown = !1 } destroy() { var e, t, n; null === (e = Mo(Hu, this)) || void 0 === e || e.abort(), To(Hu, this, null), this._signal = null, this._eventBus._off("editingaction", Mo(Ad, this)), this._eventBus._off("pagechanging", Mo(Ed, this)), this._eventBus._off("scalechanging", Mo(Cd, this)), this._eventBus._off("rotationchanging", Mo(Md, this)); for (const r of Mo(qu, this).values()) r.destroy(); Mo(qu, this).clear(), Mo(Vu, this).clear(), Mo(ed, this).clear(), To(Uu, this, null), Mo(pd, this).clear(), Mo(Ku, this).destroy(), null === (t = Mo(Gu, this)) || void 0 === t || t.destroy(), null === (n = Mo(sd, this)) || void 0 === n || n.hide(), To(sd, this, null), Mo(rd, this) && (clearTimeout(Mo(rd, this)), To(rd, this, null)), Mo(Rd, this) && (clearTimeout(Mo(Rd, this)), To(Rd, this, null)) } async mlGuess(e) { var t; return (null === (t = Mo(hd, this)) || void 0 === t ? void 0 : t.guess(e)) || null } get hasMLManager() { return !!Mo(hd, this) } get hcmFilter() { return Dl(this, "hcmFilter", Mo(gd, this) ? Mo(nd, this).addHCMFilter(Mo(gd, this).foreground, Mo(gd, this).background) : "none") } get direction() { return Dl(this, "direction", getComputedStyle(Mo(Nd, this)).direction) } get highlightColors() { return Dl(this, "highlightColors", Mo(id, this) ? new Map(Mo(id, this).split(",").map((e => e.split("=").map((e => e.trim()))))) : null) } get highlightColorNames() { return Dl(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e => e.reverse()))) : null) } setMainHighlightColorPicker(e) { To(dd, this, e) } editAltText(e) { var t; null === (t = Mo(Gu, this)) || void 0 === t || t.editAltText(this, e) } onPageChanging(e) { let { pageNumber: t } = e; To(Qu, this, t - 1) } focusMainContainer() { Mo(Nd, this).focus() } findParent(e, t) { for (const n of Mo(qu, this).values()) { const { x: r, y: i, width: a, height: s } = n.div.getBoundingClientRect(); if (e >= r && e <= r + a && t >= i && t <= i + s) return n } return null } disableUserSelect() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; Mo(Ld, this).classList.toggle("noUserSelect", e) } addShouldRescale(e) { Mo(ed, this).add(e) } removeShouldRescale(e) { Mo(ed, this).delete(e) } onScaleChanging(e) { let { scale: t } = e; this.commitOrRemove(), this.viewParameters.realScale = t * bc.PDF_TO_CSS_UNITS; for (const n of Mo(ed, this)) n.onScaleChanging() } onRotationChanging(e) { let { pagesRotation: t } = e; this.commitOrRemove(), this.viewParameters.rotation = t } highlightSelection() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; const t = document.getSelection(); if (!t || t.isCollapsed) return; const { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: a } = t, s = t.toString(), o = _o(Id, this, Od).call(this, t).closest(".textLayer"), l = this.getSelectionBoxes(o); if (l) { t.empty(), Mo(fd, this) === Vo.NONE && (this._eventBus.dispatch("showannotationeditorui", { source: this, mode: Vo.HIGHLIGHT }), this.showAllEditors("highlight", !0, !0)); for (const t of Mo(qu, this).values()) if (t.hasTextLayer(o)) { t.createAndAddNewEditor({ x: 0, y: 0 }, !1, { methodOfCreation: e, boxes: l, anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: a, text: s }); break } } } addToAnnotationStorage(e) { e.isEmpty() || !Mo(Xu, this) || Mo(Xu, this).has(e.id) || Mo(Xu, this).setValue(e.id, e) } blur() { if (this.isShiftKeyDown = !1, Mo(ad, this) && (To(ad, this, !1), _o(Id, this, zd).call(this, "main_toolbar")), !this.hasSelection) return; const { activeElement: e } = document; for (const t of Mo(pd, this)) if (t.div.contains(e)) { To(ud, this, [t, e]), t._focusEventsAllowed = !1; break } } focus() { if (!Mo(ud, this)) return; const [e, t] = Mo(ud, this); To(ud, this, null), t.addEventListener("focusin", (() => { e._focusEventsAllowed = !0 }), { once: !0, signal: this._signal }), t.focus() } addEditListeners() { _o(Id, this, Ud).call(this), _o(Id, this, qd).call(this) } removeEditListeners() { _o(Id, this, Vd).call(this), _o(Id, this, Gd).call(this) } dragOver(e) { for (const { type: t } of e.dataTransfer.items) for (const n of Mo(Zu, this)) if (n.isHandlingMimeForPasting(t)) return e.dataTransfer.dropEffect = "copy", void e.preventDefault() } drop(e) { for (const t of e.dataTransfer.items) for (const n of Mo(Zu, this)) if (n.isHandlingMimeForPasting(t.type)) return n.paste(t, this.currentLayer), void e.preventDefault() } copy(e) { var t; if (e.preventDefault(), null === (t = Mo(Uu, this)) || void 0 === t || t.commitOrRemove(), !this.hasSelection) return; const n = []; for (const r of Mo(pd, this)) { const e = r.serialize(!0); e && n.push(e) } 0 !== n.length && e.clipboardData.setData("application/pdfjs", JSON.stringify(n)) } cut(e) { this.copy(e), this.delete() } paste(e) { e.preventDefault(); const { clipboardData: t } = e; for (const a of t.items) for (const e of Mo(Zu, this)) if (e.isHandlingMimeForPasting(a.type)) return void e.paste(a, this.currentLayer); let n = t.getData("application/pdfjs"); if (!n) return; try { n = JSON.parse(n) } catch (i) { return void Rl('paste: "'.concat(i.message, '".')) } if (!Array.isArray(n)) return; this.unselectAll(); const r = this.currentLayer; try { const e = []; for (const a of n) { const t = r.deserialize(a); if (!t) return; e.push(t) } const t = () => { for (const t of e) _o(Id, this, Jd).call(this, t); _o(Id, this, th).call(this, e) }, i = () => { for (const t of e) t.remove() }; this.addCommands({ cmd: t, undo: i, mustExec: !0 }) } catch (i) { Rl('paste: "'.concat(i.message, '".')) } } keydown(e) { this.isShiftKeyDown || "Shift" !== e.key || (this.isShiftKeyDown = !0), Mo(fd, this) === Vo.NONE || this.isEditorHandlingKeyboard || Dd._keyboardManager.exec(this, e) } keyup(e) { this.isShiftKeyDown && "Shift" === e.key && (this.isShiftKeyDown = !1, Mo(ad, this) && (To(ad, this, !1), _o(Id, this, zd).call(this, "main_toolbar"))) } onEditingAction(e) { let { name: t } = e; switch (t) { case "undo": case "redo": case "delete": case "selectAll": this[t](); break; case "highlightSelection": this.highlightSelection("context_menu") } } setEditingState(e) { e ? (_o(Id, this, Bd).call(this), _o(Id, this, qd).call(this), _o(Id, this, Yd).call(this, { isEditing: Mo(fd, this) !== Vo.NONE, isEmpty: _o(Id, this, eh).call(this), hasSomethingToUndo: Mo(Ku, this).hasSomethingToUndo(), hasSomethingToRedo: Mo(Ku, this).hasSomethingToRedo(), hasSelectedEditor: !1 })) : (_o(Id, this, Hd).call(this), _o(Id, this, Gd).call(this), _o(Id, this, Yd).call(this, { isEditing: !1 }), this.disableUserSelect(!1)) } registerEditorTypes(e) { if (!Mo(Zu, this)) { To(Zu, this, e); for (const e of Mo(Zu, this)) _o(Id, this, Kd).call(this, e.defaultPropertiesToUpdate) } } getId() { return Mo(od, this).id } get currentLayer() { return Mo(qu, this).get(Mo(Qu, this)) } getLayer(e) { return Mo(qu, this).get(e) } get currentPageIndex() { return Mo(Qu, this) } addLayer(e) { Mo(qu, this).set(e.pageIndex, e), Mo(ld, this) ? e.enable() : e.disable() } removeLayer(e) { Mo(qu, this).delete(e.pageIndex) } updateMode(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (Mo(fd, this) !== e) { if (To(fd, this, e), e === Vo.NONE) return this.setEditingState(!1), void _o(Id, this, $d).call(this); this.setEditingState(!0), _o(Id, this, Qd).call(this), this.unselectAll(); for (const t of Mo(qu, this).values()) t.updateMode(e); if (t || !n) { if (t) for (const e of Mo(Vu, this).values()) if (e.annotationElementId === t) { this.setSelected(e), e.enterInEditMode(); break } } else this.addNewEditorFromKeyboard() } } addNewEditorFromKeyboard() { this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor() } updateToolbar(e) { e !== Mo(fd, this) && this._eventBus.dispatch("switchannotationeditormode", { source: this, mode: e }) } updateParams(e, t) { var n; if (Mo(Zu, this)) { switch (e) { case qo.CREATE: return void this.currentLayer.addNewEditor(); case qo.HIGHLIGHT_DEFAULT_COLOR: null === (n = Mo(dd, this)) || void 0 === n || n.updateColor(t); break; case qo.HIGHLIGHT_SHOW_ALL: this._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: { type: "highlight", action: "toggle_visibility" } } }), (Mo(vd, this) || To(vd, this, new Map)).set(e, t), this.showAllEditors("highlight", t) }for (const n of Mo(pd, this)) n.updateParams(e, t); for (const n of Mo(Zu, this)) n.updateDefaultParams(e, t) } } showAllEditors(e, t) { var n, r; for (const i of Mo(Vu, this).values()) i.editorType === e && i.show(t); (null === (n = null === (r = Mo(vd, this)) || void 0 === r ? void 0 : r.get(qo.HIGHLIGHT_SHOW_ALL)) || void 0 === n || n) !== t && _o(Id, this, Kd).call(this, [[qo.HIGHLIGHT_SHOW_ALL, t]]) } enableWaiting() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (Mo(cd, this) !== e) { To(cd, this, e); for (const t of Mo(qu, this).values()) e ? t.disableClick() : t.enableClick(), t.div.classList.toggle("waiting", e) } } getEditors(e) { const t = []; for (const n of Mo(Vu, this).values()) n.pageIndex === e && t.push(n); return t } getEditor(e) { return Mo(Vu, this).get(e) } addEditor(e) { Mo(Vu, this).set(e.id, e) } removeEditor(e) { var t; (e.div.contains(document.activeElement) && (Mo(rd, this) && clearTimeout(Mo(rd, this)), To(rd, this, setTimeout((() => { this.focusMainContainer(), To(rd, this, null) }), 0))), Mo(Vu, this).delete(e.id), this.unselect(e), e.annotationElementId && Mo($u, this).has(e.annotationElementId)) || (null === (t = Mo(Xu, this)) || void 0 === t || t.remove(e.id)) } addDeletedAnnotationElement(e) { Mo($u, this).add(e.annotationElementId), this.addChangedExistingAnnotation(e), e.deleted = !0 } isDeletedAnnotationElement(e) { return Mo($u, this).has(e) } removeDeletedAnnotationElement(e) { Mo($u, this).delete(e.annotationElementId), this.removeChangedExistingAnnotation(e), e.deleted = !1 } setActiveEditor(e) { Mo(Uu, this) !== e && (To(Uu, this, e), e && _o(Id, this, Kd).call(this, e.propertiesToUpdate)) } updateUI(e) { ko(Id, this, Zd) === e && _o(Id, this, Kd).call(this, e.propertiesToUpdate) } toggleSelected(e) { if (Mo(pd, this).has(e)) return Mo(pd, this).delete(e), e.unselect(), void _o(Id, this, Yd).call(this, { hasSelectedEditor: this.hasSelection }); Mo(pd, this).add(e), e.select(), _o(Id, this, Kd).call(this, e.propertiesToUpdate), _o(Id, this, Yd).call(this, { hasSelectedEditor: !0 }) } setSelected(e) { for (const t of Mo(pd, this)) t !== e && t.unselect(); Mo(pd, this).clear(), Mo(pd, this).add(e), e.select(), _o(Id, this, Kd).call(this, e.propertiesToUpdate), _o(Id, this, Yd).call(this, { hasSelectedEditor: !0 }) } isSelected(e) { return Mo(pd, this).has(e) } get firstSelectedEditor() { return Mo(pd, this).values().next().value } unselect(e) { e.unselect(), Mo(pd, this).delete(e), _o(Id, this, Yd).call(this, { hasSelectedEditor: this.hasSelection }) } get hasSelection() { return 0 !== Mo(pd, this).size } get isEnterHandled() { return 1 === Mo(pd, this).size && this.firstSelectedEditor.isEnterHandled } undo() { Mo(Ku, this).undo(), _o(Id, this, Yd).call(this, { hasSomethingToUndo: Mo(Ku, this).hasSomethingToUndo(), hasSomethingToRedo: !0, isEmpty: _o(Id, this, eh).call(this) }) } redo() { Mo(Ku, this).redo(), _o(Id, this, Yd).call(this, { hasSomethingToUndo: !0, hasSomethingToRedo: Mo(Ku, this).hasSomethingToRedo(), isEmpty: _o(Id, this, eh).call(this) }) } addCommands(e) { Mo(Ku, this).add(e), _o(Id, this, Yd).call(this, { hasSomethingToUndo: !0, hasSomethingToRedo: !1, isEmpty: _o(Id, this, eh).call(this) }) } delete() { if (this.commitOrRemove(), !this.hasSelection) return; const e = [...Mo(pd, this)]; this.addCommands({ cmd: () => { for (const t of e) t.remove() }, undo: () => { for (const t of e) _o(Id, this, Jd).call(this, t) }, mustExec: !0 }) } commitOrRemove() { var e; null === (e = Mo(Uu, this)) || void 0 === e || e.commitOrRemove() } hasSomethingToControl() { return Mo(Uu, this) || this.hasSelection } selectAll() { for (const e of Mo(pd, this)) e.commit(); _o(Id, this, th).call(this, Mo(Vu, this).values()) } unselectAll() { if ((!Mo(Uu, this) || (Mo(Uu, this).commitOrRemove(), Mo(fd, this) === Vo.NONE)) && this.hasSelection) { for (const e of Mo(pd, this)) e.unselect(); Mo(pd, this).clear(), _o(Id, this, Yd).call(this, { hasSelectedEditor: !1 }) } } translateSelectedEditors(e, t) { if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2] || this.commitOrRemove(), !this.hasSelection) return; Mo(Pd, this)[0] += e, Mo(Pd, this)[1] += t; const [n, r] = Mo(Pd, this), i = [...Mo(pd, this)]; Mo(Rd, this) && clearTimeout(Mo(Rd, this)), To(Rd, this, setTimeout((() => { To(Rd, this, null), Mo(Pd, this)[0] = Mo(Pd, this)[1] = 0, this.addCommands({ cmd: () => { for (const e of i) Mo(Vu, this).has(e.id) && e.translateInPage(n, r) }, undo: () => { for (const e of i) Mo(Vu, this).has(e.id) && e.translateInPage(-n, -r) }, mustExec: !1 }) }), 1e3)); for (const a of i) a.translateInPage(e, t) } setUpDragSession() { if (this.hasSelection) { this.disableUserSelect(!0), To(Ju, this, new Map); for (const e of Mo(pd, this)) Mo(Ju, this).set(e, { savedX: e.x, savedY: e.y, savedPageIndex: e.pageIndex, newX: 0, newY: 0, newPageIndex: -1 }) } } endDragSession() { if (!Mo(Ju, this)) return !1; this.disableUserSelect(!1); const e = Mo(Ju, this); To(Ju, this, null); let t = !1; for (const [{ x: r, y: i, pageIndex: a }, s] of e) s.newX = r, s.newY = i, s.newPageIndex = a, t || (t = r !== s.savedX || i !== s.savedY || a !== s.savedPageIndex); if (!t) return !1; const n = (e, t, n, r) => { if (Mo(Vu, this).has(e.id)) { const i = Mo(qu, this).get(r); i ? e._setParentAndPosition(i, t, n) : (e.pageIndex = r, e.x = t, e.y = n) } }; return this.addCommands({ cmd: () => { for (const [t, { newX: r, newY: i, newPageIndex: a }] of e) n(t, r, i, a) }, undo: () => { for (const [t, { savedX: r, savedY: i, savedPageIndex: a }] of e) n(t, r, i, a) }, mustExec: !0 }), !0 } dragSelectedEditors(e, t) { if (Mo(Ju, this)) for (const n of Mo(Ju, this).keys()) n.drag(e, t) } rebuild(e) { if (null === e.parent) { const t = this.getLayer(e.pageIndex); t ? (t.changeParent(e), t.addOrRebuild(e)) : (this.addEditor(e), this.addToAnnotationStorage(e), e.rebuild()) } else e.parent.addOrRebuild(e) } get isEditorHandlingKeyboard() { var e; return (null === (e = this.getActive()) || void 0 === e ? void 0 : e.shouldGetKeyboardEvents()) || 1 === Mo(pd, this).size && this.firstSelectedEditor.shouldGetKeyboardEvents() } isActive(e) { return Mo(Uu, this) === e } getActive() { return Mo(Uu, this) } getMode() { return Mo(fd, this) } get imageManager() { return Dl(this, "imageManager", new Ru) } getSelectionBoxes(e) { if (!e) return null; const t = document.getSelection(); for (let l = 0, c = t.rangeCount; l < c; l++)if (!e.contains(t.getRangeAt(l).commonAncestorContainer)) return null; const { x: n, y: r, width: i, height: a } = e.getBoundingClientRect(); let s; switch (e.getAttribute("data-main-rotation")) { case "90": s = (e, t, s, o) => ({ x: (t - r) / a, y: 1 - (e + s - n) / i, width: o / a, height: s / i }); break; case "180": s = (e, t, s, o) => ({ x: 1 - (e + s - n) / i, y: 1 - (t + o - r) / a, width: s / i, height: o / a }); break; case "270": s = (e, t, s, o) => ({ x: 1 - (t + o - r) / a, y: (e - n) / i, width: o / a, height: s / i }); break; default: s = (e, t, s, o) => ({ x: (e - n) / i, y: (t - r) / a, width: s / i, height: o / a }) }const o = []; for (let l = 0, c = t.rangeCount; l < c; l++) { const e = t.getRangeAt(l); if (!e.collapsed) for (const { x: t, y: n, width: r, height: i } of e.getClientRects()) 0 !== r && 0 !== i && o.push(s(t, n, r, i)) } return 0 === o.length ? null : o } addChangedExistingAnnotation(e) { let { annotationElementId: t, id: n } = e; (Mo(Yu, this) || To(Yu, this, new Map)).set(t, n) } removeChangedExistingAnnotation(e) { var t; let { annotationElementId: n } = e; null === (t = Mo(Yu, this)) || void 0 === t || t.delete(n) } renderAnnotationElement(e) { var t; const n = null === (t = Mo(Yu, this)) || void 0 === t ? void 0 : t.get(e.data.id); if (!n) return; const r = Mo(Xu, this).getRawValue(n); r && (Mo(fd, this) !== Vo.NONE || r.hasBeenModified) && r.renderAnnotationElement(e) } } function Od(e) { let { anchorNode: t } = e; return t.nodeType === Node.TEXT_NODE ? t.parentElement : t } function jd() { const e = document.getSelection(); if (!e || e.isCollapsed) return; const t = _o(Id, this, Od).call(this, e).closest(".textLayer"), n = this.getSelectionBoxes(t); n && (Mo(sd, this) || To(sd, this, new wu(this)), Mo(sd, this).show(t, n, "ltr" === this.direction)) } function Fd() { var e; const t = document.getSelection(); if (!t || t.isCollapsed) { var n; if (Mo(md, this)) null === (n = Mo(sd, this)) || void 0 === n || n.hide(), To(md, this, null), _o(Id, this, Yd).call(this, { hasSelectedText: !1 }); return } const { anchorNode: r } = t; if (r === Mo(md, this)) return; var i; if (_o(Id, this, Od).call(this, t).closest(".textLayer")) { if (null === (e = Mo(sd, this)) || void 0 === e || e.hide(), To(md, this, r), _o(Id, this, Yd).call(this, { hasSelectedText: !0 }), (Mo(fd, this) === Vo.HIGHLIGHT || Mo(fd, this) === Vo.NONE) && (Mo(fd, this) === Vo.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), To(ad, this, this.isShiftKeyDown), !this.isShiftKeyDown)) { const e = this._signal, t = e => { "pointerup" === e.type && 0 !== e.button || (window.removeEventListener("pointerup", t), window.removeEventListener("blur", t), "pointerup" === e.type && _o(Id, this, zd).call(this, "main_toolbar")) }; window.addEventListener("pointerup", t, { signal: e }), window.addEventListener("blur", t, { signal: e }) } } else Mo(md, this) && (null === (i = Mo(sd, this)) || void 0 === i || i.hide(), To(md, this, null), _o(Id, this, Yd).call(this, { hasSelectedText: !1 })) } function zd() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; Mo(fd, this) === Vo.HIGHLIGHT ? this.highlightSelection(e) : Mo(td, this) && _o(Id, this, jd).call(this) } function Wd() { document.addEventListener("selectionchange", _o(Id, this, Fd).bind(this), { signal: this._signal }) } function Bd() { const e = this._signal; window.addEventListener("focus", Mo(yd, this), { signal: e }), window.addEventListener("blur", Mo(bd, this), { signal: e }) } function Hd() { window.removeEventListener("focus", Mo(yd, this)), window.removeEventListener("blur", Mo(bd, this)) } function Ud() { const e = this._signal; window.addEventListener("keydown", Mo(kd, this), { signal: e }), window.addEventListener("keyup", Mo(Sd, this), { signal: e }) } function Vd() { window.removeEventListener("keydown", Mo(kd, this)), window.removeEventListener("keyup", Mo(Sd, this)) } function qd() { const e = this._signal; document.addEventListener("copy", Mo(wd, this), { signal: e }), document.addEventListener("cut", Mo(xd, this), { signal: e }), document.addEventListener("paste", Mo(_d, this), { signal: e }) } function Gd() { document.removeEventListener("copy", Mo(wd, this)), document.removeEventListener("cut", Mo(xd, this)), document.removeEventListener("paste", Mo(_d, this)) } function Xd() { const e = this._signal; document.addEventListener("dragover", this.dragOver.bind(this), { signal: e }), document.addEventListener("drop", this.drop.bind(this), { signal: e }) } function Yd(e) { Object.entries(e).some((e => { let [t, n] = e; return Mo(Td, this)[t] !== n })) && (this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(Mo(Td, this), e) }), Mo(fd, this) === Vo.HIGHLIGHT && !1 === e.hasSelectedEditor && _o(Id, this, Kd).call(this, [[qo.HIGHLIGHT_FREE, !0]])) } function Kd(e) { this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: e }) } function Qd() { if (!Mo(ld, this)) { To(ld, this, !0); for (const e of Mo(qu, this).values()) e.enable(); for (const e of Mo(Vu, this).values()) e.enable() } } function $d() { if (this.unselectAll(), Mo(ld, this)) { To(ld, this, !1); for (const e of Mo(qu, this).values()) e.disable(); for (const e of Mo(Vu, this).values()) e.disable() } } function Jd(e) { const t = Mo(qu, this).get(e.pageIndex); t ? t.addOrRebuild(e) : (this.addEditor(e), this.addToAnnotationStorage(e)) } function Zd(e) { let t = null; for (t of Mo(pd, e)); return t } function eh() { if (0 === Mo(Vu, this).size) return !0; if (1 === Mo(Vu, this).size) for (const e of Mo(Vu, this).values()) return e.isEmpty(); return !1 } function th(e) { for (const t of Mo(pd, this)) t.unselect(); Mo(pd, this).clear(); for (const t of e) t.isEmpty() || (Mo(pd, this).add(t), t.select()); _o(Id, this, Yd).call(this, { hasSelectedEditor: this.hasSelection }) } Eo(Dd, "TRANSLATE_SMALL", 1), Eo(Dd, "TRANSLATE_BIG", 10); var nh = new WeakMap, rh = new WeakMap, ih = new WeakMap, ah = new WeakMap, sh = new WeakMap, oh = new WeakMap, lh = new WeakMap, ch = new WeakSet; class uh { constructor(e) { xo(this, ch), Co(this, nh, ""), Co(this, rh, !1), Co(this, ih, null), Co(this, ah, null), Co(this, sh, null), Co(this, oh, !1), Co(this, lh, null), To(lh, this, e) } static initialize(e) { uh._l10nPromise || (uh._l10nPromise = e) } async render() { const e = To(ih, this, document.createElement("button")); e.className = "altText"; const t = await uh._l10nPromise.get("pdfjs-editor-alt-text-button-label"); e.textContent = t, e.setAttribute("aria-label", t), e.tabIndex = "0"; const n = Mo(lh, this)._uiManager._signal; e.addEventListener("contextmenu", Kc, { signal: n }), e.addEventListener("pointerdown", (e => e.stopPropagation()), { signal: n }); const r = e => { e.preventDefault(), Mo(lh, this)._uiManager.editAltText(Mo(lh, this)) }; return e.addEventListener("click", r, { capture: !0, signal: n }), e.addEventListener("keydown", (t => { t.target === e && "Enter" === t.key && (To(oh, this, !0), r(t)) }), { signal: n }), await _o(ch, this, dh).call(this), e } finish() { Mo(ih, this) && (Mo(ih, this).focus({ focusVisible: Mo(oh, this) }), To(oh, this, !1)) } isEmpty() { return !Mo(nh, this) && !Mo(rh, this) } get data() { return { altText: Mo(nh, this), decorative: Mo(rh, this) } } set data(e) { let { altText: t, decorative: n } = e; Mo(nh, this) === t && Mo(rh, this) === n || (To(nh, this, t), To(rh, this, n), _o(ch, this, dh).call(this)) } toggle() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; Mo(ih, this) && (!e && Mo(sh, this) && (clearTimeout(Mo(sh, this)), To(sh, this, null)), Mo(ih, this).disabled = !e) } destroy() { var e; null === (e = Mo(ih, this)) || void 0 === e || e.remove(), To(ih, this, null), To(ah, this, null) } } async function dh() { const e = Mo(ih, this); if (!e) return; var t; if (!Mo(nh, this) && !Mo(rh, this)) return e.classList.remove("done"), void (null === (t = Mo(ah, this)) || void 0 === t || t.remove()); e.classList.add("done"), ao._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((t => { e.setAttribute("aria-label", t) })); let n = Mo(ah, this); if (!n) { To(ah, this, n = document.createElement("span")), n.className = "tooltip", n.setAttribute("role", "tooltip"); const t = n.id = "alt-text-tooltip-".concat(Mo(lh, this).id); e.setAttribute("aria-describedby", t); const r = 100, i = Mo(lh, this)._uiManager._signal; i.addEventListener("abort", (() => { clearTimeout(Mo(sh, this)), To(sh, this, null) }), { once: !0 }), e.addEventListener("mouseenter", (() => { To(sh, this, setTimeout((() => { To(sh, this, null), Mo(ah, this).classList.add("show"), Mo(lh, this)._reportTelemetry({ action: "alt_text_tooltip" }) }), r)) }), { signal: i }), e.addEventListener("mouseleave", (() => { var e; Mo(sh, this) && (clearTimeout(Mo(sh, this)), To(sh, this, null)), null === (e = Mo(ah, this)) || void 0 === e || e.classList.remove("show") }), { signal: i }) } n.innerText = Mo(rh, this) ? await ao._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : Mo(nh, this), n.parentNode || e.append(n); const r = Mo(lh, this).getImageForAltText(); null === r || void 0 === r || r.setAttribute("aria-describedby", n.id) } ao = uh, Eo(uh, "_l10nPromise", null); var hh = new WeakMap, fh = new WeakMap, ph = new WeakMap, mh = new WeakMap, gh = new WeakMap, vh = new WeakMap, bh = new WeakMap, yh = new WeakMap, wh = new WeakMap, xh = new WeakMap, _h = new WeakMap, kh = new WeakMap, Sh = new WeakMap, Ah = new WeakMap, Eh = new WeakMap, Ch = new WeakMap, Mh = new WeakMap, Th = new WeakMap, Ph = new WeakMap, Rh = new WeakMap, Nh = new WeakMap, Lh = new WeakMap, Ih = new WeakSet; class Dh { static get _resizerKeyboardManager() { const e = Dh.prototype._resizeWithKeyboard, t = Dd.TRANSLATE_SMALL, n = Dd.TRANSLATE_BIG; return Dl(this, "_resizerKeyboardManager", new zu([[["ArrowLeft", "mac+ArrowLeft"], e, { args: [-t, 0] }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e, { args: [-n, 0] }], [["ArrowRight", "mac+ArrowRight"], e, { args: [t, 0] }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e, { args: [n, 0] }], [["ArrowUp", "mac+ArrowUp"], e, { args: [0, -t] }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e, { args: [0, -n] }], [["ArrowDown", "mac+ArrowDown"], e, { args: [0, t] }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e, { args: [0, n] }], [["Escape", "mac+Escape"], Dh.prototype._stopResizingWithKeyboard]])) } constructor(e) { xo(this, Ih), Co(this, hh, null), Co(this, fh, null), Co(this, ph, null), Co(this, mh, !1), Co(this, gh, !1), Co(this, vh, null), Co(this, bh, null), Co(this, yh, this.focusin.bind(this)), Co(this, wh, this.focusout.bind(this)), Co(this, xh, null), Co(this, _h, ""), Co(this, kh, !1), Co(this, Sh, null), Co(this, Ah, !1), Co(this, Eh, !1), Co(this, Ch, !1), Co(this, Mh, null), Co(this, Th, 0), Co(this, Ph, 0), Co(this, Rh, null), Eo(this, "_initialOptions", Object.create(null)), Eo(this, "_isVisible", !0), Eo(this, "_uiManager", null), Eo(this, "_focusEventsAllowed", !0), Eo(this, "_l10nPromise", null), Co(this, Nh, !1), Co(this, Lh, Dh._zIndex++), this.constructor === Dh && Nl("Cannot initialize AnnotationEditor."), this.parent = e.parent, this.id = e.id, this.width = this.height = null, this.pageIndex = e.parent.pageIndex, this.name = e.name, this.div = null, this._uiManager = e.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = e.isCentered, this._structTreeParentId = null; const { rotation: t, rawDims: { pageWidth: n, pageHeight: r, pageX: i, pageY: a } } = this.parent.viewport; this.rotation = t, this.pageRotation = (360 + t - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [n, r], this.pageTranslation = [i, a]; const [s, o] = this.parentDimensions; this.x = e.x / s, this.y = e.y / o, this.isAttachedToDOM = !1, this.deleted = !1 } get editorType() { return Object.getPrototypeOf(this).constructor._type } static get _defaultLineColor() { return Dl(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText")) } static deleteAnnotationElement(e) { const t = new Qh({ id: e.parent.getNextId(), parent: e.parent, uiManager: e._uiManager }); t.annotationElementId = e.annotationElementId, t.deleted = !0, t._uiManager.addToAnnotationStorage(t) } static initialize(e, t, n) { if (Dh._l10nPromise || (Dh._l10nPromise = new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((t => [t, e.get(t.replaceAll(/([A-Z])/g, (e => "-".concat(e.toLowerCase()))))])))), null !== n && void 0 !== n && n.strings) for (const i of n.strings) Dh._l10nPromise.set(i, e.get(i)); if (-1 !== Dh._borderLineWidth) return; const r = getComputedStyle(document.documentElement); Dh._borderLineWidth = parseFloat(r.getPropertyValue("--outline-width")) || 0 } static updateDefaultParams(e, t) { } static get defaultPropertiesToUpdate() { return [] } static isHandlingMimeForPasting(e) { return !1 } static paste(e, t) { Nl("Not implemented") } get propertiesToUpdate() { return [] } get _isDraggable() { return Mo(Nh, this) } set _isDraggable(e) { var t; To(Nh, this, e), null === (t = this.div) || void 0 === t || t.classList.toggle("draggable", e) } get isEnterHandled() { return !0 } center() { const [e, t] = this.pageDimensions; switch (this.parentRotation) { case 90: this.x -= this.height * t / (2 * e), this.y += this.width * e / (2 * t); break; case 180: this.x += this.width / 2, this.y += this.height / 2; break; case 270: this.x += this.height * t / (2 * e), this.y -= this.width * e / (2 * t); break; default: this.x -= this.width / 2, this.y -= this.height / 2 }this.fixAndSetPosition() } addCommands(e) { this._uiManager.addCommands(e) } get currentLayer() { return this._uiManager.currentLayer } setInBackground() { this.div.style.zIndex = 0 } setInForeground() { this.div.style.zIndex = Mo(Lh, this) } setParent(e) { null !== e ? (this.pageIndex = e.pageIndex, this.pageDimensions = e.pageDimensions) : _o(Ih, this, Kh).call(this), this.parent = e } focusin(e) { this._focusEventsAllowed && (Mo(kh, this) ? To(kh, this, !1) : this.parent.setSelected(this)) } focusout(e) { var t; if (!this._focusEventsAllowed) return; if (!this.isAttachedToDOM) return; const n = e.relatedTarget; null !== n && void 0 !== n && n.closest("#".concat(this.id)) || (e.preventDefault(), null !== (t = this.parent) && void 0 !== t && t.isMultipleSelection || this.commitOrRemove()) } commitOrRemove() { this.isEmpty() ? this.remove() : this.commit() } commit() { this.addToAnnotationStorage() } addToAnnotationStorage() { this._uiManager.addToAnnotationStorage(this) } setAt(e, t, n, r) { const [i, a] = this.parentDimensions;[n, r] = this.screenToPageTranslation(n, r), this.x = (e + n) / i, this.y = (t + r) / a, this.fixAndSetPosition() } translate(e, t) { _o(Ih, this, Oh).call(this, this.parentDimensions, e, t) } translateInPage(e, t) { Mo(Sh, this) || To(Sh, this, [this.x, this.y]), _o(Ih, this, Oh).call(this, this.pageDimensions, e, t), this.div.scrollIntoView({ block: "nearest" }) } drag(e, t) { Mo(Sh, this) || To(Sh, this, [this.x, this.y]); const [n, r] = this.parentDimensions; if (this.x += e / n, this.y += t / r, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) { const { x: e, y: t } = this.div.getBoundingClientRect(); this.parent.findNewParent(this, e, t) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y)) } let { x: i, y: a } = this; const [s, o] = this.getBaseTranslation(); i += s, a += o, this.div.style.left = "".concat((100 * i).toFixed(2), "%"), this.div.style.top = "".concat((100 * a).toFixed(2), "%"), this.div.scrollIntoView({ block: "nearest" }) } get _hasBeenMoved() { return !!Mo(Sh, this) && (Mo(Sh, this)[0] !== this.x || Mo(Sh, this)[1] !== this.y) } getBaseTranslation() { const [e, t] = this.parentDimensions, { _borderLineWidth: n } = Dh, r = n / e, i = n / t; switch (this.rotation) { case 90: return [-r, i]; case 180: return [r, i]; case 270: return [r, -i]; default: return [-r, -i] } } get _mustFixPosition() { return !0 } fixAndSetPosition() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.rotation; const [t, n] = this.pageDimensions; let { x: r, y: i, width: a, height: s } = this; if (a *= t, s *= n, r *= t, i *= n, this._mustFixPosition) switch (e) { case 0: r = Math.max(0, Math.min(t - a, r)), i = Math.max(0, Math.min(n - s, i)); break; case 90: r = Math.max(0, Math.min(t - s, r)), i = Math.min(n, Math.max(a, i)); break; case 180: r = Math.min(t, Math.max(a, r)), i = Math.min(n, Math.max(s, i)); break; case 270: r = Math.min(t, Math.max(s, r)), i = Math.max(0, Math.min(n - a, i)) }this.x = r /= t, this.y = i /= n; const [o, l] = this.getBaseTranslation(); r += o, i += l; const { style: c } = this.div; c.left = "".concat((100 * r).toFixed(2), "%"), c.top = "".concat((100 * i).toFixed(2), "%"), this.moveInDOM() } screenToPageTranslation(e, t) { return jh.call(Dh, e, t, this.parentRotation) } pageTranslationToScreen(e, t) { return jh.call(Dh, e, t, 360 - this.parentRotation) } get parentScale() { return this._uiManager.viewParameters.realScale } get parentRotation() { return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360 } get parentDimensions() { const { parentScale: e, pageDimensions: [t, n] } = this, r = t * e, i = n * e; return Xl.isCSSRoundSupported ? [Math.round(r), Math.round(i)] : [r, i] } setDims(e, t) { const [n, r] = this.parentDimensions; this.div.style.width = "".concat((100 * e / n).toFixed(2), "%"), Mo(gh, this) || (this.div.style.height = "".concat((100 * t / r).toFixed(2), "%")) } fixDims() { const { style: e } = this.div, { height: t, width: n } = e, r = n.endsWith("%"), i = !Mo(gh, this) && t.endsWith("%"); if (r && i) return; const [a, s] = this.parentDimensions; r || (e.width = "".concat((100 * parseFloat(n) / a).toFixed(2), "%")), Mo(gh, this) || i || (e.height = "".concat((100 * parseFloat(t) / s).toFixed(2), "%")) } getInitialTranslation() { return [0, 0] } altTextFinish() { var e; null === (e = Mo(ph, this)) || void 0 === e || e.finish() } async addEditToolbar() { return Mo(xh, this) || Mo(Eh, this) || (To(xh, this, new cu(this)), this.div.append(Mo(xh, this).render()), Mo(ph, this) && Mo(xh, this).addAltTextButton(await Mo(ph, this).render())), Mo(xh, this) } removeEditToolbar() { var e; Mo(xh, this) && (Mo(xh, this).remove(), To(xh, this, null), null === (e = Mo(ph, this)) || void 0 === e || e.destroy()) } getClientDimensions() { return this.div.getBoundingClientRect() } async addAltTextButton() { Mo(ph, this) || (uh.initialize(Dh._l10nPromise), To(ph, this, new uh(this)), Mo(hh, this) && (Mo(ph, this).data = Mo(hh, this), To(hh, this, null)), await this.addEditToolbar()) } get altTextData() { var e; return null === (e = Mo(ph, this)) || void 0 === e ? void 0 : e.data } set altTextData(e) { Mo(ph, this) && (Mo(ph, this).data = e) } hasAltText() { var e; return !(null !== (e = Mo(ph, this)) && void 0 !== e && e.isEmpty()) } render() { this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = Mo(mh, this) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(); const e = this._uiManager._signal; this.div.addEventListener("focusin", Mo(yh, this), { signal: e }), this.div.addEventListener("focusout", Mo(wh, this), { signal: e }); const [t, n] = this.parentDimensions; this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = "".concat((100 * n / t).toFixed(2), "%"), this.div.style.maxHeight = "".concat((100 * t / n).toFixed(2), "%")); const [r, i] = this.getInitialTranslation(); return this.translate(r, i), Su(this, this.div, ["pointerdown"]), this.div } pointerdown(e) { const { isMac: t } = Xl.platform; 0 !== e.button || e.ctrlKey && t ? e.preventDefault() : (To(kh, this, !0), this._isDraggable ? _o(Ih, this, Vh).call(this, e) : _o(Ih, this, Uh).call(this, e)) } moveInDOM() { Mo(Mh, this) && clearTimeout(Mo(Mh, this)), To(Mh, this, setTimeout((() => { var e; To(Mh, this, null), null === (e = this.parent) || void 0 === e || e.moveEditorInDOM(this) }), 0)) } _setParentAndPosition(e, t, n) { e.changeParent(this), this.x = t, this.y = n, this.fixAndSetPosition() } getRect(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.rotation; const r = this.parentScale, [i, a] = this.pageDimensions, [s, o] = this.pageTranslation, l = e / r, c = t / r, u = this.x * i, d = this.y * a, h = this.width * i, f = this.height * a; switch (n) { case 0: return [u + l + s, a - d - c - f + o, u + l + h + s, a - d - c + o]; case 90: return [u + c + s, a - d + l + o, u + c + f + s, a - d + l + h + o]; case 180: return [u - l - h + s, a - d + c + o, u - l + s, a - d + c + f + o]; case 270: return [u - c - f + s, a - d - l - h + o, u - c + s, a - d - l + o]; default: throw new Error("Invalid rotation") } } getRectInCurrentCoords(e, t) { const [n, r, i, a] = e, s = i - n, o = a - r; switch (this.rotation) { case 0: return [n, t - a, s, o]; case 90: return [n, t - r, o, s]; case 180: return [i, t - r, s, o]; case 270: return [i, t - a, o, s]; default: throw new Error("Invalid rotation") } } onceAdded() { } isEmpty() { return !1 } enableEditMode() { To(Eh, this, !0) } disableEditMode() { To(Eh, this, !1) } isInEditMode() { return Mo(Eh, this) } shouldGetKeyboardEvents() { return Mo(Ch, this) } needsToBeRebuilt() { return this.div && !this.isAttachedToDOM } rebuild() { var e, t; const n = this._uiManager._signal; null === (e = this.div) || void 0 === e || e.addEventListener("focusin", Mo(yh, this), { signal: n }), null === (t = this.div) || void 0 === t || t.addEventListener("focusout", Mo(wh, this), { signal: n }) } rotate(e) { } serialize() { Nl("An editor must be serializable") } static deserialize(e, t, n) { const r = new this.prototype.constructor({ parent: t, id: t.getNextId(), uiManager: n }); r.rotation = e.rotation, To(hh, r, e.accessibilityData); const [i, a] = r.pageDimensions, [s, o, l, c] = r.getRectInCurrentCoords(e.rect, a); return r.x = s / i, r.y = o / a, r.width = l / i, r.height = c / a, r } get hasBeenModified() { return !!this.annotationElementId && (this.deleted || null !== this.serialize()) } remove() { if (this.div.removeEventListener("focusin", Mo(yh, this)), this.div.removeEventListener("focusout", Mo(wh, this)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), Mo(Mh, this) && (clearTimeout(Mo(Mh, this)), To(Mh, this, null)), _o(Ih, this, Kh).call(this), this.removeEditToolbar(), Mo(Rh, this)) { for (const e of Mo(Rh, this).values()) clearTimeout(e); To(Rh, this, null) } this.parent = null } get isResizable() { return !1 } makeResizable() { this.isResizable && (_o(Ih, this, zh).call(this), Mo(vh, this).classList.remove("hidden"), Su(this, this.div, ["keydown"])) } get toolbarPosition() { return null } keydown(e) { if (!this.isResizable || e.target !== this.div || "Enter" !== e.key) return; this._uiManager.setSelected(this), To(bh, this, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height }); const t = Mo(vh, this).children; if (!Mo(fh, this)) { To(fh, this, Array.from(t)); const e = _o(Ih, this, qh).bind(this), n = _o(Ih, this, Gh).bind(this), r = this._uiManager._signal; for (const t of Mo(fh, this)) { const i = t.getAttribute("data-resizer-name"); t.setAttribute("role", "spinbutton"), t.addEventListener("keydown", e, { signal: r }), t.addEventListener("blur", n, { signal: r }), t.addEventListener("focus", _o(Ih, this, Xh).bind(this, i), { signal: r }), Dh._l10nPromise.get("pdfjs-editor-resizer-label-".concat(i)).then((e => t.setAttribute("aria-label", e))) } } const n = Mo(fh, this)[0]; let r = 0; for (const a of t) { if (a === n) break; r++ } const i = (360 - this.rotation + this.parentRotation) % 360 / 90 * (Mo(fh, this).length / 4); if (i !== r) { if (i < r) for (let t = 0; t < r - i; t++)Mo(vh, this).append(Mo(vh, this).firstChild); else if (i > r) for (let t = 0; t < i - r; t++)Mo(vh, this).firstChild.before(Mo(vh, this).lastChild); let e = 0; for (const n of t) { const t = Mo(fh, this)[e++].getAttribute("data-resizer-name"); Dh._l10nPromise.get("pdfjs-editor-resizer-label-".concat(t)).then((e => n.setAttribute("aria-label", e))) } } _o(Ih, this, Yh).call(this, 0), To(Ch, this, !0), Mo(vh, this).firstChild.focus({ focusVisible: !0 }), e.preventDefault(), e.stopImmediatePropagation() } _resizeWithKeyboard(e, t) { Mo(Ch, this) && _o(Ih, this, Hh).call(this, Mo(_h, this), { movementX: e, movementY: t }) } _stopResizingWithKeyboard() { _o(Ih, this, Kh).call(this), this.div.focus() } select() { var e, t; this.makeResizable(), null === (e = this.div) || void 0 === e || e.classList.add("selectedEditor"), Mo(xh, this) ? null === (t = Mo(xh, this)) || void 0 === t || t.show() : this.addEditToolbar().then((() => { var e, t; null !== (e = this.div) && void 0 !== e && e.classList.contains("selectedEditor") && (null === (t = Mo(xh, this)) || void 0 === t || t.show()) })) } unselect() { var e, t, n, r; null === (e = Mo(vh, this)) || void 0 === e || e.classList.add("hidden"), null === (t = this.div) || void 0 === t || t.classList.remove("selectedEditor"), null !== (n = this.div) && void 0 !== n && n.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({ preventScroll: !0 }), null === (r = Mo(xh, this)) || void 0 === r || r.hide() } updateParams(e, t) { } disableEditing() { } enableEditing() { } enterInEditMode() { } getImageForAltText() { return null } get contentDiv() { return this.div } get isEditing() { return Mo(Ah, this) } set isEditing(e) { To(Ah, this, e), this.parent && (e ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null)) } setAspectRatio(e, t) { To(gh, this, !0); const n = e / t, { style: r } = this.div; r.aspectRatio = n, r.height = "auto" } static get MIN_SIZE() { return 16 } static canCreateNewEmptyEditor() { return !0 } get telemetryInitialData() { return { action: "added" } } get telemetryFinalData() { return null } _reportTelemetry(e) { if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) { Mo(Rh, this) || To(Rh, this, new Map); const { action: t } = e; let n = Mo(Rh, this).get(t); return n && clearTimeout(n), n = setTimeout((() => { this._reportTelemetry(e), Mo(Rh, this).delete(t), 0 === Mo(Rh, this).size && To(Rh, this, null) }), Dh._telemetryTimeout), void Mo(Rh, this).set(t, n) } e.type || (e.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: e } }) } show() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._isVisible; this.div.classList.toggle("hidden", !e), this._isVisible = e } enable() { this.div && (this.div.tabIndex = 0), To(mh, this, !1) } disable() { this.div && (this.div.tabIndex = -1), To(mh, this, !0) } renderAnnotationElement(e) { let t = e.container.querySelector(".annotationContent"); if (t) { if ("CANVAS" === t.nodeName) { const e = t; t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e.before(t) } } else t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e.container.prepend(t); return t } resetAnnotationElement(e) { const { firstChild: t } = e.container; "DIV" === t.nodeName && t.classList.contains("annotationContent") && t.remove() } } function Oh(e, t, n) { let [r, i] = e;[t, n] = this.screenToPageTranslation(t, n), this.x += t / r, this.y += n / i, this.fixAndSetPosition() } function jh(e, t, n) { switch (n) { case 90: return [t, -e]; case 180: return [-e, -t]; case 270: return [-t, e]; default: return [e, t] } } function Fh(e) { switch (e) { case 90: { const [e, t] = this.pageDimensions; return [0, -e / t, t / e, 0] } case 180: return [-1, 0, 0, -1]; case 270: { const [e, t] = this.pageDimensions; return [0, e / t, -t / e, 0] } default: return [1, 0, 0, 1] } } function zh() { if (Mo(vh, this)) return; To(vh, this, document.createElement("div")), Mo(vh, this).classList.add("resizers"); const e = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t = this._uiManager._signal; for (const n of e) { const e = document.createElement("div"); Mo(vh, this).append(e), e.classList.add("resizer", n), e.setAttribute("data-resizer-name", n), e.addEventListener("pointerdown", _o(Ih, this, Wh).bind(this, n), { signal: t }), e.addEventListener("contextmenu", Kc, { signal: t }), e.tabIndex = -1 } this.div.prepend(Mo(vh, this)) } function Wh(e, t) { var n; t.preventDefault(); const { isMac: r } = Xl.platform; if (0 !== t.button || t.ctrlKey && r) return; null === (n = Mo(ph, this)) || void 0 === n || n.toggle(!1); const i = _o(Ih, this, Hh).bind(this, e), a = this._isDraggable; this._isDraggable = !1; const s = this._uiManager._signal, o = { passive: !0, capture: !0, signal: s }; this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", i, o), window.addEventListener("contextmenu", Kc, { signal: s }); const l = this.x, c = this.y, u = this.width, d = this.height, h = this.parent.div.style.cursor, f = this.div.style.cursor; this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t.target).cursor; const p = () => { var e; this.parent.togglePointerEvents(!0), null === (e = Mo(ph, this)) || void 0 === e || e.toggle(!0), this._isDraggable = a, window.removeEventListener("pointerup", p), window.removeEventListener("blur", p), window.removeEventListener("pointermove", i, o), window.removeEventListener("contextmenu", Kc), this.parent.div.style.cursor = h, this.div.style.cursor = f, _o(Ih, this, Bh).call(this, l, c, u, d) }; window.addEventListener("pointerup", p, { signal: s }), window.addEventListener("blur", p, { signal: s }) } function Bh(e, t, n, r) { const i = this.x, a = this.y, s = this.width, o = this.height; i === e && a === t && s === n && o === r || this.addCommands({ cmd: () => { this.width = s, this.height = o, this.x = i, this.y = a; const [e, t] = this.parentDimensions; this.setDims(e * s, t * o), this.fixAndSetPosition() }, undo: () => { this.width = n, this.height = r, this.x = e, this.y = t; const [i, a] = this.parentDimensions; this.setDims(i * n, a * r), this.fixAndSetPosition() }, mustExec: !0 }) } function Hh(e, t) { const [n, r] = this.parentDimensions, i = this.x, a = this.y, s = this.width, o = this.height, l = so.MIN_SIZE / n, c = so.MIN_SIZE / r, u = e => Math.round(1e4 * e) / 1e4, d = _o(Ih, this, Fh).call(this, this.rotation), h = (e, t) => [d[0] * e + d[2] * t, d[1] * e + d[3] * t], f = _o(Ih, this, Fh).call(this, 360 - this.rotation); let p, m, g = !1, v = !1; switch (e) { case "topLeft": g = !0, p = (e, t) => [0, 0], m = (e, t) => [e, t]; break; case "topMiddle": p = (e, t) => [e / 2, 0], m = (e, t) => [e / 2, t]; break; case "topRight": g = !0, p = (e, t) => [e, 0], m = (e, t) => [0, t]; break; case "middleRight": v = !0, p = (e, t) => [e, t / 2], m = (e, t) => [0, t / 2]; break; case "bottomRight": g = !0, p = (e, t) => [e, t], m = (e, t) => [0, 0]; break; case "bottomMiddle": p = (e, t) => [e / 2, t], m = (e, t) => [e / 2, 0]; break; case "bottomLeft": g = !0, p = (e, t) => [0, t], m = (e, t) => [e, 0]; break; case "middleLeft": v = !0, p = (e, t) => [0, t / 2], m = (e, t) => [e, t / 2] }const b = p(s, o), y = m(s, o); let w = h(...y); const x = u(i + w[0]), _ = u(a + w[1]); let k = 1, S = 1, [A, E] = this.screenToPageTranslation(t.movementX, t.movementY); var C, M; if ([A, E] = (C = A / n, M = E / r, [f[0] * C + f[2] * M, f[1] * C + f[3] * M]), g) { const e = Math.hypot(s, o); k = S = Math.max(Math.min(Math.hypot(y[0] - b[0] - A, y[1] - b[1] - E) / e, 1 / s, 1 / o), l / s, c / o) } else v ? k = Math.max(l, Math.min(1, Math.abs(y[0] - b[0] - A))) / s : S = Math.max(c, Math.min(1, Math.abs(y[1] - b[1] - E))) / o; const T = u(s * k), P = u(o * S); w = h(...m(T, P)); const R = x - w[0], N = _ - w[1]; this.width = T, this.height = P, this.x = R, this.y = N, this.setDims(n * T, r * P), this.fixAndSetPosition() } function Uh(e) { const { isMac: t } = Xl.platform; e.ctrlKey && !t || e.shiftKey || e.metaKey && t ? this.parent.toggleSelected(this) : this.parent.setSelected(this) } function Vh(e) { const t = this._uiManager.isSelected(this); let n, r; this._uiManager.setUpDragSession(); const i = this._uiManager._signal; t && (this.div.classList.add("moving"), n = { passive: !0, capture: !0, signal: i }, To(Th, this, e.clientX), To(Ph, this, e.clientY), r = e => { const { clientX: t, clientY: n } = e, [r, i] = this.screenToPageTranslation(t - Mo(Th, this), n - Mo(Ph, this)); To(Th, this, t), To(Ph, this, n), this._uiManager.dragSelectedEditors(r, i) }, window.addEventListener("pointermove", r, n)); const a = () => { window.removeEventListener("pointerup", a), window.removeEventListener("blur", a), t && (this.div.classList.remove("moving"), window.removeEventListener("pointermove", r, n)), To(kh, this, !1), this._uiManager.endDragSession() || _o(Ih, this, Uh).call(this, e) }; window.addEventListener("pointerup", a, { signal: i }), window.addEventListener("blur", a, { signal: i }) } function qh(e) { so._resizerKeyboardManager.exec(this, e) } function Gh(e) { var t; Mo(Ch, this) && (null === (t = e.relatedTarget) || void 0 === t ? void 0 : t.parentNode) !== Mo(vh, this) && _o(Ih, this, Kh).call(this) } function Xh(e) { To(_h, this, Mo(Ch, this) ? e : "") } function Yh(e) { if (Mo(fh, this)) for (const t of Mo(fh, this)) t.tabIndex = e } function Kh() { if (To(Ch, this, !1), _o(Ih, this, Yh).call(this, -1), Mo(bh, this)) { const { savedX: e, savedY: t, savedWidth: n, savedHeight: r } = Mo(bh, this); _o(Ih, this, Bh).call(this, e, t, n, r), To(bh, this, null) } } so = Dh, Eo(Dh, "_borderLineWidth", -1), Eo(Dh, "_colorManager", new Bu), Eo(Dh, "_zIndex", 1), Eo(Dh, "_telemetryTimeout", 1e3); class Qh extends Dh { constructor(e) { super(e), this.annotationElementId = e.annotationElementId, this.deleted = !0 } serialize() { return { id: this.annotationElementId, deleted: !0, pageIndex: this.pageIndex } } } const $h = 3285377520, Jh = 4294901760, Zh = 65535; class ef { constructor(e) { this.h1 = e ? 4294967295 & e : $h, this.h2 = e ? 4294967295 & e : $h } update(e) { let t, n; if ("string" === typeof e) { t = new Uint8Array(2 * e.length), n = 0; for (let r = 0, i = e.length; r < i; r++) { const i = e.charCodeAt(r); i <= 255 ? t[n++] = i : (t[n++] = i >>> 8, t[n++] = 255 & i) } } else { if (!ArrayBuffer.isView(e)) throw new Error("Invalid data format, must be a string or TypedArray."); t = e.slice(), n = t.byteLength } const r = n >> 2, i = n - 4 * r, a = new Uint32Array(t.buffer, 0, r); let s = 0, o = 0, l = this.h1, c = this.h2; const u = 3432918353, d = 461845907, h = 11601, f = 13715; for (let p = 0; p < r; p++)1 & p ? (s = a[p], s = s * u & Jh | s * h & Zh, s = s << 15 | s >>> 17, s = s * d & Jh | s * f & Zh, l ^= s, l = l << 13 | l >>> 19, l = 5 * l + 3864292196) : (o = a[p], o = o * u & Jh | o * h & Zh, o = o << 15 | o >>> 17, o = o * d & Jh | o * f & Zh, c ^= o, c = c << 13 | c >>> 19, c = 5 * c + 3864292196); switch (s = 0, i) { case 3: s ^= t[4 * r + 2] << 16; case 2: s ^= t[4 * r + 1] << 8; case 1: s ^= t[4 * r], s = s * u & Jh | s * h & Zh, s = s << 15 | s >>> 17, s = s * d & Jh | s * f & Zh, 1 & r ? l ^= s : c ^= s }this.h1 = l, this.h2 = c } hexdigest() { let e = this.h1, t = this.h2; return e ^= t >>> 1, e = 3981806797 * e & Jh | 36045 * e & Zh, t = 4283543511 * t & Jh | (2950163797 * (t << 16 | e >>> 16) & Jh) >>> 16, e ^= t >>> 1, e = 444984403 * e & Jh | 60499 * e & Zh, t = 3301882366 * t & Jh | (3120437893 * (t << 16 | e >>> 16) & Jh) >>> 16, e ^= t >>> 1, (e >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0") } } const tf = Object.freeze({ map: null, hash: "", transfer: void 0 }); var nf = new WeakMap, rf = new WeakMap, af = new WeakSet; class sf { constructor() { xo(this, af), Co(this, nf, !1), Co(this, rf, new Map), this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null } getValue(e, t) { const n = Mo(rf, this).get(e); return void 0 === n ? t : Object.assign(t, n) } getRawValue(e) { return Mo(rf, this).get(e) } remove(e) { if (Mo(rf, this).delete(e), 0 === Mo(rf, this).size && this.resetModified(), "function" === typeof this.onAnnotationEditor) { for (const e of Mo(rf, this).values()) if (e instanceof Dh) return; this.onAnnotationEditor(null) } } setValue(e, t) { const n = Mo(rf, this).get(e); let r = !1; if (void 0 !== n) for (const [i, a] of Object.entries(t)) n[i] !== a && (r = !0, n[i] = a); else r = !0, Mo(rf, this).set(e, t); r && _o(af, this, of).call(this), t instanceof Dh && "function" === typeof this.onAnnotationEditor && this.onAnnotationEditor(t.constructor._type) } has(e) { return Mo(rf, this).has(e) } getAll() { return Mo(rf, this).size > 0 ? Gl(Mo(rf, this)) : null } setAll(e) { for (const [t, n] of Object.entries(e)) this.setValue(t, n) } get size() { return Mo(rf, this).size } resetModified() { Mo(nf, this) && (To(nf, this, !1), "function" === typeof this.onResetModified && this.onResetModified()) } get print() { return new cf(this) } get serializable() { if (0 === Mo(rf, this).size) return tf; const e = new Map, t = new ef, n = [], r = Object.create(null); let i = !1; for (const [a, s] of Mo(rf, this)) { const n = s instanceof Dh ? s.serialize(!1, r) : s; n && (e.set(a, n), t.update("".concat(a, ":").concat(JSON.stringify(n))), i || (i = !!n.bitmap)) } if (i) for (const a of e.values()) a.bitmap && n.push(a.bitmap); return e.size > 0 ? { map: e, hash: t.hexdigest(), transfer: n } : tf } get editorStats() { let e = null; const t = new Map; for (const i of Mo(rf, this).values()) { var n; if (!(i instanceof Dh)) continue; const a = i.telemetryFinalData; if (!a) continue; const { type: s } = a; t.has(s) || t.set(s, Object.getPrototypeOf(i).constructor), e || (e = Object.create(null)); const o = (n = e)[s] || (n[s] = new Map); for (const [e, t] of Object.entries(a)) { var r; if ("type" === e) continue; let n = o.get(e); n || (n = new Map, o.set(e, n)); const i = null !== (r = n.get(t)) && void 0 !== r ? r : 0; n.set(t, i + 1) } } for (const [i, a] of t) e[i] = a.computeTelemetryFinalData(e[i]); return e } } function of() { Mo(nf, this) || (To(nf, this, !0), "function" === typeof this.onSetModified && this.onSetModified()) } var lf = new WeakMap; class cf extends sf { constructor(e) { super(), Co(this, lf, void 0); const { map: t, hash: n, transfer: r } = e.serializable, i = structuredClone(t, r ? { transfer: r } : null); To(lf, this, { map: i, hash: n, transfer: r }) } get print() { Nl("Should not call PrintAnnotationStorage.print") } get serializable() { return Mo(lf, this) } } var uf = new WeakMap; class df { constructor(e) { let { ownerDocument: t = globalThis.document, styleElement: n = null } = e; Co(this, uf, new Set), this._document = t, this.nativeFontFaces = new Set, this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0 } addNativeFontFace(e) { this.nativeFontFaces.add(e), this._document.fonts.add(e) } removeNativeFontFace(e) { this.nativeFontFaces.delete(e), this._document.fonts.delete(e) } insertRule(e) { this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement)); const t = this.styleElement.sheet; t.insertRule(e, t.cssRules.length) } clear() { for (const e of this.nativeFontFaces) this._document.fonts.delete(e); this.nativeFontFaces.clear(), Mo(uf, this).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null) } async loadSystemFont(e) { let { systemFontInfo: t, _inspectFont: n } = e; if (t && !Mo(uf, this).has(t.loadedName)) if (Ll(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) { const { loadedName: e, src: r, style: i } = t, a = new FontFace(e, r, i); this.addNativeFontFace(a); try { await a.load(), Mo(uf, this).add(e), null === n || void 0 === n || n(t) } catch { Rl("Cannot load system font: ".concat(t.baseFontName, ", installing it could help to improve PDF rendering.")), this.removeNativeFontFace(a) } } else Nl("Not implemented: loadSystemFont without the Font Loading API.") } async bind(e) { if (e.attached || e.missingFile && !e.systemFontInfo) return; if (e.attached = !0, e.systemFontInfo) return void await this.loadSystemFont(e); if (this.isFontLoadingAPISupported) { const t = e.createNativeFontFace(); if (t) { this.addNativeFontFace(t); try { await t.loaded } catch (n) { throw Rl("Failed to load font '".concat(t.family, "': '").concat(n, "'.")), e.disableFontFace = !0, n } } return } const t = e.createFontFaceRule(); if (t) { if (this.insertRule(t), this.isSyncFontLoadingSupported) return; await new Promise((t => { const n = this._queueLoadingCallback(t); this._prepareFontLoadEvent(e, n) })) } } get isFontLoadingAPISupported() { var e; return Dl(this, "isFontLoadingAPISupported", !(null === (e = this._document) || void 0 === e || !e.fonts)) } get isSyncFontLoadingSupported() { var e; let t = !1; return (No || "undefined" !== typeof navigator && "string" === typeof (null === (e = navigator) || void 0 === e ? void 0 : e.userAgent) && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (t = !0), Dl(this, "isSyncFontLoadingSupported", t) } _queueLoadingCallback(e) { const { loadingRequests: t } = this, n = { done: !1, complete: function () { for (Ll(!n.done, "completeRequest() cannot be called twice."), n.done = !0; t.length > 0 && t[0].done;) { const e = t.shift(); setTimeout(e.callback, 0) } }, callback: e }; return t.push(n), n } get _loadTestFont() { return Dl(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==")) } _prepareFontLoadEvent(e, t) { function n(e, t) { return e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | 255 & e.charCodeAt(t + 3) } function r(e, t, n, r) { return e.substring(0, t) + r + e.substring(t + n) } let i, a; const s = this._document.createElement("canvas"); s.width = 1, s.height = 1; const o = s.getContext("2d"); let l = 0; const c = "lt".concat(Date.now()).concat(this.loadTestFontId++); let u = this._loadTestFont; u = r(u, 976, c.length, c); const d = 1482184792; let h = n(u, 16); for (i = 0, a = c.length - 3; i < a; i += 4)h = h - d + n(c, i) | 0; var f; i < c.length && (h = h - d + n(c + "XXX", i) | 0), u = r(u, 16, 4, (f = h, String.fromCharCode(f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, 255 & f))); const p = "url(data:font/opentype;base64,".concat(btoa(u), ");"), m = '@font-face {font-family:"'.concat(c, '";src:').concat(p, "}"); this.insertRule(m); const g = this._document.createElement("div"); g.style.visibility = "hidden", g.style.width = g.style.height = "10px", g.style.position = "absolute", g.style.top = g.style.left = "0px"; for (const v of [e.loadedName, c]) { const e = this._document.createElement("span"); e.textContent = "Hi", e.style.fontFamily = v, g.append(e) } this._document.body.append(g), function e(t, n) { if (++l > 30) return Rl("Load test font never loaded."), void n(); o.font = "30px " + t, o.fillText(".", 0, 20), o.getImageData(0, 0, 1, 1).data[3] > 0 ? n() : setTimeout(e.bind(null, t, n)) }(c, (() => { g.remove(), t.complete() })) } } class hf { constructor(e, t) { let { disableFontFace: n = !1, inspectFont: r = null } = t; this.compiledGlyphs = Object.create(null); for (const i in e) this[i] = e[i]; this.disableFontFace = !0 === n, this._inspectFont = r } createNativeFontFace() { var e; if (!this.data || this.disableFontFace) return null; let t; if (this.cssFontInfo) { const e = { weight: this.cssFontInfo.fontWeight }; this.cssFontInfo.italicAngle && (e.style = "oblique ".concat(this.cssFontInfo.italicAngle, "deg")), t = new FontFace(this.cssFontInfo.fontFamily, this.data, e) } else t = new FontFace(this.loadedName, this.data, {}); return null === (e = this._inspectFont) || void 0 === e || e.call(this, this), t } createFontFaceRule() { var e; if (!this.data || this.disableFontFace) return null; const t = Vl(this.data), n = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(t), ");"); let r; if (this.cssFontInfo) { let e = "font-weight: ".concat(this.cssFontInfo.fontWeight, ";"); this.cssFontInfo.italicAngle && (e += "font-style: oblique ".concat(this.cssFontInfo.italicAngle, "deg;")), r = '@font-face {font-family:"'.concat(this.cssFontInfo.fontFamily, '";').concat(e, "src:").concat(n, "}") } else r = '@font-face {font-family:"'.concat(this.loadedName, '";src:').concat(n, "}"); return null === (e = this._inspectFont) || void 0 === e || e.call(this, this, n), r } getPathGenerator(e, t) { if (void 0 !== this.compiledGlyphs[t]) return this.compiledGlyphs[t]; let n; try { n = e.get(this.loadedName + "_path_" + t) } catch (i) { Rl('getPathGenerator - ignoring character: "'.concat(i, '".')) } if (!Array.isArray(n) || 0 === n.length) return this.compiledGlyphs[t] = function (e, t) { }; const r = []; for (let a = 0, s = n.length; a < s;)switch (n[a++]) { case nc: { const [e, t, i, s, o, l] = n.slice(a, a + 6); r.push((n => n.bezierCurveTo(e, t, i, s, o, l))), a += 6 } break; case rc: { const [e, t] = n.slice(a, a + 2); r.push((n => n.moveTo(e, t))), a += 2 } break; case ic: { const [e, t] = n.slice(a, a + 2); r.push((n => n.lineTo(e, t))), a += 2 } break; case ac: { const [e, t, i, s] = n.slice(a, a + 4); r.push((n => n.quadraticCurveTo(e, t, i, s))), a += 4 } break; case sc: r.push((e => e.restore())); break; case oc: r.push((e => e.save())); break; case lc: Ll(2 === r.length, "Scale command is only valid at the third position."); break; case cc: { const [e, t, i, s, o, l] = n.slice(a, a + 6); r.push((n => n.transform(e, t, i, s, o, l))), a += 6 } break; case uc: { const [e, t] = n.slice(a, a + 2); r.push((n => n.translate(e, t))), a += 2 } }return this.compiledGlyphs[t] = function (e, t) { r[0](e), r[1](e), e.scale(t, -t); for (let n = 2, i = r.length; n < i; n++)r[n](e) } } } if (No) { var ff = Promise.withResolvers(), pf = null; (async () => { const e = await import("fs"), t = await import("http"), n = await import("https"), r = await import("url"); return new Map(Object.entries({ fs: e, http: t, https: n, url: r, canvas: undefined, path2d: undefined })) })().then((e => { pf = e, ff.resolve() }), (e => { Rl("loadPackages: ".concat(e)), pf = new Map, ff.resolve() })) } class mf { static get promise() { return ff.promise } static get(e) { var t; return null === (t = pf) || void 0 === t ? void 0 : t.get(e) } } const gf = function (e) { return mf.get("fs").promises.readFile(e).then((e => new Uint8Array(e))) }; const vf = "Fill", bf = "Stroke", yf = "Shading"; function wf(e, t) { if (!t) return; const n = t[2] - t[0], r = t[3] - t[1], i = new Path2D; i.rect(t[0], t[1], n, r), e.clip(i) } class xf { constructor() { this.constructor === xf && Nl("Cannot initialize BaseShadingPattern.") } getPattern() { Nl("Abstract method `getPattern` called.") } } class _f extends xf { constructor(e) { super(), this._type = e[1], this._bbox = e[2], this._colorStops = e[3], this._p0 = e[4], this._p1 = e[5], this._r0 = e[6], this._r1 = e[7], this.matrix = null } _createGradient(e) { let t; "axial" === this._type ? t = e.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (t = e.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1)); for (const n of this._colorStops) t.addColorStop(n[0], n[1]); return t } getPattern(e, t, n, r) { let i; if (r === bf || r === vf) { const a = t.current.getClippedPathBoundingBox(r, tu(e)) || [0, 0, 0, 0], s = Math.ceil(a[2] - a[0]) || 1, o = Math.ceil(a[3] - a[1]) || 1, l = t.cachedCanvases.getCanvas("pattern", s, o, !0), c = l.context; c.clearRect(0, 0, c.canvas.width, c.canvas.height), c.beginPath(), c.rect(0, 0, c.canvas.width, c.canvas.height), c.translate(-a[0], -a[1]), n = Kl.transform(n, [1, 0, 0, 1, a[0], a[1]]), c.transform(...t.baseTransform), this.matrix && c.transform(...this.matrix), wf(c, this._bbox), c.fillStyle = this._createGradient(c), c.fill(), i = e.createPattern(l.canvas, "no-repeat"); const u = new DOMMatrix(n); i.setTransform(u) } else wf(e, this._bbox), i = this._createGradient(e); return i } } function kf(e, t, n, r, i, a, s, o) { const l = t.coords, c = t.colors, u = e.data, d = 4 * e.width; let h; l[n + 1] > l[r + 1] && (h = n, n = r, r = h, h = a, a = s, s = h), l[r + 1] > l[i + 1] && (h = r, r = i, i = h, h = s, s = o, o = h), l[n + 1] > l[r + 1] && (h = n, n = r, r = h, h = a, a = s, s = h); const f = (l[n] + t.offsetX) * t.scaleX, p = (l[n + 1] + t.offsetY) * t.scaleY, m = (l[r] + t.offsetX) * t.scaleX, g = (l[r + 1] + t.offsetY) * t.scaleY, v = (l[i] + t.offsetX) * t.scaleX, b = (l[i + 1] + t.offsetY) * t.scaleY; if (p >= b) return; const y = c[a], w = c[a + 1], x = c[a + 2], _ = c[s], k = c[s + 1], S = c[s + 2], A = c[o], E = c[o + 1], C = c[o + 2], M = Math.round(p), T = Math.round(b); let P, R, N, L, I, D, O, j; for (let F = M; F <= T; F++) { if (F < g) { const e = F < p ? 0 : (p - F) / (p - g); P = f - (f - m) * e, R = y - (y - _) * e, N = w - (w - k) * e, L = x - (x - S) * e } else { let e; e = F > b ? 1 : g === b ? 0 : (g - F) / (g - b), P = m - (m - v) * e, R = _ - (_ - A) * e, N = k - (k - E) * e, L = S - (S - C) * e } let e; e = F < p ? 0 : F > b ? 1 : (p - F) / (p - b), I = f - (f - v) * e, D = y - (y - A) * e, O = w - (w - E) * e, j = x - (x - C) * e; const t = Math.round(Math.min(P, I)), n = Math.round(Math.max(P, I)); let r = d * F + 4 * t; for (let i = t; i <= n; i++)e = (P - i) / (P - I), e < 0 ? e = 0 : e > 1 && (e = 1), u[r++] = R - (R - D) * e | 0, u[r++] = N - (N - O) * e | 0, u[r++] = L - (L - j) * e | 0, u[r++] = 255 } } function Sf(e, t, n) { const r = t.coords, i = t.colors; let a, s; switch (t.type) { case "lattice": const o = t.verticesPerRow, l = Math.floor(r.length / o) - 1, c = o - 1; for (a = 0; a < l; a++) { let t = a * o; for (let a = 0; a < c; a++, t++)kf(e, n, r[t], r[t + 1], r[t + o], i[t], i[t + 1], i[t + o]), kf(e, n, r[t + o + 1], r[t + 1], r[t + o], i[t + o + 1], i[t + 1], i[t + o]) } break; case "triangles": for (a = 0, s = r.length; a < s; a += 3)kf(e, n, r[a], r[a + 1], r[a + 2], i[a], i[a + 1], i[a + 2]); break; default: throw new Error("illegal figure") } } class Af extends xf { constructor(e) { super(), this._coords = e[2], this._colors = e[3], this._figures = e[4], this._bounds = e[5], this._bbox = e[7], this._background = e[8], this.matrix = null } _createMeshCanvas(e, t, n) { const r = Math.floor(this._bounds[0]), i = Math.floor(this._bounds[1]), a = Math.ceil(this._bounds[2]) - r, s = Math.ceil(this._bounds[3]) - i, o = Math.min(Math.ceil(Math.abs(a * e[0] * 1.1)), 3e3), l = Math.min(Math.ceil(Math.abs(s * e[1] * 1.1)), 3e3), c = a / o, u = s / l, d = { coords: this._coords, colors: this._colors, offsetX: -r, offsetY: -i, scaleX: 1 / c, scaleY: 1 / u }, h = o + 4, f = l + 4, p = n.getCanvas("mesh", h, f, !1), m = p.context, g = m.createImageData(o, l); if (t) { const e = g.data; for (let n = 0, r = e.length; n < r; n += 4)e[n] = t[0], e[n + 1] = t[1], e[n + 2] = t[2], e[n + 3] = 255 } for (const v of this._figures) Sf(g, v, d); m.putImageData(g, 2, 2); return { canvas: p.canvas, offsetX: r - 2 * c, offsetY: i - 2 * u, scaleX: c, scaleY: u } } getPattern(e, t, n, r) { let i; if (wf(e, this._bbox), r === yf) i = Kl.singularValueDecompose2dScale(tu(e)); else if (i = Kl.singularValueDecompose2dScale(t.baseTransform), this.matrix) { const e = Kl.singularValueDecompose2dScale(this.matrix); i = [i[0] * e[0], i[1] * e[1]] } const a = this._createMeshCanvas(i, r === yf ? null : this._background, t.cachedCanvases); return r !== yf && (e.setTransform(...t.baseTransform), this.matrix && e.transform(...this.matrix)), e.translate(a.offsetX, a.offsetY), e.scale(a.scaleX, a.scaleY), e.createPattern(a.canvas, "no-repeat") } } class Ef extends xf { getPattern() { return "hotpink" } } const Cf = 1, Mf = 2; class Tf { constructor(e, t, n, r, i) { this.operatorList = e[2], this.matrix = e[3], this.bbox = e[4], this.xstep = e[5], this.ystep = e[6], this.paintType = e[7], this.tilingType = e[8], this.color = t, this.ctx = n, this.canvasGraphicsFactory = r, this.baseTransform = i } createPatternCanvas(e) { const t = this.operatorList, n = this.bbox, r = this.xstep, i = this.ystep, a = this.paintType, s = this.tilingType, o = this.color, l = this.canvasGraphicsFactory; Pl("TilingType: " + s); const c = n[0], u = n[1], d = n[2], h = n[3], f = Kl.singularValueDecompose2dScale(this.matrix), p = Kl.singularValueDecompose2dScale(this.baseTransform), m = [f[0] * p[0], f[1] * p[1]], g = this.getSizeAndScale(r, this.ctx.canvas.width, m[0]), v = this.getSizeAndScale(i, this.ctx.canvas.height, m[1]), b = e.cachedCanvases.getCanvas("pattern", g.size, v.size, !0), y = b.context, w = l.createCanvasGraphics(y); w.groupLevel = e.groupLevel, this.setFillAndStrokeStyleToContext(w, a, o); let x = c, _ = u, k = d, S = h; return c < 0 && (x = 0, k += Math.abs(c)), u < 0 && (_ = 0, S += Math.abs(u)), y.translate(-g.scale * x, -v.scale * _), w.transform(g.scale, 0, 0, v.scale, 0, 0), y.save(), this.clipBbox(w, x, _, k, S), w.baseTransform = tu(w.ctx), w.executeOperatorList(t), w.endDrawing(), { canvas: b.canvas, scaleX: g.scale, scaleY: v.scale, offsetX: x, offsetY: _ } } getSizeAndScale(e, t, n) { e = Math.abs(e); const r = Math.max(Tf.MAX_PATTERN_SIZE, t); let i = Math.ceil(e * n); return i >= r ? i = r : n = i / e, { scale: n, size: i } } clipBbox(e, t, n, r, i) { const a = r - t, s = i - n; e.ctx.rect(t, n, a, s), e.current.updateRectMinMax(tu(e.ctx), [t, n, r, i]), e.clip(), e.endPath() } setFillAndStrokeStyleToContext(e, t, n) { const r = e.ctx, i = e.current; switch (t) { case Cf: const e = this.ctx; r.fillStyle = e.fillStyle, r.strokeStyle = e.strokeStyle, i.fillColor = e.fillStyle, i.strokeColor = e.strokeStyle; break; case Mf: const a = Kl.makeHexColor(n[0], n[1], n[2]); r.fillStyle = a, r.strokeStyle = a, i.fillColor = a, i.strokeColor = a; break; default: throw new Hl("Unsupported paint type: ".concat(t)) } } getPattern(e, t, n, r) { let i = n; r !== yf && (i = Kl.transform(i, t.baseTransform), this.matrix && (i = Kl.transform(i, this.matrix))); const a = this.createPatternCanvas(t); let s = new DOMMatrix(i); s = s.translate(a.offsetX, a.offsetY), s = s.scale(1 / a.scaleX, 1 / a.scaleY); const o = e.createPattern(a.canvas, "repeat"); return o.setTransform(s), o } } function Pf(e) { let { src: t, srcPos: n = 0, dest: r, width: i, height: a, nonBlackColor: s = 4294967295, inverseDecode: o = !1 } = e; const l = Xl.isLittleEndian ? 4278190080 : 255, [c, u] = o ? [s, l] : [l, s], d = i >> 3, h = 7 & i, f = t.length; r = new Uint32Array(r.buffer); let p = 0; for (let m = 0; m < a; m++) { for (const i = n + d; n < i; n++) { const e = n < f ? t[n] : 255; r[p++] = 128 & e ? u : c, r[p++] = 64 & e ? u : c, r[p++] = 32 & e ? u : c, r[p++] = 16 & e ? u : c, r[p++] = 8 & e ? u : c, r[p++] = 4 & e ? u : c, r[p++] = 2 & e ? u : c, r[p++] = 1 & e ? u : c } if (0 === h) continue; const e = n < f ? t[n++] : 255; for (let t = 0; t < h; t++)r[p++] = e & 1 << 7 - t ? u : c } return { srcPos: n, destPos: p } } Eo(Tf, "MAX_PATTERN_SIZE", 3e3); const Rf = 16; class Nf { constructor(e) { this.canvasFactory = e, this.cache = Object.create(null) } getCanvas(e, t, n) { let r; return void 0 !== this.cache[e] ? (r = this.cache[e], this.canvasFactory.reset(r, t, n)) : (r = this.canvasFactory.create(t, n), this.cache[e] = r), r } delete(e) { delete this.cache[e] } clear() { for (const e in this.cache) { const t = this.cache[e]; this.canvasFactory.destroy(t), delete this.cache[e] } } } function Lf(e, t, n, r, i, a, s, o, l, c) { const [u, d, h, f, p, m] = tu(e); if (0 === d && 0 === h) { const g = s * u + p, v = Math.round(g), b = o * f + m, y = Math.round(b), w = (s + l) * u + p, x = Math.abs(Math.round(w) - v) || 1, _ = (o + c) * f + m, k = Math.abs(Math.round(_) - y) || 1; return e.setTransform(Math.sign(u), 0, 0, Math.sign(f), v, y), e.drawImage(t, n, r, i, a, 0, 0, x, k), e.setTransform(u, d, h, f, p, m), [x, k] } if (0 === u && 0 === f) { const g = o * h + p, v = Math.round(g), b = s * d + m, y = Math.round(b), w = (o + c) * h + p, x = Math.abs(Math.round(w) - v) || 1, _ = (s + l) * d + m, k = Math.abs(Math.round(_) - y) || 1; return e.setTransform(0, Math.sign(d), Math.sign(h), 0, v, y), e.drawImage(t, n, r, i, a, 0, 0, k, x), e.setTransform(u, d, h, f, p, m), [k, x] } e.drawImage(t, n, r, i, a, s, o, l, c); return [Math.hypot(u, d) * l, Math.hypot(h, f) * c] } class If { constructor(e, t) { this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = Lo, this.textMatrixScale = 1, this.fontMatrix = Io, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = Xo, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, e, t]) } clone() { const e = Object.create(this); return e.clipBox = this.clipBox.slice(), e } setCurrentPoint(e, t) { this.x = e, this.y = t } updatePathMinMax(e, t, n) { [t, n] = Kl.applyTransform([t, n], e), this.minX = Math.min(this.minX, t), this.minY = Math.min(this.minY, n), this.maxX = Math.max(this.maxX, t), this.maxY = Math.max(this.maxY, n) } updateRectMinMax(e, t) { const n = Kl.applyTransform(t, e), r = Kl.applyTransform(t.slice(2), e), i = Kl.applyTransform([t[0], t[3]], e), a = Kl.applyTransform([t[2], t[1]], e); this.minX = Math.min(this.minX, n[0], r[0], i[0], a[0]), this.minY = Math.min(this.minY, n[1], r[1], i[1], a[1]), this.maxX = Math.max(this.maxX, n[0], r[0], i[0], a[0]), this.maxY = Math.max(this.maxY, n[1], r[1], i[1], a[1]) } updateScalingPathMinMax(e, t) { Kl.scaleMinMax(e, t), this.minX = Math.min(this.minX, t[0]), this.minY = Math.min(this.minY, t[1]), this.maxX = Math.max(this.maxX, t[2]), this.maxY = Math.max(this.maxY, t[3]) } updateCurvePathMinMax(e, t, n, r, i, a, s, o, l, c) { const u = Kl.bezierBoundingBox(t, n, r, i, a, s, o, l, c); c || this.updateRectMinMax(e, u) } getPathBoundingBox() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vf, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const n = [this.minX, this.minY, this.maxX, this.maxY]; if (e === bf) { t || Nl("Stroke bounding box must include transform."); const e = Kl.singularValueDecompose2dScale(t), r = e[0] * this.lineWidth / 2, i = e[1] * this.lineWidth / 2; n[0] -= r, n[1] -= i, n[2] += r, n[3] += i } return n } updateClipFromPath() { const e = Kl.intersect(this.clipBox, this.getPathBoundingBox()); this.startNewPathAndClipBox(e || [0, 0, 0, 0]) } isEmptyClip() { return this.minX === 1 / 0 } startNewPathAndClipBox(e) { this.clipBox = e, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0 } getClippedPathBoundingBox() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vf, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return Kl.intersect(this.clipBox, this.getPathBoundingBox(e, t)) } } function Df(e, t) { if ("undefined" !== typeof ImageData && t instanceof ImageData) return void e.putImageData(t, 0, 0); const n = t.height, r = t.width, i = n % Rf, a = (n - i) / Rf, s = 0 === i ? a : a + 1, o = e.createImageData(r, Rf); let l, c = 0; const u = t.data, d = o.data; let h, f, p, m; if (t.kind === Zo.GRAYSCALE_1BPP) { const t = u.byteLength, n = new Uint32Array(d.buffer, 0, d.byteLength >> 2), m = n.length, g = r + 7 >> 3, v = 4294967295, b = Xl.isLittleEndian ? 4278190080 : 255; for (h = 0; h < s; h++) { for (p = h < a ? Rf : i, l = 0, f = 0; f < p; f++) { const e = t - c; let i = 0; const a = e > g ? r : 8 * e - 7, s = -8 & a; let o = 0, d = 0; for (; i < s; i += 8)d = u[c++], n[l++] = 128 & d ? v : b, n[l++] = 64 & d ? v : b, n[l++] = 32 & d ? v : b, n[l++] = 16 & d ? v : b, n[l++] = 8 & d ? v : b, n[l++] = 4 & d ? v : b, n[l++] = 2 & d ? v : b, n[l++] = 1 & d ? v : b; for (; i < a; i++)0 === o && (d = u[c++], o = 128), n[l++] = d & o ? v : b, o >>= 1 } for (; l < m;)n[l++] = 0; e.putImageData(o, 0, h * Rf) } } else if (t.kind === Zo.RGBA_32BPP) { for (f = 0, m = r * Rf * 4, h = 0; h < a; h++)d.set(u.subarray(c, c + m)), c += m, e.putImageData(o, 0, f), f += Rf; h < s && (m = r * i * 4, d.set(u.subarray(c, c + m)), e.putImageData(o, 0, f)) } else { if (t.kind !== Zo.RGB_24BPP) throw new Error("bad image kind: ".concat(t.kind)); for (p = Rf, m = r * p, h = 0; h < s; h++) { for (h >= a && (p = i, m = r * p), l = 0, f = m; f--;)d[l++] = u[c++], d[l++] = u[c++], d[l++] = u[c++], d[l++] = 255; e.putImageData(o, 0, h * Rf) } } } function Of(e, t) { if (t.bitmap) return void e.drawImage(t.bitmap, 0, 0); const n = t.height, r = t.width, i = n % Rf, a = (n - i) / Rf, s = 0 === i ? a : a + 1, o = e.createImageData(r, Rf); let l = 0; const c = t.data, u = o.data; for (let d = 0; d < s; d++) { const t = d < a ? Rf : i; ({ srcPos: l } = Pf({ src: c, srcPos: l, dest: u, width: r, height: t, nonBlackColor: 0 })), e.putImageData(o, 0, d * Rf) } } function jf(e, t) { const n = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"]; for (const r of n) void 0 !== e[r] && (t[r] = e[r]); void 0 !== e.setLineDash && (t.setLineDash(e.getLineDash()), t.lineDashOffset = e.lineDashOffset) } function Ff(e) { if (e.strokeStyle = e.fillStyle = "#000000", e.fillRule = "nonzero", e.globalAlpha = 1, e.lineWidth = 1, e.lineCap = "butt", e.lineJoin = "miter", e.miterLimit = 10, e.globalCompositeOperation = "source-over", e.font = "10px sans-serif", void 0 !== e.setLineDash && (e.setLineDash([]), e.lineDashOffset = 0), !No) { const { filter: t } = e; "none" !== t && "" !== t && (e.filter = "none") } } function zf(e, t) { if (t) return !0; const n = Kl.singularValueDecompose2dScale(e); n[0] = Math.fround(n[0]), n[1] = Math.fround(n[1]); const r = Math.fround((globalThis.devicePixelRatio || 1) * bc.PDF_TO_CSS_UNITS); return n[0] <= r && n[1] <= r } const Wf = ["butt", "round", "square"], Bf = ["miter", "round", "bevel"], Hf = {}, Uf = {}; var Vf = new WeakSet; class qf { constructor(e, t, n, r, i, a, s, o) { let { optionalContentConfig: l, markedContentStack: c = null } = a; xo(this, Vf), this.ctx = e, this.current = new If(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = n, this.canvasFactory = r, this.filterFactory = i, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = c || [], this.optionalContentConfig = l, this.cachedCanvases = new Nf(this.canvasFactory), this.cachedPatterns = new Map, this.annotationCanvasMap = s, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = o, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = new Map } getObject(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return "string" === typeof e ? e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e) : t } beginDrawing(e) { let { transform: t, viewport: n, transparency: r = !1, background: i = null } = e; const a = this.ctx.canvas.width, s = this.ctx.canvas.height, o = this.ctx.fillStyle; if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, a, s), this.ctx.fillStyle = o, r) { const e = this.cachedCanvases.getCanvas("transparent", a, s); this.compositeCtx = this.ctx, this.transparentCanvas = e.canvas, this.ctx = e.context, this.ctx.save(), this.ctx.transform(...tu(this.compositeCtx)) } this.ctx.save(), Ff(this.ctx), t && (this.ctx.transform(...t), this.outputScaleX = t[0], this.outputScaleY = t[0]), this.ctx.transform(...n.transform), this.viewportScale = n.scale, this.baseTransform = tu(this.ctx) } executeOperatorList(e, t, n, r) { const i = e.argsArray, a = e.fnArray; let s = t || 0; const o = i.length; if (o === s) return s; const l = o - s > 10 && "function" === typeof n, c = l ? Date.now() + 15 : 0; let u = 0; const d = this.commonObjs, h = this.objs; let f; for (; ;) { if (void 0 !== r && s === r.nextBreakPoint) return r.breakIt(s, n), s; if (f = a[s], f !== Al.dependency) this[f].apply(this, i[s]); else for (const e of i[s]) { const t = e.startsWith("g_") ? d : h; if (!t.has(e)) return t.get(e, n), s } if (s++, s === o) return s; if (l && ++u > 10) { if (Date.now() > c) return n(), s; u = 0 } } } endDrawing() { _o(Vf, this, Gf).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear(); for (const e of this._cachedBitmapsMap.values()) { for (const t of e.values()) "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement && (t.width = t.height = 0); e.clear() } this._cachedBitmapsMap.clear(), _o(Vf, this, Xf).call(this) } _scaleImage(e, t) { const n = e.width, r = e.height; let i, a, s = Math.max(Math.hypot(t[0], t[1]), 1), o = Math.max(Math.hypot(t[2], t[3]), 1), l = n, c = r, u = "prescale1"; for (; s > 2 && l > 1 || o > 2 && c > 1;) { let t = l, n = c; s > 2 && l > 1 && (t = l >= 16384 ? Math.floor(l / 2) - 1 || 1 : Math.ceil(l / 2), s /= l / t), o > 2 && c > 1 && (n = c >= 16384 ? Math.floor(c / 2) - 1 || 1 : Math.ceil(c) / 2, o /= c / n), i = this.cachedCanvases.getCanvas(u, t, n), a = i.context, a.clearRect(0, 0, t, n), a.drawImage(e, 0, 0, l, c, 0, 0, t, n), e = i.canvas, l = t, c = n, u = "prescale1" === u ? "prescale2" : "prescale1" } return { img: e, paintWidth: l, paintHeight: c } } _createMaskCanvas(e) { const t = this.ctx, { width: n, height: r } = e, i = this.current.fillColor, a = this.current.patternFill, s = tu(t); let o, l, c, u; if ((e.bitmap || e.data) && e.count > 1) { const t = e.bitmap || e.data.buffer; l = JSON.stringify(a ? s : [s.slice(0, 4), i]), o = this._cachedBitmapsMap.get(t), o || (o = new Map, this._cachedBitmapsMap.set(t, o)); const n = o.get(l); if (n && !a) { return { canvas: n, offsetX: Math.round(Math.min(s[0], s[2]) + s[4]), offsetY: Math.round(Math.min(s[1], s[3]) + s[5]) } } c = n } c || (u = this.cachedCanvases.getCanvas("maskCanvas", n, r), Of(u.context, e)); let d = Kl.transform(s, [1 / n, 0, 0, -1 / r, 0, 0]); d = Kl.transform(d, [1, 0, 0, 1, 0, -r]); const [h, f, p, m] = Kl.getAxialAlignedBoundingBox([0, 0, n, r], d), g = Math.round(p - h) || 1, v = Math.round(m - f) || 1, b = this.cachedCanvases.getCanvas("fillCanvas", g, v), y = b.context, w = h, x = f; y.translate(-w, -x), y.transform(...d), c || (c = this._scaleImage(u.canvas, nu(y)), c = c.img, o && a && o.set(l, c)), y.imageSmoothingEnabled = zf(tu(y), e.interpolate), Lf(y, c, 0, 0, c.width, c.height, 0, 0, n, r), y.globalCompositeOperation = "source-in"; const _ = Kl.transform(nu(y), [1, 0, 0, 1, -w, -x]); return y.fillStyle = a ? i.getPattern(t, this, _, vf) : i, y.fillRect(0, 0, n, r), o && !a && (this.cachedCanvases.delete("fillCanvas"), o.set(l, b.canvas)), { canvas: b.canvas, offsetX: Math.round(w), offsetY: Math.round(x) } } setLineWidth(e) { e !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e, this.ctx.lineWidth = e } setLineCap(e) { this.ctx.lineCap = Wf[e] } setLineJoin(e) { this.ctx.lineJoin = Bf[e] } setMiterLimit(e) { this.ctx.miterLimit = e } setDash(e, t) { const n = this.ctx; void 0 !== n.setLineDash && (n.setLineDash(e), n.lineDashOffset = t) } setRenderingIntent(e) { } setFlatness(e) { } setGState(e) { for (const [t, n] of e) switch (t) { case "LW": this.setLineWidth(n); break; case "LC": this.setLineCap(n); break; case "LJ": this.setLineJoin(n); break; case "ML": this.setMiterLimit(n); break; case "D": this.setDash(n[0], n[1]); break; case "RI": this.setRenderingIntent(n); break; case "FL": this.setFlatness(n); break; case "Font": this.setFont(n[0], n[1]); break; case "CA": this.current.strokeAlpha = n; break; case "ca": this.current.fillAlpha = n, this.ctx.globalAlpha = n; break; case "BM": this.ctx.globalCompositeOperation = n; break; case "SMask": this.current.activeSMask = n ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState(); break; case "TR": this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(n) } } get inSMaskMode() { return !!this.suspendedCtx } checkSMaskState() { const e = this.inSMaskMode; this.current.activeSMask && !e ? this.beginSMaskMode() : !this.current.activeSMask && e && this.endSMaskMode() } beginSMaskMode() { if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode"); const e = this.ctx.canvas.width, t = this.ctx.canvas.height, n = "smaskGroupAt" + this.groupLevel, r = this.cachedCanvases.getCanvas(n, e, t); this.suspendedCtx = this.ctx, this.ctx = r.context; const i = this.ctx; i.setTransform(...tu(this.suspendedCtx)), jf(this.suspendedCtx, i), function (e, t) { if (e._removeMirroring) throw new Error("Context is already forwarding operations."); e.__originalSave = e.save, e.__originalRestore = e.restore, e.__originalRotate = e.rotate, e.__originalScale = e.scale, e.__originalTranslate = e.translate, e.__originalTransform = e.transform, e.__originalSetTransform = e.setTransform, e.__originalResetTransform = e.resetTransform, e.__originalClip = e.clip, e.__originalMoveTo = e.moveTo, e.__originalLineTo = e.lineTo, e.__originalBezierCurveTo = e.bezierCurveTo, e.__originalRect = e.rect, e.__originalClosePath = e.closePath, e.__originalBeginPath = e.beginPath, e._removeMirroring = () => { e.save = e.__originalSave, e.restore = e.__originalRestore, e.rotate = e.__originalRotate, e.scale = e.__originalScale, e.translate = e.__originalTranslate, e.transform = e.__originalTransform, e.setTransform = e.__originalSetTransform, e.resetTransform = e.__originalResetTransform, e.clip = e.__originalClip, e.moveTo = e.__originalMoveTo, e.lineTo = e.__originalLineTo, e.bezierCurveTo = e.__originalBezierCurveTo, e.rect = e.__originalRect, e.closePath = e.__originalClosePath, e.beginPath = e.__originalBeginPath, delete e._removeMirroring }, e.save = function () { t.save(), this.__originalSave() }, e.restore = function () { t.restore(), this.__originalRestore() }, e.translate = function (e, n) { t.translate(e, n), this.__originalTranslate(e, n) }, e.scale = function (e, n) { t.scale(e, n), this.__originalScale(e, n) }, e.transform = function (e, n, r, i, a, s) { t.transform(e, n, r, i, a, s), this.__originalTransform(e, n, r, i, a, s) }, e.setTransform = function (e, n, r, i, a, s) { t.setTransform(e, n, r, i, a, s), this.__originalSetTransform(e, n, r, i, a, s) }, e.resetTransform = function () { t.resetTransform(), this.__originalResetTransform() }, e.rotate = function (e) { t.rotate(e), this.__originalRotate(e) }, e.clip = function (e) { t.clip(e), this.__originalClip(e) }, e.moveTo = function (e, n) { t.moveTo(e, n), this.__originalMoveTo(e, n) }, e.lineTo = function (e, n) { t.lineTo(e, n), this.__originalLineTo(e, n) }, e.bezierCurveTo = function (e, n, r, i, a, s) { t.bezierCurveTo(e, n, r, i, a, s), this.__originalBezierCurveTo(e, n, r, i, a, s) }, e.rect = function (e, n, r, i) { t.rect(e, n, r, i), this.__originalRect(e, n, r, i) }, e.closePath = function () { t.closePath(), this.__originalClosePath() }, e.beginPath = function () { t.beginPath(), this.__originalBeginPath() } }(i, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]) } endSMaskMode() { if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode"); this.ctx._removeMirroring(), jf(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null } compose(e) { if (!this.current.activeSMask) return; e ? (e[0] = Math.floor(e[0]), e[1] = Math.floor(e[1]), e[2] = Math.ceil(e[2]), e[3] = Math.ceil(e[3])) : e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]; const t = this.current.activeSMask, n = this.suspendedCtx; this.composeSMask(n, t, this.ctx, e), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore() } composeSMask(e, t, n, r) { const i = r[0], a = r[1], s = r[2] - i, o = r[3] - a; 0 !== s && 0 !== o && (this.genericComposeSMask(t.context, n, s, o, t.subtype, t.backdrop, t.transferMap, i, a, t.offsetX, t.offsetY), e.save(), e.globalAlpha = 1, e.globalCompositeOperation = "source-over", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(n.canvas, 0, 0), e.restore()) } genericComposeSMask(e, t, n, r, i, a, s, o, l, c, u) { let d = e.canvas, h = o - c, f = l - u; if (a) if (h < 0 || f < 0 || h + n > d.width || f + r > d.height) { const e = this.cachedCanvases.getCanvas("maskExtension", n, r), t = e.context; t.drawImage(d, -h, -f), a.some((e => 0 !== e)) && (t.globalCompositeOperation = "destination-atop", t.fillStyle = Kl.makeHexColor(...a), t.fillRect(0, 0, n, r), t.globalCompositeOperation = "source-over"), d = e.canvas, h = f = 0 } else if (a.some((e => 0 !== e))) { e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0); const t = new Path2D; t.rect(h, f, n, r), e.clip(t), e.globalCompositeOperation = "destination-atop", e.fillStyle = Kl.makeHexColor(...a), e.fillRect(h, f, n, r), e.restore() } t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0), "Alpha" === i && s ? t.filter = this.filterFactory.addAlphaFilter(s) : "Luminosity" === i && (t.filter = this.filterFactory.addLuminosityFilter(s)); const p = new Path2D; p.rect(o, l, n, r), t.clip(p), t.globalCompositeOperation = "destination-in", t.drawImage(d, h, f, n, r, o, l, n, r), t.restore() } save() { this.inSMaskMode ? (jf(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save(); const e = this.current; this.stateStack.push(e), this.current = e.clone() } restore() { 0 === this.stateStack.length && this.inSMaskMode && this.endSMaskMode(), 0 !== this.stateStack.length && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), jf(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null) } transform(e, t, n, r, i, a) { this.ctx.transform(e, t, n, r, i, a), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null } constructPath(e, t, n) { const r = this.ctx, i = this.current; let a, s, o = i.x, l = i.y; const c = tu(r), u = 0 === c[0] && 0 === c[3] || 0 === c[1] && 0 === c[2], d = u ? n.slice(0) : null; for (let h = 0, f = 0, p = e.length; h < p; h++)switch (0 | e[h]) { case Al.rectangle: o = t[f++], l = t[f++]; const e = t[f++], n = t[f++], h = o + e, p = l + n; r.moveTo(o, l), 0 === e || 0 === n ? r.lineTo(h, p) : (r.lineTo(h, l), r.lineTo(h, p), r.lineTo(o, p)), u || i.updateRectMinMax(c, [o, l, h, p]), r.closePath(); break; case Al.moveTo: o = t[f++], l = t[f++], r.moveTo(o, l), u || i.updatePathMinMax(c, o, l); break; case Al.lineTo: o = t[f++], l = t[f++], r.lineTo(o, l), u || i.updatePathMinMax(c, o, l); break; case Al.curveTo: a = o, s = l, o = t[f + 4], l = t[f + 5], r.bezierCurveTo(t[f], t[f + 1], t[f + 2], t[f + 3], o, l), i.updateCurvePathMinMax(c, a, s, t[f], t[f + 1], t[f + 2], t[f + 3], o, l, d), f += 6; break; case Al.curveTo2: a = o, s = l, r.bezierCurveTo(o, l, t[f], t[f + 1], t[f + 2], t[f + 3]), i.updateCurvePathMinMax(c, a, s, o, l, t[f], t[f + 1], t[f + 2], t[f + 3], d), o = t[f + 2], l = t[f + 3], f += 4; break; case Al.curveTo3: a = o, s = l, o = t[f + 2], l = t[f + 3], r.bezierCurveTo(t[f], t[f + 1], o, l, o, l), i.updateCurvePathMinMax(c, a, s, t[f], t[f + 1], o, l, o, l, d), f += 4; break; case Al.closePath: r.closePath() }u && i.updateScalingPathMinMax(c, d), i.setCurrentPoint(o, l) } closePath() { this.ctx.closePath() } stroke() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const t = this.ctx, n = this.current.strokeColor; t.globalAlpha = this.current.strokeAlpha, this.contentVisible && ("object" === typeof n && null !== n && void 0 !== n && n.getPattern ? (t.save(), t.strokeStyle = n.getPattern(t, this, nu(t), bf), this.rescaleAndStroke(!1), t.restore()) : this.rescaleAndStroke(!0)), e && this.consumePath(this.current.getClippedPathBoundingBox()), t.globalAlpha = this.current.fillAlpha } closeStroke() { this.closePath(), this.stroke() } fill() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const t = this.ctx, n = this.current.fillColor; let r = !1; this.current.patternFill && (t.save(), t.fillStyle = n.getPattern(t, this, nu(t), vf), r = !0); const i = this.current.getClippedPathBoundingBox(); this.contentVisible && null !== i && (this.pendingEOFill ? (t.fill("evenodd"), this.pendingEOFill = !1) : t.fill()), r && t.restore(), e && this.consumePath(i) } eoFill() { this.pendingEOFill = !0, this.fill() } fillStroke() { this.fill(!1), this.stroke(!1), this.consumePath() } eoFillStroke() { this.pendingEOFill = !0, this.fillStroke() } closeFillStroke() { this.closePath(), this.fillStroke() } closeEOFillStroke() { this.pendingEOFill = !0, this.closePath(), this.fillStroke() } endPath() { this.consumePath() } clip() { this.pendingClip = Hf } eoClip() { this.pendingClip = Uf } beginText() { this.current.textMatrix = Lo, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0 } endText() { const e = this.pendingTextPaths, t = this.ctx; if (void 0 !== e) { t.save(), t.beginPath(); for (const n of e) t.setTransform(...n.transform), t.translate(n.x, n.y), n.addToPath(t, n.fontSize); t.restore(), t.clip(), t.beginPath(), delete this.pendingTextPaths } else t.beginPath() } setCharSpacing(e) { this.current.charSpacing = e } setWordSpacing(e) { this.current.wordSpacing = e } setHScale(e) { this.current.textHScale = e / 100 } setLeading(e) { this.current.leading = -e } setFont(e, t) { var n; const r = this.commonObjs.get(e), i = this.current; if (!r) throw new Error("Can't find font for ".concat(e)); if (i.fontMatrix = r.fontMatrix || Io, 0 !== i.fontMatrix[0] && 0 !== i.fontMatrix[3] || Rl("Invalid font matrix for font " + e), t < 0 ? (t = -t, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = r, this.current.fontSize = t, r.isType3Font) return; const a = r.loadedName || "sans-serif", s = (null === (n = r.systemFontInfo) || void 0 === n ? void 0 : n.css) || '"'.concat(a, '", ').concat(r.fallbackName); let o = "normal"; r.black ? o = "900" : r.bold && (o = "bold"); const l = r.italic ? "italic" : "normal"; let c = t; t < 16 ? c = 16 : t > 100 && (c = 100), this.current.fontSizeScale = t / c, this.ctx.font = "".concat(l, " ").concat(o, " ").concat(c, "px ").concat(s) } setTextRenderingMode(e) { this.current.textRenderingMode = e } setTextRise(e) { this.current.textRise = e } moveText(e, t) { this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += t } setLeadingMoveText(e, t) { this.setLeading(-t), this.moveText(e, t) } setTextMatrix(e, t, n, r, i, a) { this.current.textMatrix = [e, t, n, r, i, a], this.current.textMatrixScale = Math.hypot(e, t), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0 } nextLine() { this.moveText(0, this.current.leading) } paintChar(e, t, n, r) { const i = this.ctx, a = this.current, s = a.font, o = a.textRenderingMode, l = a.fontSize / a.fontSizeScale, c = o & $o, u = !!(o & Jo), d = a.patternFill && !s.missingFile; let h; if ((s.disableFontFace || u || d) && (h = s.getPathGenerator(this.commonObjs, e)), s.disableFontFace || d ? (i.save(), i.translate(t, n), i.beginPath(), h(i, l), r && i.setTransform(...r), c !== Xo && c !== Ko || i.fill(), c !== Yo && c !== Ko || i.stroke(), i.restore()) : (c !== Xo && c !== Ko || i.fillText(e, t, n), c !== Yo && c !== Ko || i.strokeText(e, t, n)), u) { (this.pendingTextPaths || (this.pendingTextPaths = [])).push({ transform: tu(i), x: t, y: n, fontSize: l, addToPath: h }) } } get isFontSubpixelAAEnabled() { const { context: e } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10); e.scale(1.5, 1), e.fillText("I", 0, 10); const t = e.getImageData(0, 0, 10, 10).data; let n = !1; for (let r = 3; r < t.length; r += 4)if (t[r] > 0 && t[r] < 255) { n = !0; break } return Dl(this, "isFontSubpixelAAEnabled", n) } showText(e) { const t = this.current, n = t.font; if (n.isType3Font) return this.showType3Text(e); const r = t.fontSize; if (0 === r) return; const i = this.ctx, a = t.fontSizeScale, s = t.charSpacing, o = t.wordSpacing, l = t.fontDirection, c = t.textHScale * l, u = e.length, d = n.vertical, h = d ? 1 : -1, f = n.defaultVMetrics, p = r * t.fontMatrix[0], m = t.textRenderingMode === Xo && !n.disableFontFace && !t.patternFill; let g; if (i.save(), i.transform(...t.textMatrix), i.translate(t.x, t.y + t.textRise), l > 0 ? i.scale(c, -1) : i.scale(c, 1), t.patternFill) { i.save(); const e = t.fillColor.getPattern(i, this, nu(i), vf); g = tu(i), i.restore(), i.fillStyle = e } let v = t.lineWidth; const b = t.textMatrixScale; if (0 === b || 0 === v) { const e = t.textRenderingMode & $o; e !== Yo && e !== Ko || (v = this.getSinglePixelWidth()) } else v /= b; if (1 !== a && (i.scale(a, a), v /= a), i.lineWidth = v, n.isInvalidPDFjsFont) { const n = []; let r = 0; for (const t of e) n.push(t.unicode), r += t.width; return i.fillText(n.join(""), 0, 0), t.x += r * p * c, i.restore(), void this.compose() } let y, w = 0; for (y = 0; y < u; ++y) { const t = e[y]; if ("number" === typeof t) { w += h * t * r / 1e3; continue } let c = !1; const u = (t.isSpace ? o : 0) + s, v = t.fontChar, b = t.accent; let x, _, k = t.width; if (d) { const e = t.vmetric || f, n = -(t.vmetric ? e[1] : .5 * k) * p, r = e[2] * p; k = e ? -e[0] : k, x = n / a, _ = (w + r) / a } else x = w / a, _ = 0; if (n.remeasure && k > 0) { const e = 1e3 * i.measureText(v).width / r * a; if (k < e && this.isFontSubpixelAAEnabled) { const t = k / e; c = !0, i.save(), i.scale(t, 1), x /= t } else k !== e && (x += (k - e) / 2e3 * r / a) } if (this.contentVisible && (t.isInFont || n.missingFile)) if (m && !b) i.fillText(v, x, _); else if (this.paintChar(v, x, _, g), b) { const e = x + r * b.offset.x / a, t = _ - r * b.offset.y / a; this.paintChar(b.fontChar, e, t, g) } w += d ? k * p - u * l : k * p + u * l, c && i.restore() } d ? t.y -= w : t.x += w * c, i.restore(), this.compose() } showType3Text(e) { const t = this.ctx, n = this.current, r = n.font, i = n.fontSize, a = n.fontDirection, s = r.vertical ? 1 : -1, o = n.charSpacing, l = n.wordSpacing, c = n.textHScale * a, u = n.fontMatrix || Io, d = e.length; let h, f, p, m; if (!(n.textRenderingMode === Qo) && 0 !== i) { for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, t.save(), t.transform(...n.textMatrix), t.translate(n.x, n.y), t.scale(c, a), h = 0; h < d; ++h) { if (f = e[h], "number" === typeof f) { m = s * f * i / 1e3, this.ctx.translate(m, 0), n.x += m * c; continue } const a = (f.isSpace ? l : 0) + o, d = r.charProcOperatorList[f.operatorListId]; if (!d) { Rl('Type3 character "'.concat(f.operatorListId, '" is not available.')); continue } this.contentVisible && (this.processingType3 = f, this.save(), t.scale(i, i), t.transform(...u), this.executeOperatorList(d), this.restore()); p = Kl.applyTransform([f.width, 0], u)[0] * i + a, t.translate(p, 0), n.x += p * c } t.restore(), this.processingType3 = null } } setCharWidth(e, t) { } setCharWidthAndBounds(e, t, n, r, i, a) { this.ctx.rect(n, r, i - n, a - r), this.ctx.clip(), this.endPath() } getColorN_Pattern(e) { let t; if ("TilingPattern" === e[0]) { const n = e[1], r = this.baseTransform || tu(this.ctx), i = { createCanvasGraphics: e => new qf(e, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) }; t = new Tf(e, n, this.ctx, i, r) } else t = this._getPattern(e[1], e[2]); return t } setStrokeColorN() { this.current.strokeColor = this.getColorN_Pattern(arguments) } setFillColorN() { this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0 } setStrokeRGBColor(e, t, n) { const r = Kl.makeHexColor(e, t, n); this.ctx.strokeStyle = r, this.current.strokeColor = r } setFillRGBColor(e, t, n) { const r = Kl.makeHexColor(e, t, n); this.ctx.fillStyle = r, this.current.fillColor = r, this.current.patternFill = !1 } _getPattern(e) { let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return this.cachedPatterns.has(e) ? t = this.cachedPatterns.get(e) : (t = function (e) { switch (e[0]) { case "RadialAxial": return new _f(e); case "Mesh": return new Af(e); case "Dummy": return new Ef }throw new Error("Unknown IR type: ".concat(e[0])) }(this.getObject(e)), this.cachedPatterns.set(e, t)), n && (t.matrix = n), t } shadingFill(e) { if (!this.contentVisible) return; const t = this.ctx; this.save(); const n = this._getPattern(e); t.fillStyle = n.getPattern(t, this, nu(t), yf); const r = nu(t); if (r) { const { width: e, height: n } = t.canvas, [i, a, s, o] = Kl.getAxialAlignedBoundingBox([0, 0, e, n], r); this.ctx.fillRect(i, a, s - i, o - a) } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); this.compose(this.current.getClippedPathBoundingBox()), this.restore() } beginInlineImage() { Nl("Should not call beginInlineImage") } beginImageData() { Nl("Should not call beginImageData") } paintFormXObjectBegin(e, t) { if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), e && this.transform(...e), this.baseTransform = tu(this.ctx), t)) { const e = t[2] - t[0], n = t[3] - t[1]; this.ctx.rect(t[0], t[1], e, n), this.current.updateRectMinMax(tu(this.ctx), t), this.clip(), this.endPath() } } paintFormXObjectEnd() { this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop()) } beginGroup(e) { if (!this.contentVisible) return; this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null); const t = this.ctx; e.isolated || Pl("TODO: Support non-isolated groups."), e.knockout && Rl("Knockout groups not supported."); const n = tu(t); if (e.matrix && t.transform(...e.matrix), !e.bbox) throw new Error("Bounding box is required."); let r = Kl.getAxialAlignedBoundingBox(e.bbox, tu(t)); const i = [0, 0, t.canvas.width, t.canvas.height]; r = Kl.intersect(r, i) || [0, 0, 0, 0]; const a = Math.floor(r[0]), s = Math.floor(r[1]), o = Math.max(Math.ceil(r[2]) - a, 1), l = Math.max(Math.ceil(r[3]) - s, 1); this.current.startNewPathAndClipBox([0, 0, o, l]); let c = "groupAt" + this.groupLevel; e.smask && (c += "_smask_" + this.smaskCounter++ % 2); const u = this.cachedCanvases.getCanvas(c, o, l), d = u.context; d.translate(-a, -s), d.transform(...n), e.smask ? this.smaskStack.push({ canvas: u.canvas, context: d, offsetX: a, offsetY: s, subtype: e.smask.subtype, backdrop: e.smask.backdrop, transferMap: e.smask.transferMap || null, startTransformInverse: null }) : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(a, s), t.save()), jf(t, d), this.ctx = d, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(t), this.groupLevel++ } endGroup(e) { if (!this.contentVisible) return; this.groupLevel--; const t = this.ctx, n = this.groupStack.pop(); if (this.ctx = n, this.ctx.imageSmoothingEnabled = !1, e.smask) this.tempSMask = this.smaskStack.pop(), this.restore(); else { this.ctx.restore(); const e = tu(this.ctx); this.restore(), this.ctx.save(), this.ctx.setTransform(...e); const n = Kl.getAxialAlignedBoundingBox([0, 0, t.canvas.width, t.canvas.height], e); this.ctx.drawImage(t.canvas, 0, 0), this.ctx.restore(), this.compose(n) } } beginAnnotation(e, t, n, r, i) { if (_o(Vf, this, Gf).call(this), Ff(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), t) { const r = t[2] - t[0], a = t[3] - t[1]; if (i && this.annotationCanvasMap) { (n = n.slice())[4] -= t[0], n[5] -= t[1], (t = t.slice())[0] = t[1] = 0, t[2] = r, t[3] = a; const [i, s] = Kl.singularValueDecompose2dScale(tu(this.ctx)), { viewportScale: o } = this, l = Math.ceil(r * this.outputScaleX * o), c = Math.ceil(a * this.outputScaleY * o); this.annotationCanvas = this.canvasFactory.create(l, c); const { canvas: u, context: d } = this.annotationCanvas; this.annotationCanvasMap.set(e, u), this.annotationCanvas.savedCtx = this.ctx, this.ctx = d, this.ctx.save(), this.ctx.setTransform(i, 0, 0, -s, 0, a * s), Ff(this.ctx) } else Ff(this.ctx), this.ctx.rect(t[0], t[1], r, a), this.ctx.clip(), this.endPath() } this.current = new If(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...n), this.transform(...r) } endAnnotation() { this.annotationCanvas && (this.ctx.restore(), _o(Vf, this, Xf).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas) } paintImageMaskXObject(e) { if (!this.contentVisible) return; const t = e.count; (e = this.getObject(e.data, e)).count = t; const n = this.ctx, r = this.processingType3; if (r && (void 0 === r.compiled && (r.compiled = function (e) { const { width: t, height: n } = e; if (t > 1e3 || n > 1e3) return null; const r = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), i = t + 1; let a, s, o, l = new Uint8Array(i * (n + 1)); const c = t + 7 & -8; let u = new Uint8Array(c * n), d = 0; for (const m of e.data) { let e = 128; for (; e > 0;)u[d++] = m & e ? 0 : 255, e >>= 1 } let h = 0; for (d = 0, 0 !== u[d] && (l[0] = 1, ++h), s = 1; s < t; s++)u[d] !== u[d + 1] && (l[s] = u[d] ? 2 : 1, ++h), d++; for (0 !== u[d] && (l[s] = 2, ++h), a = 1; a < n; a++) { d = a * c, o = a * i, u[d - c] !== u[d] && (l[o] = u[d] ? 1 : 8, ++h); let e = (u[d] ? 4 : 0) + (u[d - c] ? 8 : 0); for (s = 1; s < t; s++)e = (e >> 2) + (u[d + 1] ? 4 : 0) + (u[d - c + 1] ? 8 : 0), r[e] && (l[o + s] = r[e], ++h), d++; if (u[d - c] !== u[d] && (l[o + s] = u[d] ? 2 : 4, ++h), h > 1e3) return null } for (d = c * (n - 1), o = a * i, 0 !== u[d] && (l[o] = 8, ++h), s = 1; s < t; s++)u[d] !== u[d + 1] && (l[o + s] = u[d] ? 4 : 8, ++h), d++; if (0 !== u[d] && (l[o + s] = 4, ++h), h > 1e3) return null; const f = new Int32Array([0, i, -1, 0, -i, 0, 0, 0, 1]), p = new Path2D; for (a = 0; h && a <= n; a++) { let e = a * i; const n = e + t; for (; e < n && !l[e];)e++; if (e === n) continue; p.moveTo(e % i, a); const r = e; let s = l[e]; do { const t = f[s]; do { e += t } while (!l[e]); const n = l[e]; 5 !== n && 10 !== n ? (s = n, l[e] = 0) : (s = n & 51 * s >> 4, l[e] &= s >> 2 | s << 2), p.lineTo(e % i, e / i | 0), l[e] || --h } while (r !== e); --a } return u = null, l = null, function (e) { e.save(), e.scale(1 / t, -1 / n), e.translate(0, -n), e.fill(p), e.beginPath(), e.restore() } }(e)), r.compiled)) return void r.compiled(n); const i = this._createMaskCanvas(e), a = i.canvas; n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.drawImage(a, i.offsetX, i.offsetY), n.restore(), this.compose() } paintImageMaskXObjectRepeat(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = arguments.length > 4 ? arguments[4] : void 0, a = arguments.length > 5 ? arguments[5] : void 0; if (!this.contentVisible) return; e = this.getObject(e.data, e); const s = this.ctx; s.save(); const o = tu(s); s.transform(t, n, r, i, 0, 0); const l = this._createMaskCanvas(e); s.setTransform(1, 0, 0, 1, l.offsetX - o[4], l.offsetY - o[5]); for (let c = 0, u = a.length; c < u; c += 2) { const e = Kl.transform(o, [t, n, r, i, a[c], a[c + 1]]), [u, d] = Kl.applyTransform([0, 0], e); s.drawImage(l.canvas, u, d) } s.restore(), this.compose() } paintImageMaskXObjectGroup(e) { if (!this.contentVisible) return; const t = this.ctx, n = this.current.fillColor, r = this.current.patternFill; for (const i of e) { const { data: e, width: a, height: s, transform: o } = i, l = this.cachedCanvases.getCanvas("maskCanvas", a, s), c = l.context; c.save(); Of(c, this.getObject(e, i)), c.globalCompositeOperation = "source-in", c.fillStyle = r ? n.getPattern(c, this, nu(t), vf) : n, c.fillRect(0, 0, a, s), c.restore(), t.save(), t.transform(...o), t.scale(1, -1), Lf(t, l.canvas, 0, 0, a, s, 0, -1, 1, 1), t.restore() } this.compose() } paintImageXObject(e) { if (!this.contentVisible) return; const t = this.getObject(e); t ? this.paintInlineImageXObject(t) : Rl("Dependent image isn't ready yet") } paintImageXObjectRepeat(e, t, n, r) { if (!this.contentVisible) return; const i = this.getObject(e); if (!i) return void Rl("Dependent image isn't ready yet"); const a = i.width, s = i.height, o = []; for (let l = 0, c = r.length; l < c; l += 2)o.push({ transform: [t, 0, 0, n, r[l], r[l + 1]], x: 0, y: 0, w: a, h: s }); this.paintInlineImageXObjectGroup(i, o) } applyTransferMapsToCanvas(e) { return "none" !== this.current.transferMaps && (e.filter = this.current.transferMaps, e.drawImage(e.canvas, 0, 0), e.filter = "none"), e.canvas } applyTransferMapsToBitmap(e) { if ("none" === this.current.transferMaps) return e.bitmap; const { bitmap: t, width: n, height: r } = e, i = this.cachedCanvases.getCanvas("inlineImage", n, r), a = i.context; return a.filter = this.current.transferMaps, a.drawImage(t, 0, 0), a.filter = "none", i.canvas } paintInlineImageXObject(e) { if (!this.contentVisible) return; const t = e.width, n = e.height, r = this.ctx; if (this.save(), !No) { const { filter: e } = r; "none" !== e && "" !== e && (r.filter = "none") } let i; if (r.scale(1 / t, -1 / n), e.bitmap) i = this.applyTransferMapsToBitmap(e); else if ("function" === typeof HTMLElement && e instanceof HTMLElement || !e.data) i = e; else { const r = this.cachedCanvases.getCanvas("inlineImage", t, n).context; Df(r, e), i = this.applyTransferMapsToCanvas(r) } const a = this._scaleImage(i, nu(r)); r.imageSmoothingEnabled = zf(tu(r), e.interpolate), Lf(r, a.img, 0, 0, a.paintWidth, a.paintHeight, 0, -n, t, n), this.compose(), this.restore() } paintInlineImageXObjectGroup(e, t) { if (!this.contentVisible) return; const n = this.ctx; let r; if (e.bitmap) r = e.bitmap; else { const t = e.width, n = e.height, i = this.cachedCanvases.getCanvas("inlineImage", t, n).context; Df(i, e), r = this.applyTransferMapsToCanvas(i) } for (const i of t) n.save(), n.transform(...i.transform), n.scale(1, -1), Lf(n, r, i.x, i.y, i.w, i.h, 0, -1, 1, 1), n.restore(); this.compose() } paintSolidColorImageMask() { this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose()) } markPoint(e) { } markPointProps(e, t) { } beginMarkedContent(e) { this.markedContentStack.push({ visible: !0 }) } beginMarkedContentProps(e, t) { "OC" === e ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(t) }) : this.markedContentStack.push({ visible: !0 }), this.contentVisible = this.isContentVisible() } endMarkedContent() { this.markedContentStack.pop(), this.contentVisible = this.isContentVisible() } beginCompat() { } endCompat() { } consumePath(e) { const t = this.current.isEmptyClip(); this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(e); const n = this.ctx; this.pendingClip && (t || (this.pendingClip === Uf ? n.clip("evenodd") : n.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), n.beginPath() } getSinglePixelWidth() { if (!this._cachedGetSinglePixelWidth) { const e = tu(this.ctx); if (0 === e[1] && 0 === e[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e[0]), Math.abs(e[3])); else { const t = Math.abs(e[0] * e[3] - e[2] * e[1]), n = Math.hypot(e[0], e[2]), r = Math.hypot(e[1], e[3]); this._cachedGetSinglePixelWidth = Math.max(n, r) / t } } return this._cachedGetSinglePixelWidth } getScaleForStroking() { if (-1 === this._cachedScaleForStroking[0]) { const { lineWidth: e } = this.current, { a: t, b: n, c: r, d: i } = this.ctx.getTransform(); let a, s; if (0 === n && 0 === r) { const n = Math.abs(t), r = Math.abs(i); if (n === r) if (0 === e) a = s = 1 / n; else { const t = n * e; a = s = t < 1 ? 1 / t : 1 } else if (0 === e) a = 1 / n, s = 1 / r; else { const t = n * e, i = r * e; a = t < 1 ? 1 / t : 1, s = i < 1 ? 1 / i : 1 } } else { const o = Math.abs(t * i - n * r), l = Math.hypot(t, n), c = Math.hypot(r, i); if (0 === e) a = c / o, s = l / o; else { const t = e * o; a = c > t ? c / t : 1, s = l > t ? l / t : 1 } } this._cachedScaleForStroking[0] = a, this._cachedScaleForStroking[1] = s } return this._cachedScaleForStroking } rescaleAndStroke(e) { const { ctx: t } = this, { lineWidth: n } = this.current, [r, i] = this.getScaleForStroking(); if (t.lineWidth = n || 1, 1 === r && 1 === i) return void t.stroke(); const a = t.getLineDash(); if (e && t.save(), t.scale(r, i), a.length > 0) { const e = Math.max(r, i); t.setLineDash(a.map((t => t / e))), t.lineDashOffset /= e } t.stroke(), e && t.restore() } isContentVisible() { for (let e = this.markedContentStack.length - 1; e >= 0; e--)if (!this.markedContentStack[e].visible) return !1; return !0 } } function Gf() { for (; this.stateStack.length || this.inSMaskMode;)this.restore(); this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null) } function Xf() { if (this.pageColors) { const e = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background); if ("none" !== e) { const t = this.ctx.filter; this.ctx.filter = e, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t } } } for (const PC in Al) void 0 !== qf.prototype[PC] && (qf.prototype[Al[PC]] = qf.prototype[PC]); class Yf { static get workerPort() { return _o(Yf, this, Kf)._ } static set workerPort(e) { if (!("undefined" !== typeof Worker && e instanceof Worker) && null !== e) throw new Error("Invalid `workerPort` type."); Kf._ = _o(Yf, this, e) } static get workerSrc() { return _o(Yf, this, Qf)._ } static set workerSrc(e) { if ("string" !== typeof e) throw new Error("Invalid `workerSrc` type."); Qf._ = _o(Yf, this, e) } } var Kf = { _: null }, Qf = { _: "" }; const $f = 1, Jf = 2, Zf = 1, ep = 2, tp = 3, np = 4, rp = 5, ip = 6, ap = 7, sp = 8; function op(e) { switch (e instanceof Error || "object" === typeof e && null !== e || Nl('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e.name) { case "AbortException": return new Ul(e.message); case "MissingPDFException": return new Wl(e.message); case "PasswordException": return new jl(e.message, e.code); case "UnexpectedResponseException": return new Bl(e.message, e.status); case "UnknownErrorException": return new Fl(e.message, e.details); default: return new Fl(e.message, e.toString()) } } var lp = new WeakSet; class cp { constructor(e, t, n) { xo(this, lp), this.sourceName = e, this.targetName = t, this.comObj = n, this.callbackId = 1, this.streamId = 1, this.streamSinks = Object.create(null), this.streamControllers = Object.create(null), this.callbackCapabilities = Object.create(null), this.actionHandler = Object.create(null), this._onComObjOnMessage = e => { const t = e.data; if (t.targetName !== this.sourceName) return; if (t.stream) return void _o(lp, this, dp).call(this, t); if (t.callback) { const e = t.callbackId, n = this.callbackCapabilities[e]; if (!n) throw new Error("Cannot resolve callback ".concat(e)); if (delete this.callbackCapabilities[e], t.callback === $f) n.resolve(t.data); else { if (t.callback !== Jf) throw new Error("Unexpected callback case"); n.reject(op(t.reason)) } return } const r = this.actionHandler[t.action]; if (!r) throw new Error("Unknown action from worker: ".concat(t.action)); if (t.callbackId) { const e = this.sourceName, i = t.sourceName; new Promise((function (e) { e(r(t.data)) })).then((function (r) { n.postMessage({ sourceName: e, targetName: i, callback: $f, callbackId: t.callbackId, data: r }) }), (function (r) { n.postMessage({ sourceName: e, targetName: i, callback: Jf, callbackId: t.callbackId, reason: op(r) }) })) } else t.streamId ? _o(lp, this, up).call(this, t) : r(t.data) }, n.addEventListener("message", this._onComObjOnMessage) } on(e, t) { const n = this.actionHandler; if (n[e]) throw new Error('There is already an actionName called "'.concat(e, '"')); n[e] = t } send(e, t, n) { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e, data: t }, n) } sendWithPromise(e, t, n) { const r = this.callbackId++, i = Promise.withResolvers(); this.callbackCapabilities[r] = i; try { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e, callbackId: r, data: t }, n) } catch (a) { i.reject(a) } return i.promise } sendWithStream(e, t, n, r) { const i = this.streamId++, a = this.sourceName, s = this.targetName, o = this.comObj; return new ReadableStream({ start: n => { const l = Promise.withResolvers(); return this.streamControllers[i] = { controller: n, startCall: l, pullCall: null, cancelCall: null, isClosed: !1 }, o.postMessage({ sourceName: a, targetName: s, action: e, streamId: i, data: t, desiredSize: n.desiredSize }, r), l.promise }, pull: e => { const t = Promise.withResolvers(); return this.streamControllers[i].pullCall = t, o.postMessage({ sourceName: a, targetName: s, stream: ip, streamId: i, desiredSize: e.desiredSize }), t.promise }, cancel: e => { Ll(e instanceof Error, "cancel must have a valid reason"); const t = Promise.withResolvers(); return this.streamControllers[i].cancelCall = t, this.streamControllers[i].isClosed = !0, o.postMessage({ sourceName: a, targetName: s, stream: Zf, streamId: i, reason: op(e) }), t.promise } }, n) } destroy() { this.comObj.removeEventListener("message", this._onComObjOnMessage) } } function up(e) { const t = e.streamId, n = this.sourceName, r = e.sourceName, i = this.comObj, a = this, s = this.actionHandler[e.action], o = { enqueue(e) { let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, s = arguments.length > 2 ? arguments[2] : void 0; if (this.isCancelled) return; const o = this.desiredSize; this.desiredSize -= a, o > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), i.postMessage({ sourceName: n, targetName: r, stream: np, streamId: t, chunk: e }, s) }, close() { this.isCancelled || (this.isCancelled = !0, i.postMessage({ sourceName: n, targetName: r, stream: tp, streamId: t }), delete a.streamSinks[t]) }, error(e) { Ll(e instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, i.postMessage({ sourceName: n, targetName: r, stream: rp, streamId: t, reason: op(e) })) }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: !1, desiredSize: e.desiredSize, ready: null }; o.sinkCapability.resolve(), o.ready = o.sinkCapability.promise, this.streamSinks[t] = o, new Promise((function (t) { t(s(e.data, o)) })).then((function () { i.postMessage({ sourceName: n, targetName: r, stream: sp, streamId: t, success: !0 }) }), (function (e) { i.postMessage({ sourceName: n, targetName: r, stream: sp, streamId: t, reason: op(e) }) })) } function dp(e) { const t = e.streamId, n = this.sourceName, r = e.sourceName, i = this.comObj, a = this.streamControllers[t], s = this.streamSinks[t]; switch (e.stream) { case sp: e.success ? a.startCall.resolve() : a.startCall.reject(op(e.reason)); break; case ap: e.success ? a.pullCall.resolve() : a.pullCall.reject(op(e.reason)); break; case ip: if (!s) { i.postMessage({ sourceName: n, targetName: r, stream: ap, streamId: t, success: !0 }); break } s.desiredSize <= 0 && e.desiredSize > 0 && s.sinkCapability.resolve(), s.desiredSize = e.desiredSize, new Promise((function (e) { var t; e(null === (t = s.onPull) || void 0 === t ? void 0 : t.call(s)) })).then((function () { i.postMessage({ sourceName: n, targetName: r, stream: ap, streamId: t, success: !0 }) }), (function (e) { i.postMessage({ sourceName: n, targetName: r, stream: ap, streamId: t, reason: op(e) }) })); break; case np: if (Ll(a, "enqueue should have stream controller"), a.isClosed) break; a.controller.enqueue(e.chunk); break; case tp: if (Ll(a, "close should have stream controller"), a.isClosed) break; a.isClosed = !0, a.controller.close(), _o(lp, this, hp).call(this, a, t); break; case rp: Ll(a, "error should have stream controller"), a.controller.error(op(e.reason)), _o(lp, this, hp).call(this, a, t); break; case ep: e.success ? a.cancelCall.resolve() : a.cancelCall.reject(op(e.reason)), _o(lp, this, hp).call(this, a, t); break; case Zf: if (!s) break; new Promise((function (t) { var n; t(null === (n = s.onCancel) || void 0 === n ? void 0 : n.call(s, op(e.reason))) })).then((function () { i.postMessage({ sourceName: n, targetName: r, stream: ep, streamId: t, success: !0 }) }), (function (e) { i.postMessage({ sourceName: n, targetName: r, stream: ep, streamId: t, reason: op(e) }) })), s.sinkCapability.reject(op(e.reason)), s.isCancelled = !0, delete this.streamSinks[t]; break; default: throw new Error("Unexpected stream case") } } async function hp(e, t) { var n, r, i; await Promise.allSettled([null === (n = e.startCall) || void 0 === n ? void 0 : n.promise, null === (r = e.pullCall) || void 0 === r ? void 0 : r.promise, null === (i = e.cancelCall) || void 0 === i ? void 0 : i.promise]), delete this.streamControllers[t] } var fp = new WeakMap, pp = new WeakMap; class mp { constructor(e) { let { parsedData: t, rawData: n } = e; Co(this, fp, void 0), Co(this, pp, void 0), To(fp, this, t), To(pp, this, n) } getRaw() { return Mo(pp, this) } get(e) { var t; return null !== (t = Mo(fp, this).get(e)) && void 0 !== t ? t : null } getAll() { return Gl(Mo(fp, this)) } has(e) { return Mo(fp, this).has(e) } } const gp = Symbol("INTERNAL"); var vp = new WeakMap, bp = new WeakMap, yp = new WeakMap, wp = new WeakMap; class xp { constructor(e, t) { let { name: n, intent: r, usage: i } = t; Co(this, vp, !1), Co(this, bp, !1), Co(this, yp, !1), Co(this, wp, !0), To(vp, this, !!(e & jo)), To(bp, this, !!(e & Fo)), this.name = n, this.intent = r, this.usage = i } get visible() { if (Mo(yp, this)) return Mo(wp, this); if (!Mo(wp, this)) return !1; const { print: e, view: t } = this.usage; return Mo(vp, this) ? "OFF" !== (null === t || void 0 === t ? void 0 : t.viewState) : !Mo(bp, this) || "OFF" !== (null === e || void 0 === e ? void 0 : e.printState) } _setVisible(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; e !== gp && Nl("Internal method `_setVisible` called."), To(yp, this, n), To(wp, this, t) } } var _p = new WeakMap, kp = new WeakMap, Sp = new WeakMap, Ap = new WeakMap, Ep = new WeakSet; class Cp { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jo; if (xo(this, Ep), Co(this, _p, null), Co(this, kp, new Map), Co(this, Sp, null), Co(this, Ap, null), this.renderingIntent = t, this.name = null, this.creator = null, null !== e) { this.name = e.name, this.creator = e.creator, To(Ap, this, e.order); for (const n of e.groups) Mo(kp, this).set(n.id, new xp(t, n)); if ("OFF" === e.baseState) for (const e of Mo(kp, this).values()) e._setVisible(gp, !1); for (const t of e.on) Mo(kp, this).get(t)._setVisible(gp, !0); for (const t of e.off) Mo(kp, this).get(t)._setVisible(gp, !1); To(Sp, this, this.getHash()) } } isVisible(e) { if (0 === Mo(kp, this).size) return !0; if (!e) return Pl("Optional content group not defined."), !0; if ("OCG" === e.type) return Mo(kp, this).has(e.id) ? Mo(kp, this).get(e.id).visible : (Rl("Optional content group not found: ".concat(e.id)), !0); if ("OCMD" === e.type) { if (e.expression) return _o(Ep, this, Mp).call(this, e.expression); if (!e.policy || "AnyOn" === e.policy) { for (const t of e.ids) { if (!Mo(kp, this).has(t)) return Rl("Optional content group not found: ".concat(t)), !0; if (Mo(kp, this).get(t).visible) return !0 } return !1 } if ("AllOn" === e.policy) { for (const t of e.ids) { if (!Mo(kp, this).has(t)) return Rl("Optional content group not found: ".concat(t)), !0; if (!Mo(kp, this).get(t).visible) return !1 } return !0 } if ("AnyOff" === e.policy) { for (const t of e.ids) { if (!Mo(kp, this).has(t)) return Rl("Optional content group not found: ".concat(t)), !0; if (!Mo(kp, this).get(t).visible) return !0 } return !1 } if ("AllOff" === e.policy) { for (const t of e.ids) { if (!Mo(kp, this).has(t)) return Rl("Optional content group not found: ".concat(t)), !0; if (Mo(kp, this).get(t).visible) return !1 } return !0 } return Rl("Unknown optional content policy ".concat(e.policy, ".")), !0 } return Rl("Unknown group type ".concat(e.type, ".")), !0 } setVisibility(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const n = Mo(kp, this).get(e); n ? (n._setVisible(gp, !!t, !0), To(_p, this, null)) : Rl("Optional content group not found: ".concat(e)) } setOCGState(e) { let t, { state: n, preserveRB: r } = e; for (const i of n) { switch (i) { case "ON": case "OFF": case "Toggle": t = i; continue }const e = Mo(kp, this).get(i); if (e) switch (t) { case "ON": e._setVisible(gp, !0); break; case "OFF": e._setVisible(gp, !1); break; case "Toggle": e._setVisible(gp, !e.visible) } } To(_p, this, null) } get hasInitialVisibility() { return null === Mo(Sp, this) || this.getHash() === Mo(Sp, this) } getOrder() { return Mo(kp, this).size ? Mo(Ap, this) ? Mo(Ap, this).slice() : [...Mo(kp, this).keys()] : null } getGroups() { return Mo(kp, this).size > 0 ? Gl(Mo(kp, this)) : null } getGroup(e) { return Mo(kp, this).get(e) || null } getHash() { if (null !== Mo(_p, this)) return Mo(_p, this); const e = new ef; for (const [t, n] of Mo(kp, this)) e.update("".concat(t, ":").concat(n.visible)); return To(_p, this, e.hexdigest()) } } function Mp(e) { const t = e.length; if (t < 2) return !0; const n = e[0]; for (let r = 1; r < t; r++) { const t = e[r]; let i; if (Array.isArray(t)) i = _o(Ep, this, Mp).call(this, t); else { if (!Mo(kp, this).has(t)) return Rl("Optional content group not found: ".concat(t)), !0; i = Mo(kp, this).get(t).visible } switch (n) { case "And": if (!i) return !1; break; case "Or": if (i) return !0; break; case "Not": return !i; default: return !0 } } return "And" === n } class Tp { constructor(e, t) { let { disableRange: n = !1, disableStream: r = !1 } = t; Ll(e, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'); const { length: i, initialData: a, progressiveDone: s, contentDispositionFilename: o } = e; if (this._queuedChunks = [], this._progressiveDone = s, this._contentDispositionFilename = o, (null === a || void 0 === a ? void 0 : a.length) > 0) { const e = a instanceof Uint8Array && a.byteLength === a.buffer.byteLength ? a.buffer : new Uint8Array(a).buffer; this._queuedChunks.push(e) } this._pdfDataRangeTransport = e, this._isStreamingSupported = !r, this._isRangeSupported = !n, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], e.addRangeListener(((e, t) => { this._onReceiveData({ begin: e, chunk: t }) })), e.addProgressListener(((e, t) => { this._onProgress({ loaded: e, total: t }) })), e.addProgressiveReadListener((e => { this._onReceiveData({ chunk: e }) })), e.addProgressiveDoneListener((() => { this._onProgressiveDone() })), e.transportReady() } _onReceiveData(e) { let { begin: t, chunk: n } = e; const r = n instanceof Uint8Array && n.byteLength === n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer; if (void 0 === t) this._fullRequestReader ? this._fullRequestReader._enqueue(r) : this._queuedChunks.push(r); else { Ll(this._rangeReaders.some((function (e) { return e._begin === t && (e._enqueue(r), !0) })), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.") } } get _progressiveDataLength() { var e, t; return null !== (e = null === (t = this._fullRequestReader) || void 0 === t ? void 0 : t._loaded) && void 0 !== e ? e : 0 } _onProgress(e) { var t, n, r, i; void 0 === e.total ? null === (t = this._rangeReaders[0]) || void 0 === t || null === (n = t.onProgress) || void 0 === n || n.call(t, { loaded: e.loaded }) : null === (r = this._fullRequestReader) || void 0 === r || null === (i = r.onProgress) || void 0 === i || i.call(r, { loaded: e.loaded, total: e.total }) } _onProgressiveDone() { var e; null === (e = this._fullRequestReader) || void 0 === e || e.progressiveDone(), this._progressiveDone = !0 } _removeRangeReader(e) { const t = this._rangeReaders.indexOf(e); t >= 0 && this._rangeReaders.splice(t, 1) } getFullReader() { Ll(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once."); const e = this._queuedChunks; return this._queuedChunks = null, new Pp(this, e, this._progressiveDone, this._contentDispositionFilename) } getRangeReader(e, t) { if (t <= this._progressiveDataLength) return null; const n = new Rp(this, e, t); return this._pdfDataRangeTransport.requestDataRange(e, t), this._rangeReaders.push(n), n } cancelAllRequests(e) { var t; null === (t = this._fullRequestReader) || void 0 === t || t.cancel(e); for (const n of this._rangeReaders.slice(0)) n.cancel(e); this._pdfDataRangeTransport.abort() } } class Pp { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; this._stream = e, this._done = n || !1, this._filename = Vc(r) ? r : null, this._queuedChunks = t || [], this._loaded = 0; for (const i of this._queuedChunks) this._loaded += i.byteLength; this._requests = [], this._headersReady = Promise.resolve(), e._fullRequestReader = this, this.onProgress = null } _enqueue(e) { if (!this._done) { if (this._requests.length > 0) { this._requests.shift().resolve({ value: e, done: !1 }) } else this._queuedChunks.push(e); this._loaded += e.byteLength } } get headersReady() { return this._headersReady } get filename() { return this._filename } get isRangeSupported() { return this._stream._isRangeSupported } get isStreamingSupported() { return this._stream._isStreamingSupported } get contentLength() { return this._stream._contentLength } async read() { if (this._queuedChunks.length > 0) { return { value: this._queuedChunks.shift(), done: !1 } } if (this._done) return { value: void 0, done: !0 }; const e = Promise.withResolvers(); return this._requests.push(e), e.promise } cancel(e) { this._done = !0; for (const t of this._requests) t.resolve({ value: void 0, done: !0 }); this._requests.length = 0 } progressiveDone() { this._done || (this._done = !0) } } class Rp { constructor(e, t, n) { this._stream = e, this._begin = t, this._end = n, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null } _enqueue(e) { if (!this._done) { if (0 === this._requests.length) this._queuedChunk = e; else { this._requests.shift().resolve({ value: e, done: !1 }); for (const e of this._requests) e.resolve({ value: void 0, done: !0 }); this._requests.length = 0 } this._done = !0, this._stream._removeRangeReader(this) } } get isStreamingSupported() { return !1 } async read() { if (this._queuedChunk) { const e = this._queuedChunk; return this._queuedChunk = null, { value: e, done: !1 } } if (this._done) return { value: void 0, done: !0 }; const e = Promise.withResolvers(); return this._requests.push(e), e.promise } cancel(e) { this._done = !0; for (const t of this._requests) t.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._stream._removeRangeReader(this) } } function Np(e) { let { getResponseHeader: t, isHttp: n, rangeChunkSize: r, disableRange: i } = e; const a = { allowRangeRequests: !1, suggestedLength: void 0 }, s = parseInt(t("Content-Length"), 10); if (!Number.isInteger(s)) return a; if (a.suggestedLength = s, s <= 2 * r) return a; if (i || !n) return a; if ("bytes" !== t("Accept-Ranges")) return a; return "identity" !== (t("Content-Encoding") || "identity") || (a.allowRangeRequests = !0), a } function Lp(e) { const t = e("Content-Disposition"); if (t) { let e = function (e) { let t = !0, n = r("filename\\*", "i").exec(e); if (n) { n = n[1]; let e = s(n); return e = unescape(e), e = o(e), e = l(e), a(e) } if (n = function (e) { const t = []; let n; const i = r("filename\\*((?!0\\d)\\d+)(\\*?)", "ig"); for (; null !== (n = i.exec(e));) { let [, e, r, i] = n; if (e = parseInt(e, 10), e in t) { if (0 === e) break } else t[e] = [r, i] } const a = []; for (let r = 0; r < t.length && r in t; ++r) { let [e, n] = t[r]; n = s(n), e && (n = unescape(n), 0 === r && (n = o(n))), a.push(n) } return a.join("") }(e), n) return a(l(n)); if (n = r("filename", "i").exec(e), n) { n = n[1]; let e = s(n); return e = l(e), a(e) } function r(e, t) { return new RegExp("(?:^|;)\\s*" + e + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', t) } function i(e, n) { if (e) { if (!/^[\x00-\xFF]+$/.test(n)) return n; try { const r = new TextDecoder(e, { fatal: !0 }), i = ql(n); n = r.decode(i), t = !1 } catch { } } return n } function a(e) { return t && /[\x80-\xff]/.test(e) && (e = i("utf-8", e), t && (e = i("iso-8859-1", e))), e } function s(e) { if (e.startsWith('"')) { const t = e.slice(1).split('\\"'); for (let e = 0; e < t.length; ++e) { const n = t[e].indexOf('"'); -1 !== n && (t[e] = t[e].slice(0, n), t.length = e + 1), t[e] = t[e].replaceAll(/\\(.)/g, "$1") } e = t.join('"') } return e } function o(e) { const t = e.indexOf("'"); return -1 === t ? e : i(e.slice(0, t), e.slice(t + 1).replace(/^[^']*'/, "")) } function l(e) { return !e.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(e) ? e : e.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (function (e, t, n, r) { if ("q" === n || "Q" === n) return i(t, r = (r = r.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, (function (e, t) { return String.fromCharCode(parseInt(t, 16)) }))); try { r = atob(r) } catch { } return i(t, r) })) } return "" }(t); if (e.includes("%")) try { e = decodeURIComponent(e) } catch { } if (Vc(e)) return e } return null } function Ip(e, t) { return 404 === e || 0 === e && t.startsWith("file:") ? new Wl('Missing PDF "' + t + '".') : new Bl("Unexpected server response (".concat(e, ') while retrieving PDF "').concat(t, '".'), e) } function Dp(e) { return 200 === e || 206 === e } function Op(e, t, n) { return { method: "GET", headers: e, signal: n.signal, mode: "cors", credentials: t ? "include" : "same-origin", redirect: "follow" } } function jp(e) { const t = new Headers; for (const n in e) { const r = e[n]; void 0 !== r && t.append(n, r) } return t } function Fp(e) { return e instanceof Uint8Array ? e.buffer : e instanceof ArrayBuffer ? e : (Rl("getArrayBuffer - unexpected data format: ".concat(e)), new Uint8Array(e).buffer) } class zp { constructor(e) { this.source = e, this.isHttp = /^https?:/i.test(e.url), this.httpHeaders = this.isHttp && e.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [] } get _progressiveDataLength() { var e, t; return null !== (e = null === (t = this._fullRequestReader) || void 0 === t ? void 0 : t._loaded) && void 0 !== e ? e : 0 } getFullReader() { return Ll(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new Wp(this), this._fullRequestReader } getRangeReader(e, t) { if (t <= this._progressiveDataLength) return null; const n = new Bp(this, e, t); return this._rangeRequestReaders.push(n), n } cancelAllRequests(e) { var t; null === (t = this._fullRequestReader) || void 0 === t || t.cancel(e); for (const n of this._rangeRequestReaders.slice(0)) n.cancel(e) } } class Wp { constructor(e) { this._stream = e, this._reader = null, this._loaded = 0, this._filename = null; const t = e.source; this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._abortController = new AbortController, this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._headers = jp(this._stream.httpHeaders); const n = t.url; fetch(n, Op(this._headers, this._withCredentials, this._abortController)).then((e => { if (!Dp(e.status)) throw Ip(e.status, n); this._reader = e.body.getReader(), this._headersCapability.resolve(); const t = t => e.headers.get(t), { allowRangeRequests: r, suggestedLength: i } = Np({ getResponseHeader: t, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = r, this._contentLength = i || this._contentLength, this._filename = Lp(t), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new Ul("Streaming is disabled.")) })).catch(this._headersCapability.reject), this.onProgress = null } get headersReady() { return this._headersCapability.promise } get filename() { return this._filename } get contentLength() { return this._contentLength } get isRangeSupported() { return this._isRangeSupported } get isStreamingSupported() { return this._isStreamingSupported } async read() { var e; await this._headersCapability.promise; const { value: t, done: n } = await this._reader.read(); return n ? { value: t, done: n } : (this._loaded += t.byteLength, null === (e = this.onProgress) || void 0 === e || e.call(this, { loaded: this._loaded, total: this._contentLength }), { value: Fp(t), done: !1 }) } cancel(e) { var t; null === (t = this._reader) || void 0 === t || t.cancel(e), this._abortController.abort() } } class Bp { constructor(e, t, n) { this._stream = e, this._reader = null, this._loaded = 0; const r = e.source; this._withCredentials = r.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !r.disableStream, this._abortController = new AbortController, this._headers = jp(this._stream.httpHeaders), this._headers.append("Range", "bytes=".concat(t, "-").concat(n - 1)); const i = r.url; fetch(i, Op(this._headers, this._withCredentials, this._abortController)).then((e => { if (!Dp(e.status)) throw Ip(e.status, i); this._readCapability.resolve(), this._reader = e.body.getReader() })).catch(this._readCapability.reject), this.onProgress = null } get isStreamingSupported() { return this._isStreamingSupported } async read() { var e; await this._readCapability.promise; const { value: t, done: n } = await this._reader.read(); return n ? { value: t, done: n } : (this._loaded += t.byteLength, null === (e = this.onProgress) || void 0 === e || e.call(this, { loaded: this._loaded }), { value: Fp(t), done: !1 }) } cancel(e) { var t; null === (t = this._reader) || void 0 === t || t.cancel(e), this._abortController.abort() } } class Hp { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.url = e, this.isHttp = /^https?:/i.test(e), this.httpHeaders = this.isHttp && t.httpHeaders || Object.create(null), this.withCredentials = t.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = Object.create(null) } requestRange(e, t, n) { const r = { begin: e, end: t }; for (const i in n) r[i] = n[i]; return this.request(r) } requestFull(e) { return this.request(e) } request(e) { const t = new XMLHttpRequest, n = this.currXhrId++, r = this.pendingRequests[n] = { xhr: t }; t.open("GET", this.url), t.withCredentials = this.withCredentials; for (const i in this.httpHeaders) { const e = this.httpHeaders[i]; void 0 !== e && t.setRequestHeader(i, e) } return this.isHttp && "begin" in e && "end" in e ? (t.setRequestHeader("Range", "bytes=".concat(e.begin, "-").concat(e.end - 1)), r.expectedStatus = 206) : r.expectedStatus = 200, t.responseType = "arraybuffer", e.onError && (t.onerror = function (n) { e.onError(t.status) }), t.onreadystatechange = this.onStateChange.bind(this, n), t.onprogress = this.onProgress.bind(this, n), r.onHeadersReceived = e.onHeadersReceived, r.onDone = e.onDone, r.onError = e.onError, r.onProgress = e.onProgress, t.send(null), n } onProgress(e, t) { var n; const r = this.pendingRequests[e]; r && (null === (n = r.onProgress) || void 0 === n || n.call(r, t)) } onStateChange(e, t) { const n = this.pendingRequests[e]; if (!n) return; const r = n.xhr; if (r.readyState >= 2 && n.onHeadersReceived && (n.onHeadersReceived(), delete n.onHeadersReceived), 4 !== r.readyState) return; if (!(e in this.pendingRequests)) return; var i; if (delete this.pendingRequests[e], 0 === r.status && this.isHttp) return void (null === (i = n.onError) || void 0 === i || i.call(n, r.status)); const a = r.status || 200; var s; if (!(200 === a && 206 === n.expectedStatus) && a !== n.expectedStatus) return void (null === (s = n.onError) || void 0 === s || s.call(n, r.status)); const o = function (e) { const t = e.response; return "string" !== typeof t ? t : ql(t).buffer }(r); if (206 === a) { const e = r.getResponseHeader("Content-Range"), t = /bytes (\d+)-(\d+)\/(\d+)/.exec(e); n.onDone({ begin: parseInt(t[1], 10), chunk: o }) } else if (o) n.onDone({ begin: 0, chunk: o }); else { var l; null === (l = n.onError) || void 0 === l || l.call(n, r.status) } } getRequestXhr(e) { return this.pendingRequests[e].xhr } isPendingRequest(e) { return e in this.pendingRequests } abortRequest(e) { const t = this.pendingRequests[e].xhr; delete this.pendingRequests[e], t.abort() } } class Up { constructor(e) { this._source = e, this._manager = new Hp(e.url, { httpHeaders: e.httpHeaders, withCredentials: e.withCredentials }), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [] } _onRangeRequestReaderClosed(e) { const t = this._rangeRequestReaders.indexOf(e); t >= 0 && this._rangeRequestReaders.splice(t, 1) } getFullReader() { return Ll(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new Vp(this._manager, this._source), this._fullRequestReader } getRangeReader(e, t) { const n = new qp(this._manager, e, t); return n.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(n), n } cancelAllRequests(e) { var t; null === (t = this._fullRequestReader) || void 0 === t || t.cancel(e); for (const n of this._rangeRequestReaders.slice(0)) n.cancel(e) } } class Vp { constructor(e, t) { this._manager = e; const n = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = t.url, this._fullRequestId = e.requestFull(n), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null } _onHeadersReceived() { const e = this._fullRequestId, t = this._manager.getRequestXhr(e), n = e => t.getResponseHeader(e), { allowRangeRequests: r, suggestedLength: i } = Np({ getResponseHeader: n, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); r && (this._isRangeSupported = !0), this._contentLength = i || this._contentLength, this._filename = Lp(n), this._isRangeSupported && this._manager.abortRequest(e), this._headersReceivedCapability.resolve() } _onDone(e) { if (e) if (this._requests.length > 0) { this._requests.shift().resolve({ value: e.chunk, done: !1 }) } else this._cachedChunks.push(e.chunk); if (this._done = !0, !(this._cachedChunks.length > 0)) { for (const e of this._requests) e.resolve({ value: void 0, done: !0 }); this._requests.length = 0 } } _onError(e) { this._storedError = Ip(e, this._url), this._headersReceivedCapability.reject(this._storedError); for (const t of this._requests) t.reject(this._storedError); this._requests.length = 0, this._cachedChunks.length = 0 } _onProgress(e) { var t; null === (t = this.onProgress) || void 0 === t || t.call(this, { loaded: e.loaded, total: e.lengthComputable ? e.total : this._contentLength }) } get filename() { return this._filename } get isRangeSupported() { return this._isRangeSupported } get isStreamingSupported() { return this._isStreamingSupported } get contentLength() { return this._contentLength } get headersReady() { return this._headersReceivedCapability.promise } async read() { if (this._storedError) throw this._storedError; if (this._cachedChunks.length > 0) { return { value: this._cachedChunks.shift(), done: !1 } } if (this._done) return { value: void 0, done: !0 }; const e = Promise.withResolvers(); return this._requests.push(e), e.promise } cancel(e) { this._done = !0, this._headersReceivedCapability.reject(e); for (const t of this._requests) t.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null } } class qp { constructor(e, t, n) { this._manager = e; const r = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = e.url, this._requestId = e.requestRange(t, n, r), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null } _close() { var e; null === (e = this.onClosed) || void 0 === e || e.call(this, this) } _onDone(e) { const t = e.chunk; if (this._requests.length > 0) { this._requests.shift().resolve({ value: t, done: !1 }) } else this._queuedChunk = t; this._done = !0; for (const n of this._requests) n.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._close() } _onError(e) { this._storedError = Ip(e, this._url); for (const t of this._requests) t.reject(this._storedError); this._requests.length = 0, this._queuedChunk = null } _onProgress(e) { var t; this.isStreamingSupported || (null === (t = this.onProgress) || void 0 === t || t.call(this, { loaded: e.loaded })) } get isStreamingSupported() { return !1 } async read() { if (this._storedError) throw this._storedError; if (null !== this._queuedChunk) { const e = this._queuedChunk; return this._queuedChunk = null, { value: e, done: !1 } } if (this._done) return { value: void 0, done: !0 }; const e = Promise.withResolvers(); return this._requests.push(e), e.promise } cancel(e) { this._done = !0; for (const t of this._requests) t.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close() } } const Gp = /^file:\/\/\/[a-zA-Z]:\//; class Xp { constructor(e) { this.source = e, this.url = function (e) { const t = mf.get("url"), n = t.parse(e); return "file:" === n.protocol || n.host ? n : /^[a-z]:[/\\]/i.test(e) ? t.parse("file:///".concat(e)) : (n.host || (n.protocol = "file:"), n) }(e.url), this.isHttp = "http:" === this.url.protocol || "https:" === this.url.protocol, this.isFsUrl = "file:" === this.url.protocol, this.httpHeaders = this.isHttp && e.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [] } get _progressiveDataLength() { var e, t; return null !== (e = null === (t = this._fullRequestReader) || void 0 === t ? void 0 : t._loaded) && void 0 !== e ? e : 0 } getFullReader() { return Ll(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new Zp(this) : new $p(this), this._fullRequestReader } getRangeReader(e, t) { if (t <= this._progressiveDataLength) return null; const n = this.isFsUrl ? new em(this, e, t) : new Jp(this, e, t); return this._rangeRequestReaders.push(n), n } cancelAllRequests(e) { var t; null === (t = this._fullRequestReader) || void 0 === t || t.cancel(e); for (const n of this._rangeRequestReaders.slice(0)) n.cancel(e) } } class Yp { constructor(e) { this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null; const t = e.source; this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers() } get headersReady() { return this._headersCapability.promise } get filename() { return this._filename } get contentLength() { return this._contentLength } get isRangeSupported() { return this._isRangeSupported } get isStreamingSupported() { return this._isStreamingSupported } async read() { var e; if (await this._readCapability.promise, this._done) return { value: void 0, done: !0 }; if (this._storedError) throw this._storedError; const t = this._readableStream.read(); if (null === t) return this._readCapability = Promise.withResolvers(), this.read(); this._loaded += t.length, null === (e = this.onProgress) || void 0 === e || e.call(this, { loaded: this._loaded, total: this._contentLength }); return { value: new Uint8Array(t).buffer, done: !1 } } cancel(e) { this._readableStream ? this._readableStream.destroy(e) : this._error(e) } _error(e) { this._storedError = e, this._readCapability.resolve() } _setReadableStream(e) { this._readableStream = e, e.on("readable", (() => { this._readCapability.resolve() })), e.on("end", (() => { e.destroy(), this._done = !0, this._readCapability.resolve() })), e.on("error", (e => { this._error(e) })), !this._isStreamingSupported && this._isRangeSupported && this._error(new Ul("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError) } } class Kp { constructor(e) { this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers(); const t = e.source; this._isStreamingSupported = !t.disableStream } get isStreamingSupported() { return this._isStreamingSupported } async read() { var e; if (await this._readCapability.promise, this._done) return { value: void 0, done: !0 }; if (this._storedError) throw this._storedError; const t = this._readableStream.read(); if (null === t) return this._readCapability = Promise.withResolvers(), this.read(); this._loaded += t.length, null === (e = this.onProgress) || void 0 === e || e.call(this, { loaded: this._loaded }); return { value: new Uint8Array(t).buffer, done: !1 } } cancel(e) { this._readableStream ? this._readableStream.destroy(e) : this._error(e) } _error(e) { this._storedError = e, this._readCapability.resolve() } _setReadableStream(e) { this._readableStream = e, e.on("readable", (() => { this._readCapability.resolve() })), e.on("end", (() => { e.destroy(), this._done = !0, this._readCapability.resolve() })), e.on("error", (e => { this._error(e) })), this._storedError && this._readableStream.destroy(this._storedError) } } function Qp(e, t) { return { protocol: e.protocol, auth: e.auth, host: e.hostname, port: e.port, path: e.path, method: "GET", headers: t } } class $p extends Yp { constructor(e) { super(e); const t = t => { if (404 === t.statusCode) { const e = new Wl('Missing PDF "'.concat(this._url, '".')); return this._storedError = e, void this._headersCapability.reject(e) } this._headersCapability.resolve(), this._setReadableStream(t); const n = e => this._readableStream.headers[e.toLowerCase()], { allowRangeRequests: r, suggestedLength: i } = Np({ getResponseHeader: n, isHttp: e.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = r, this._contentLength = i || this._contentLength, this._filename = Lp(n) }; if (this._request = null, "http:" === this._url.protocol) { const n = mf.get("http"); this._request = n.request(Qp(this._url, e.httpHeaders), t) } else { const n = mf.get("https"); this._request = n.request(Qp(this._url, e.httpHeaders), t) } this._request.on("error", (e => { this._storedError = e, this._headersCapability.reject(e) })), this._request.end() } } class Jp extends Kp { constructor(e, t, n) { super(e), this._httpHeaders = {}; for (const i in e.httpHeaders) { const t = e.httpHeaders[i]; void 0 !== t && (this._httpHeaders[i] = t) } this._httpHeaders.Range = "bytes=".concat(t, "-").concat(n - 1); const r = e => { if (404 !== e.statusCode) this._setReadableStream(e); else { const e = new Wl('Missing PDF "'.concat(this._url, '".')); this._storedError = e } }; if (this._request = null, "http:" === this._url.protocol) { const e = mf.get("http"); this._request = e.request(Qp(this._url, this._httpHeaders), r) } else { const e = mf.get("https"); this._request = e.request(Qp(this._url, this._httpHeaders), r) } this._request.on("error", (e => { this._storedError = e })), this._request.end() } } class Zp extends Yp { constructor(e) { super(e); let t = decodeURIComponent(this._url.path); Gp.test(this._url.href) && (t = t.replace(/^\//, "")); const n = mf.get("fs"); n.promises.lstat(t).then((e => { this._contentLength = e.size, this._setReadableStream(n.createReadStream(t)), this._headersCapability.resolve() }), (e => { "ENOENT" === e.code && (e = new Wl('Missing PDF "'.concat(t, '".'))), this._storedError = e, this._headersCapability.reject(e) })) } } class em extends Kp { constructor(e, t, n) { super(e); let r = decodeURIComponent(this._url.path); Gp.test(this._url.href) && (r = r.replace(/^\//, "")); const i = mf.get("fs"); this._setReadableStream(i.createReadStream(r, { start: t, end: n - 1 })) } } const tm = 30, nm = .8; var rm = new WeakMap, im = new WeakMap, am = new WeakMap, sm = new WeakMap, om = new WeakMap, lm = new WeakMap, cm = new WeakMap, um = new WeakMap, dm = new WeakMap, hm = new WeakMap, fm = new WeakMap, pm = new WeakMap, mm = new WeakMap, gm = new WeakMap, vm = new WeakMap, bm = new WeakMap, ym = new WeakMap, wm = new WeakMap, xm = new WeakSet; class _m { constructor(e) { var t; let { textContentSource: n, container: r, viewport: i } = e; if (xo(this, xm), Co(this, rm, Promise.withResolvers()), Co(this, im, null), Co(this, am, !1), Co(this, sm, !(null === (t = globalThis.FontInspector) || void 0 === t || !t.enabled)), Co(this, om, null), Co(this, lm, null), Co(this, cm, 0), Co(this, um, 0), Co(this, dm, null), Co(this, hm, null), Co(this, fm, 0), Co(this, pm, 0), Co(this, mm, Object.create(null)), Co(this, gm, []), Co(this, vm, null), Co(this, bm, []), Co(this, ym, new WeakMap), Co(this, wm, null), n instanceof ReadableStream) To(vm, this, n); else { if ("object" !== typeof n) throw new Error('No "textContentSource" parameter specified.'); To(vm, this, new ReadableStream({ start(e) { e.enqueue(n), e.close() } })) } To(im, this, To(hm, this, r)), To(pm, this, i.scale * (globalThis.devicePixelRatio || 1)), To(fm, this, i.rotation), To(lm, this, { prevFontSize: null, prevFontFamily: null, div: null, properties: null, ctx: null }); const { pageWidth: a, pageHeight: s, pageX: o, pageY: l } = i.rawDims; To(wm, this, [1, 0, 0, -1, -o, l + s]), To(um, this, a), To(cm, this, s), Cm.call(_m), ru(r, i), Mo(rm, this).promise.catch((() => { })).then((() => { Nm._.delete(this), To(lm, this, null), To(mm, this, null) })) } render() { const e = () => { Mo(dm, this).read().then((t => { var n; let { value: r, done: i } = t; i ? Mo(rm, this).resolve() : (null !== (n = Mo(om, this)) && void 0 !== n || To(om, this, r.lang), Object.assign(Mo(mm, this), r.styles), _o(xm, this, km).call(this, r.items), e()) }), Mo(rm, this).reject) }; return To(dm, this, Mo(vm, this).getReader()), Nm._.add(this), e(), Mo(rm, this).promise } update(e) { let { viewport: t, onBefore: n = null } = e; const r = t.scale * (globalThis.devicePixelRatio || 1), i = t.rotation; if (i !== Mo(fm, this) && (null === n || void 0 === n || n(), To(fm, this, i), ru(Mo(hm, this), { rotation: i })), r !== Mo(pm, this)) { null === n || void 0 === n || n(), To(pm, this, r); const e = { prevFontSize: null, prevFontFamily: null, div: null, properties: null, ctx: Em.call(_m, Mo(om, this)) }; for (const t of Mo(bm, this)) e.properties = Mo(ym, this).get(t), e.div = t, _o(xm, this, Am).call(this, e) } } cancel() { var e; const t = new Ul("TextLayer task cancelled."); null === (e = Mo(dm, this)) || void 0 === e || e.cancel(t).catch((() => { })), To(dm, this, null), Mo(rm, this).reject(t) } get textDivs() { return Mo(bm, this) } get textContentItemsStr() { return Mo(gm, this) } static cleanup() { if (!(_o(_m, this, Nm)._.size > 0)) { _o(_m, this, Tm)._.clear(); for (const { canvas: e } of _o(_m, this, Pm)._.values()) e.remove(); _o(_m, this, Pm)._.clear() } } } function km(e) { var t, n; if (Mo(am, this)) return; null !== (n = (t = Mo(lm, this)).ctx) && void 0 !== n || (t.ctx = Em.call(oo, Mo(om, this))); const r = Mo(bm, this), i = Mo(gm, this); for (const a of e) { if (r.length > 1e5) return Rl("Ignoring additional textDivs for performance reasons."), void To(am, this, !0); if (void 0 !== a.str) i.push(a.str), _o(xm, this, Sm).call(this, a); else if ("beginMarkedContentProps" === a.type || "beginMarkedContent" === a.type) { const e = Mo(im, this); To(im, this, document.createElement("span")), Mo(im, this).classList.add("markedContent"), null !== a.id && Mo(im, this).setAttribute("id", "".concat(a.id)), e.append(Mo(im, this)) } else "endMarkedContent" === a.type && To(im, this, Mo(im, this).parentNode) } } function Sm(e) { const t = document.createElement("span"), n = { angle: 0, canvasWidth: 0, hasText: "" !== e.str, hasEOL: e.hasEOL, fontSize: 0 }; Mo(bm, this).push(t); const r = Kl.transform(Mo(wm, this), e.transform); let i = Math.atan2(r[1], r[0]); const a = Mo(mm, this)[e.fontName]; a.vertical && (i += Math.PI / 2); const s = Mo(sm, this) && a.fontSubstitution || a.fontFamily, o = Math.hypot(r[2], r[3]), l = o * Mm.call(oo, s, Mo(om, this)); let c, u; 0 === i ? (c = r[4], u = r[5] - l) : (c = r[4] + l * Math.sin(i), u = r[5] - l * Math.cos(i)); const d = "calc(var(--scale-factor)*", h = t.style; Mo(im, this) === Mo(hm, this) ? (h.left = "".concat((100 * c / Mo(um, this)).toFixed(2), "%"), h.top = "".concat((100 * u / Mo(cm, this)).toFixed(2), "%")) : (h.left = "".concat(d).concat(c.toFixed(2), "px)"), h.top = "".concat(d).concat(u.toFixed(2), "px)")), h.fontSize = "".concat(d).concat((Rm._ * o).toFixed(2), "px)"), h.fontFamily = s, n.fontSize = o, t.setAttribute("role", "presentation"), t.textContent = e.str, t.dir = e.dir, Mo(sm, this) && (t.dataset.fontName = a.fontSubstitutionLoadedName || e.fontName), 0 !== i && (n.angle = i * (180 / Math.PI)); let f = !1; if (e.str.length > 1) f = !0; else if (" " !== e.str && e.transform[0] !== e.transform[3]) { const t = Math.abs(e.transform[0]), n = Math.abs(e.transform[3]); t !== n && Math.max(t, n) / Math.min(t, n) > 1.5 && (f = !0) } if (f && (n.canvasWidth = a.vertical ? e.height : e.width), Mo(ym, this).set(t, n), Mo(lm, this).div = t, Mo(lm, this).properties = n, _o(xm, this, Am).call(this, Mo(lm, this)), n.hasText && Mo(im, this).append(t), n.hasEOL) { const e = document.createElement("br"); e.setAttribute("role", "presentation"), Mo(im, this).append(e) } } function Am(e) { const { div: t, properties: n, ctx: r, prevFontSize: i, prevFontFamily: a } = e, { style: s } = t; let o = ""; if (Rm._ > 1 && (o = "scale(".concat(1 / Rm._, ")")), 0 !== n.canvasWidth && n.hasText) { const { fontFamily: l } = s, { canvasWidth: c, fontSize: u } = n; i === u && a === l || (r.font = "".concat(u * Mo(pm, this), "px ").concat(l), e.prevFontSize = u, e.prevFontFamily = l); const { width: d } = r.measureText(t.textContent); d > 0 && (o = "scaleX(".concat(c * Mo(pm, this) / d, ") ").concat(o)) } 0 !== n.angle && (o = "rotate(".concat(n.angle, "deg) ").concat(o)), o.length > 0 && (s.transform = o) } function Em() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = _o(oo, this, Pm)._.get(e || (e = "")); if (!t) { const n = document.createElement("canvas"); n.className = "hiddenCanvasElement", n.lang = e, document.body.append(n), t = n.getContext("2d", { alpha: !1, willReadFrequently: !0 }), _o(oo, this, Pm)._.set(e, t) } return t } function Cm() { if (null !== _o(oo, this, Rm)._) return; const e = document.createElement("div"); e.style.opacity = 0, e.style.lineHeight = 1, e.style.fontSize = "1px", e.textContent = "X", document.body.append(e), Rm._ = _o(oo, this, e.getBoundingClientRect().height), e.remove() } function Mm(e, t) { const n = _o(oo, this, Tm)._.get(e); if (n) return n; const r = _o(oo, this, Em).call(this, t), i = r.font; r.canvas.width = r.canvas.height = tm, r.font = "".concat(tm, "px ").concat(e); const a = r.measureText(""); let s = a.fontBoundingBoxAscent, o = Math.abs(a.fontBoundingBoxDescent); if (s) { const t = s / (s + o); return _o(oo, this, Tm)._.set(e, t), r.canvas.width = r.canvas.height = 0, r.font = i, t } r.strokeStyle = "red", r.clearRect(0, 0, tm, tm), r.strokeText("g", 0, 0); let l = r.getImageData(0, 0, tm, tm).data; o = 0; for (let u = l.length - 1 - 3; u >= 0; u -= 4)if (l[u] > 0) { o = Math.ceil(u / 4 / tm); break } r.clearRect(0, 0, tm, tm), r.strokeText("A", 0, tm), l = r.getImageData(0, 0, tm, tm).data, s = 0; for (let u = 0, d = l.length; u < d; u += 4)if (l[u] > 0) { s = tm - Math.floor(u / 4 / tm); break } r.canvas.width = r.canvas.height = 0, r.font = i; const c = s ? s / (s + o) : nm; return _o(oo, this, Tm)._.set(e, c), c } oo = _m; var Tm = { _: new Map }, Pm = { _: new Map }, Rm = { _: null }, Nm = { _: new Set }; function Lm() { Qc("`renderTextLayer`, please use `TextLayer` instead."); const { textContentSource: e, container: t, viewport: n, ...r } = arguments[0], i = Object.keys(r); i.length > 0 && Rl("Ignoring `renderTextLayer` parameters: " + i.join(", ")); const a = new _m({ textContentSource: e, container: t, viewport: n }), { textDivs: s, textContentItemsStr: o } = a; return { promise: a.render(), textDivs: s, textContentItemsStr: o } } function Im() { Qc("`updateTextLayer`, please use `TextLayer` instead.") } class Dm { static textContent(e) { const t = [], n = { items: t, styles: Object.create(null) }; return function e(n) { var r; if (!n) return; let i = null; const a = n.name; if ("#text" === a) i = n.value; else { if (!Dm.shouldBuildText(a)) return; null !== n && void 0 !== n && null !== (r = n.attributes) && void 0 !== r && r.textContent ? i = n.attributes.textContent : n.value && (i = n.value) } if (null !== i && t.push({ str: i }), n.children) for (const t of n.children) e(t) }(e), n } static shouldBuildText(e) { return !("textarea" === e || "input" === e || "option" === e || "select" === e) } } const Om = 65536, jm = No ? class extends fc { _createCanvas(e, t) { return mf.get("canvas").createCanvas(e, t) } } : class extends fc { constructor() { let { ownerDocument: e = globalThis.document, enableHWA: t = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super({ enableHWA: t }), this._document = e } _createCanvas(e, t) { const n = this._document.createElement("canvas"); return n.width = e, n.height = t, n } }, Fm = No ? class extends pc { _fetchData(e, t) { return gf(e).then((e => ({ cMapData: e, compressionType: t }))) } } : Fc, zm = No ? class extends dc { } : class extends dc { constructor() { let { docId: e, ownerDocument: t = globalThis.document } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super(), xo(this, Ac), Co(this, yc, void 0), Co(this, wc, void 0), Co(this, xc, void 0), Co(this, _c, void 0), Co(this, kc, void 0), Co(this, Sc, 0), To(xc, this, e), To(_c, this, t) } addFilter(e) { var t, n; if (!e) return "none"; let r = ko(Ac, this, Ec).get(e); if (r) return r; const [i, a, s] = _o(Ac, this, Tc).call(this, e), o = 1 === e.length ? i : "".concat(i).concat(a).concat(s); if (r = ko(Ac, this, Ec).get(o), r) return ko(Ac, this, Ec).set(e, r), r; const l = "g_".concat(Mo(xc, this), "_transfer_map_").concat((To(Sc, this, (t = Mo(Sc, this), n = t++, t)), n)), c = "url(#".concat(l, ")"); ko(Ac, this, Ec).set(e, c), ko(Ac, this, Ec).set(o, c); const u = _o(Ac, this, Nc).call(this, l); return _o(Ac, this, Ic).call(this, i, a, s, u), c } addHCMFilter(e, t) { var n; const r = "".concat(e, "-").concat(t), i = "base"; let a = ko(Ac, this, Cc).get(i); if ((null === (n = a) || void 0 === n ? void 0 : n.key) === r) return a.url; var s; a ? (null === (s = a.filter) || void 0 === s || s.remove(), a.key = r, a.url = "none", a.filter = null) : (a = { key: r, url: "none", filter: null }, ko(Ac, this, Cc).set(i, a)); if (!e || !t) return a.url; const o = _o(Ac, this, Oc).call(this, e); e = Kl.makeHexColor(...o); const l = _o(Ac, this, Oc).call(this, t); if (t = Kl.makeHexColor(...l), ko(Ac, this, Mc).style.color = "", "#000000" === e && "#ffffff" === t || e === t) return a.url; const c = new Array(256); for (let p = 0; p <= 255; p++) { const e = p / 255; c[p] = e <= .03928 ? e / 12.92 : ((e + .055) / 1.055) ** 2.4 } const u = c.join(","), d = "g_".concat(Mo(xc, this), "_hcm_filter"), h = a.filter = _o(Ac, this, Nc).call(this, d); _o(Ac, this, Ic).call(this, u, u, u, h), _o(Ac, this, Rc).call(this, h); const f = (e, t) => { const n = o[e] / 255, r = l[e] / 255, i = new Array(t + 1); for (let a = 0; a <= t; a++)i[a] = n + a / t * (r - n); return i.join(",") }; return _o(Ac, this, Ic).call(this, f(0, 5), f(1, 5), f(2, 5), h), a.url = "url(#".concat(d, ")"), a.url } addAlphaFilter(e) { var t, n; let r = ko(Ac, this, Ec).get(e); if (r) return r; const [i] = _o(Ac, this, Tc).call(this, [e]), a = "alpha_".concat(i); if (r = ko(Ac, this, Ec).get(a), r) return ko(Ac, this, Ec).set(e, r), r; const s = "g_".concat(Mo(xc, this), "_alpha_map_").concat((To(Sc, this, (t = Mo(Sc, this), n = t++, t)), n)), o = "url(#".concat(s, ")"); ko(Ac, this, Ec).set(e, o), ko(Ac, this, Ec).set(a, o); const l = _o(Ac, this, Nc).call(this, s); return _o(Ac, this, Dc).call(this, i, l), o } addLuminosityFilter(e) { var t, n; let r, i, a = ko(Ac, this, Ec).get(e || "luminosity"); if (a) return a; if (e ? ([r] = _o(Ac, this, Tc).call(this, [e]), i = "luminosity_".concat(r)) : i = "luminosity", a = ko(Ac, this, Ec).get(i), a) return ko(Ac, this, Ec).set(e, a), a; const s = "g_".concat(Mo(xc, this), "_luminosity_map_").concat((To(Sc, this, (t = Mo(Sc, this), n = t++, t)), n)), o = "url(#".concat(s, ")"); ko(Ac, this, Ec).set(e, o), ko(Ac, this, Ec).set(i, o); const l = _o(Ac, this, Nc).call(this, s); return _o(Ac, this, Pc).call(this, l), e && _o(Ac, this, Dc).call(this, r, l), o } addHighlightHCMFilter(e, t, n, r, i) { var a; const s = "".concat(t, "-").concat(n, "-").concat(r, "-").concat(i); let o = ko(Ac, this, Cc).get(e); if ((null === (a = o) || void 0 === a ? void 0 : a.key) === s) return o.url; var l; o ? (null === (l = o.filter) || void 0 === l || l.remove(), o.key = s, o.url = "none", o.filter = null) : (o = { key: s, url: "none", filter: null }, ko(Ac, this, Cc).set(e, o)); if (!t || !n) return o.url; const [c, u] = [t, n].map(_o(Ac, this, Oc).bind(this)); let d = Math.round(.2126 * c[0] + .7152 * c[1] + .0722 * c[2]), h = Math.round(.2126 * u[0] + .7152 * u[1] + .0722 * u[2]), [f, p] = [r, i].map(_o(Ac, this, Oc).bind(this)); h < d && ([d, h, f, p] = [h, d, p, f]), ko(Ac, this, Mc).style.color = ""; const m = (e, t, n) => { const r = new Array(256), i = (h - d) / n, a = e / 255, s = (t - e) / (255 * n); let o = 0; for (let l = 0; l <= n; l++) { const e = Math.round(d + l * i), t = a + l * s; for (let n = o; n <= e; n++)r[n] = t; o = e + 1 } for (let l = o; l < 256; l++)r[l] = r[o - 1]; return r.join(",") }, g = "g_".concat(Mo(xc, this), "_hcm_").concat(e, "_filter"), v = o.filter = _o(Ac, this, Nc).call(this, g); return _o(Ac, this, Rc).call(this, v), _o(Ac, this, Ic).call(this, m(f[0], p[0], 5), m(f[1], p[1], 5), m(f[2], p[2], 5), v), o.url = "url(#".concat(g, ")"), o.url } destroy() { arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && 0 !== ko(Ac, this, Cc).size || (Mo(wc, this) && (Mo(wc, this).parentNode.parentNode.remove(), To(wc, this, null)), Mo(yc, this) && (Mo(yc, this).clear(), To(yc, this, null)), To(Sc, this, 0)) } }, Wm = No ? class extends mc { _fetchData(e) { return gf(e) } } : zc; function Bm() { var e, t; let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; "string" === typeof n || n instanceof URL ? n = { url: n } : (n instanceof ArrayBuffer || ArrayBuffer.isView(n)) && (n = { data: n }); const r = new Um, { docId: i } = r, a = n.url ? function (e) { if (e instanceof URL) return e.href; try { return new URL(e, window.location).href } catch { if (No && "string" === typeof e) return e } throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.") }(n.url) : null, s = n.data ? function (e) { if (No && "undefined" !== typeof Buffer && e instanceof Buffer) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`."); if (e instanceof Uint8Array && e.byteLength === e.buffer.byteLength) return e; if ("string" === typeof e) return ql(e); if (e instanceof ArrayBuffer || ArrayBuffer.isView(e) || "object" === typeof e && !isNaN(null === e || void 0 === e ? void 0 : e.length)) return new Uint8Array(e); throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.") }(n.data) : null, o = n.httpHeaders || null, l = !0 === n.withCredentials, c = null !== (e = n.password) && void 0 !== e ? e : null, u = n.range instanceof qm ? n.range : null, d = Number.isInteger(n.rangeChunkSize) && n.rangeChunkSize > 0 ? n.rangeChunkSize : Om; let h = n.worker instanceof ig ? n.worker : null; const f = n.verbosity, p = "string" !== typeof n.docBaseUrl || Uc(n.docBaseUrl) ? null : n.docBaseUrl, m = "string" === typeof n.cMapUrl ? n.cMapUrl : null, g = !1 !== n.cMapPacked, v = n.CMapReaderFactory || Fm, b = "string" === typeof n.standardFontDataUrl ? n.standardFontDataUrl : null, y = n.StandardFontDataFactory || Wm, w = !0 !== n.stopAtErrors, x = Number.isInteger(n.maxImageSize) && n.maxImageSize > -1 ? n.maxImageSize : -1, _ = !1 !== n.isEvalSupported, k = "boolean" === typeof n.isOffscreenCanvasSupported ? n.isOffscreenCanvasSupported : !No, S = Number.isInteger(n.canvasMaxAreaInBytes) ? n.canvasMaxAreaInBytes : -1, A = "boolean" === typeof n.disableFontFace ? n.disableFontFace : No, E = !0 === n.fontExtraProperties, C = !0 === n.enableXfa, M = n.ownerDocument || globalThis.document, T = !0 === n.disableRange, P = !0 === n.disableStream, R = !0 === n.disableAutoFetch, N = !0 === n.pdfBug, L = !0 === n.enableHWA, I = u ? u.length : null !== (t = n.length) && void 0 !== t ? t : NaN, D = "boolean" === typeof n.useSystemFonts ? n.useSystemFonts : !No && !A, O = "boolean" === typeof n.useWorkerFetch ? n.useWorkerFetch : v === Fc && y === zc && m && b && Yc(m, document.baseURI) && Yc(b, document.baseURI), j = n.canvasFactory || new jm({ ownerDocument: M, enableHWA: L }), F = n.filterFactory || new zm({ docId: i, ownerDocument: M }); Ml(f); const z = { canvasFactory: j, filterFactory: F }; if (O || (z.cMapReaderFactory = new v({ baseUrl: m, isCompressed: g }), z.standardFontDataFactory = new y({ baseUrl: b })), !h) { const e = { verbosity: f, port: Yf.workerPort }; h = e.port ? ig.fromPort(e) : new ig(e), r._worker = h } const W = { docId: i, apiVersion: "4.4.168", data: s, password: c, disableAutoFetch: R, rangeChunkSize: d, length: I, docBaseUrl: p, enableXfa: C, evaluatorOptions: { maxImageSize: x, disableFontFace: A, ignoreErrors: w, isEvalSupported: _, isOffscreenCanvasSupported: k, canvasMaxAreaInBytes: S, fontExtraProperties: E, useSystemFonts: D, cMapUrl: O ? m : null, standardFontDataUrl: O ? b : null } }, B = { disableFontFace: A, fontExtraProperties: E, ownerDocument: M, pdfBug: N, styleElement: null, loadingParams: { disableAutoFetch: R, enableXfa: C } }; return h.promise.then((function () { if (r.destroyed) throw new Error("Loading aborted"); if (h.destroyed) throw new Error("Worker was destroyed"); const e = h.messageHandler.sendWithPromise("GetDocRequest", W, s ? [s.buffer] : null); let t; if (u) t = new Tp(u, { disableRange: T, disableStream: P }); else if (!s) { if (!a) throw new Error("getDocument - no `url` parameter provided."); t = (e => { if (No) { return function () { return "undefined" !== typeof fetch && "undefined" !== typeof Response && "body" in Response.prototype }() && Yc(e.url) ? new zp(e) : new Xp(e) } return Yc(e.url) ? new zp(e) : new Up(e) })({ url: a, length: I, httpHeaders: o, withCredentials: l, rangeChunkSize: d, disableRange: T, disableStream: P }) } return e.then((e => { if (r.destroyed) throw new Error("Loading aborted"); if (h.destroyed) throw new Error("Worker was destroyed"); const n = new cp(i, e, h.port), a = new pg(n, r, t, B, z); r._transport = a, n.send("Ready", null) })) })).catch(r._capability.reject), r } function Hm(e) { return "object" === typeof e && Number.isInteger(null === e || void 0 === e ? void 0 : e.num) && e.num >= 0 && Number.isInteger(null === e || void 0 === e ? void 0 : e.gen) && e.gen >= 0 } class Um { constructor() { var e, t; this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = "d".concat((Vm._ = (e = Vm._, t = e++, e), t)), this.destroyed = !1, this.onPassword = null, this.onProgress = null } get promise() { return this._capability.promise } async destroy() { this.destroyed = !0; try { var e, t; null !== (e = this._worker) && void 0 !== e && e.port && (this._worker._pendingDestroy = !0), await (null === (t = this._transport) || void 0 === t ? void 0 : t.destroy()) } catch (r) { var n; throw null !== (n = this._worker) && void 0 !== n && n.port && delete this._worker._pendingDestroy, r } this._transport = null, this._worker && (this._worker.destroy(), this._worker = null) } } var Vm = { _: 0 }; class qm { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; this.length = e, this.initialData = t, this.progressiveDone = n, this.contentDispositionFilename = r, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers() } addRangeListener(e) { this._rangeListeners.push(e) } addProgressListener(e) { this._progressListeners.push(e) } addProgressiveReadListener(e) { this._progressiveReadListeners.push(e) } addProgressiveDoneListener(e) { this._progressiveDoneListeners.push(e) } onDataRange(e, t) { for (const n of this._rangeListeners) n(e, t) } onDataProgress(e, t) { this._readyCapability.promise.then((() => { for (const n of this._progressListeners) n(e, t) })) } onDataProgressiveRead(e) { this._readyCapability.promise.then((() => { for (const t of this._progressiveReadListeners) t(e) })) } onDataProgressiveDone() { this._readyCapability.promise.then((() => { for (const e of this._progressiveDoneListeners) e() })) } transportReady() { this._readyCapability.resolve() } requestDataRange(e, t) { Nl("Abstract method PDFDataRangeTransport.requestDataRange") } abort() { } } class Gm { constructor(e, t) { this._pdfInfo = e, this._transport = t } get annotationStorage() { return this._transport.annotationStorage } get filterFactory() { return this._transport.filterFactory } get numPages() { return this._pdfInfo.numPages } get fingerprints() { return this._pdfInfo.fingerprints } get isPureXfa() { return Dl(this, "isPureXfa", !!this._transport._htmlForXfa) } get allXfaHtml() { return this._transport._htmlForXfa } getPage(e) { return this._transport.getPage(e) } getPageIndex(e) { return this._transport.getPageIndex(e) } getDestinations() { return this._transport.getDestinations() } getDestination(e) { return this._transport.getDestination(e) } getPageLabels() { return this._transport.getPageLabels() } getPageLayout() { return this._transport.getPageLayout() } getPageMode() { return this._transport.getPageMode() } getViewerPreferences() { return this._transport.getViewerPreferences() } getOpenAction() { return this._transport.getOpenAction() } getAttachments() { return this._transport.getAttachments() } getJSActions() { return this._transport.getDocJSActions() } getOutline() { return this._transport.getOutline() } getOptionalContentConfig() { let { intent: e = "display" } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const { renderingIntent: t } = this._transport.getRenderingIntent(e); return this._transport.getOptionalContentConfig(t) } getPermissions() { return this._transport.getPermissions() } getMetadata() { return this._transport.getMetadata() } getMarkInfo() { return this._transport.getMarkInfo() } getData() { return this._transport.getData() } saveDocument() { return this._transport.saveDocument() } getDownloadInfo() { return this._transport.downloadInfoCapability.promise } cleanup() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return this._transport.startCleanup(e || this.isPureXfa) } destroy() { return this.loadingTask.destroy() } cachedPageNumber(e) { return this._transport.cachedPageNumber(e) } get loadingParams() { return this._transport.loadingParams } get loadingTask() { return this._transport.loadingTask } getFieldObjects() { return this._transport.getFieldObjects() } hasJSActions() { return this._transport.hasJSActions() } getCalculationOrderIds() { return this._transport.getCalculationOrderIds() } } var Xm = new WeakMap, Ym = new WeakMap, Km = new WeakSet; class Qm { constructor(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; xo(this, Km), Co(this, Xm, null), Co(this, Ym, !1), this._pageIndex = e, this._pageInfo = t, this._transport = n, this._stats = r ? new Xc : null, this._pdfBug = r, this.commonObjs = n.commonObjs, this.objs = new yg, this._maybeCleanupAfterRender = !1, this._intentStates = new Map, this.destroyed = !1 } get pageNumber() { return this._pageIndex + 1 } get rotate() { return this._pageInfo.rotate } get ref() { return this._pageInfo.ref } get userUnit() { return this._pageInfo.userUnit } get view() { return this._pageInfo.view } getViewport() { let { scale: e, rotation: t = this.rotate, offsetX: n = 0, offsetY: r = 0, dontFlip: i = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return new Bc({ viewBox: this.view, scale: e, rotation: t, offsetX: n, offsetY: r, dontFlip: i }) } getAnnotations() { let { intent: e = "display" } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const { renderingIntent: t } = this._transport.getRenderingIntent(e); return this._transport.getAnnotations(this._pageIndex, t) } getJSActions() { return this._transport.getPageJSActions(this._pageIndex) } get filterFactory() { return this._transport.filterFactory } get isPureXfa() { return Dl(this, "isPureXfa", !!this._transport._htmlForXfa) } async getXfa() { var e; return (null === (e = this._transport._htmlForXfa) || void 0 === e ? void 0 : e.children[this._pageIndex]) || null } render(e) { var t, n; let { canvasContext: r, viewport: i, intent: a = "display", annotationMode: s = Uo.ENABLE, transform: o = null, background: l = null, optionalContentConfigPromise: c = null, annotationCanvasMap: u = null, pageColors: d = null, printAnnotationStorage: h = null } = e; null === (t = this._stats) || void 0 === t || t.time("Overall"); const f = this._transport.getRenderingIntent(a, s, h), { renderingIntent: p, cacheKey: m } = f; To(Ym, this, !1), _o(Km, this, Jm).call(this), c || (c = this._transport.getOptionalContentConfig(p)); let g = this._intentStates.get(m); g || (g = Object.create(null), this._intentStates.set(m, g)), g.streamReaderCancelTimeout && (clearTimeout(g.streamReaderCancelTimeout), g.streamReaderCancelTimeout = null); const v = !!(p & Fo); var b; g.displayReadyCapability || (g.displayReadyCapability = Promise.withResolvers(), g.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }, null === (b = this._stats) || void 0 === b || b.time("Page Request"), this._pumpOperatorList(f)); const y = e => { var t; (g.renderTasks.delete(w), (this._maybeCleanupAfterRender || v) && To(Ym, this, !0), _o(Km, this, $m).call(this, !v), e ? (w.capability.reject(e), this._abortOperatorList({ intentState: g, reason: e instanceof Error ? e : new Error(e) })) : w.capability.resolve(), this._stats) && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), null !== (t = globalThis.Stats) && void 0 !== t && t.enabled && globalThis.Stats.add(this.pageNumber, this._stats)) }, w = new Sg({ callback: y, params: { canvasContext: r, viewport: i, transform: o, background: l }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: u, operatorList: g.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !v, pdfBug: this._pdfBug, pageColors: d }); ((n = g).renderTasks || (n.renderTasks = new Set)).add(w); const x = w.task; return Promise.all([g.displayReadyCapability.promise, c]).then((e => { var t; let [n, r] = e; if (this.destroyed) y(); else { if (null === (t = this._stats) || void 0 === t || t.time("Rendering"), !(r.renderingIntent & p)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods."); w.initializeGraphics({ transparency: n, optionalContentConfig: r }), w.operatorListChanged() } })).catch(y), x } getOperatorList() { let { intent: e = "display", annotationMode: t = Uo.ENABLE, printAnnotationStorage: n = null } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const r = this._transport.getRenderingIntent(e, t, n, !0); let i, a = this._intentStates.get(r.cacheKey); var s, o; (a || (a = Object.create(null), this._intentStates.set(r.cacheKey, a)), a.opListReadCapability) || (i = Object.create(null), i.operatorListChanged = function () { a.operatorList.lastChunk && (a.opListReadCapability.resolve(a.operatorList), a.renderTasks.delete(i)) }, a.opListReadCapability = Promise.withResolvers(), ((s = a).renderTasks || (s.renderTasks = new Set)).add(i), a.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }, null === (o = this._stats) || void 0 === o || o.time("Page Request"), this._pumpOperatorList(r)); return a.opListReadCapability.promise } streamTextContent() { let { includeMarkedContent: e = !1, disableNormalization: t = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: !0 === e, disableNormalization: !0 === t }, { highWaterMark: 100, size: e => e.items.length }) } getTextContent() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (this._transport._htmlForXfa) return this.getXfa().then((e => Dm.textContent(e))); const t = this.streamTextContent(e); return new Promise((function (e, n) { const r = t.getReader(), i = { items: [], styles: Object.create(null), lang: null }; !function t() { r.read().then((function (n) { var r; let { value: a, done: s } = n; s ? e(i) : (null !== (r = i.lang) && void 0 !== r || (i.lang = a.lang), Object.assign(i.styles, a.styles), i.items.push(...a.items), t()) }), n) }() })) } getStructTree() { return this._transport.getStructTree(this._pageIndex) } _destroy() { this.destroyed = !0; const e = []; for (const t of this._intentStates.values()) if (this._abortOperatorList({ intentState: t, reason: new Error("Page was destroyed."), force: !0 }), !t.opListReadCapability) for (const n of t.renderTasks) e.push(n.completed), n.cancel(); return this.objs.clear(), To(Ym, this, !1), _o(Km, this, Jm).call(this), Promise.all(e) } cleanup() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; To(Ym, this, !0); const t = _o(Km, this, $m).call(this, !1); return e && t && this._stats && (this._stats = new Xc), t } _startRenderPage(e, t) { var n, r; const i = this._intentStates.get(t); i && (null === (n = this._stats) || void 0 === n || n.timeEnd("Page Request"), null === (r = i.displayReadyCapability) || void 0 === r || r.resolve(e)) } _renderPageChunk(e, t) { for (let n = 0, r = e.length; n < r; n++)t.operatorList.fnArray.push(e.fnArray[n]), t.operatorList.argsArray.push(e.argsArray[n]); t.operatorList.lastChunk = e.lastChunk, t.operatorList.separateAnnots = e.separateAnnots; for (const n of t.renderTasks) n.operatorListChanged(); e.lastChunk && _o(Km, this, $m).call(this, !0) } _pumpOperatorList(e) { let { renderingIntent: t, cacheKey: n, annotationStorageSerializable: r } = e; const { map: i, transfer: a } = r, s = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: t, cacheKey: n, annotationStorage: i }, a).getReader(), o = this._intentStates.get(n); o.streamReader = s; const l = () => { s.read().then((e => { let { value: t, done: n } = e; n ? o.streamReader = null : this._transport.destroyed || (this._renderPageChunk(t, o), l()) }), (e => { if (o.streamReader = null, !this._transport.destroyed) { if (o.operatorList) { o.operatorList.lastChunk = !0; for (const e of o.renderTasks) e.operatorListChanged(); _o(Km, this, $m).call(this, !0) } if (o.displayReadyCapability) o.displayReadyCapability.reject(e); else { if (!o.opListReadCapability) throw e; o.opListReadCapability.reject(e) } } })) }; l() } _abortOperatorList(e) { let { intentState: t, reason: n, force: r = !1 } = e; if (t.streamReader) { if (t.streamReaderCancelTimeout && (clearTimeout(t.streamReaderCancelTimeout), t.streamReaderCancelTimeout = null), !r) { if (t.renderTasks.size > 0) return; if (n instanceof Hc) { let e = 100; return n.extraDelay > 0 && n.extraDelay < 1e3 && (e += n.extraDelay), void (t.streamReaderCancelTimeout = setTimeout((() => { t.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: t, reason: n, force: !0 }) }), e)) } } if (t.streamReader.cancel(new Ul(n.message)).catch((() => { })), t.streamReader = null, !this._transport.destroyed) { for (const [e, n] of this._intentStates) if (n === t) { this._intentStates.delete(e); break } this.cleanup() } } } get stats() { return this._stats } } function $m() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (_o(Km, this, Jm).call(this), !Mo(Ym, this) || this.destroyed) return !1; if (e) return To(Xm, this, setTimeout((() => { To(Xm, this, null), _o(Km, this, $m).call(this, !1) }), 5e3)), !1; for (const { renderTasks: t, operatorList: n } of this._intentStates.values()) if (t.size > 0 || !n.lastChunk) return !1; return this._intentStates.clear(), this.objs.clear(), To(Ym, this, !1), !0 } function Jm() { Mo(Xm, this) && (clearTimeout(Mo(Xm, this)), To(Xm, this, null)) } var Zm = new WeakMap, eg = new WeakMap; class tg { constructor() { Co(this, Zm, new Set), Co(this, eg, Promise.resolve()) } postMessage(e, t) { const n = { data: structuredClone(e, t ? { transfer: t } : null) }; Mo(eg, this).then((() => { for (const e of Mo(Zm, this)) e.call(this, n) })) } addEventListener(e, t) { Mo(Zm, this).add(t) } removeEventListener(e, t) { Mo(Zm, this).delete(t) } terminate() { Mo(Zm, this).clear() } } const ng = { isWorkerDisabled: !1, fakeWorkerId: 0 }; No && (ng.isWorkerDisabled = !0, Yf.workerSrc || (Yf.workerSrc = "./pdf.worker.mjs")), ng.isSameOrigin = function (e, t) { let n; try { if (n = new URL(e), !n.origin || "null" === n.origin) return !1 } catch { return !1 } const r = new URL(t, n); return n.origin === r.origin }, ng.createCDNWrapper = function (e) { const t = 'await import("'.concat(e, '");'); return URL.createObjectURL(new Blob([t], { type: "text/javascript" })) }; var rg = new WeakSet; class ig { constructor() { let { name: e = null, port: t = null, verbosity: n = Tl() } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (xo(this, rg), this.name = e, this.destroyed = !1, this.verbosity = n, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, t) { var r; if (null !== (r = og._) && void 0 !== r && r.has(t)) throw new Error("Cannot use more than one PDFWorker per port."); return (og._ || (og._ = new WeakMap)).set(t, this), void this._initializeFromPort(t) } this._initialize() } get promise() { return No ? Promise.all([mf.promise, this._readyCapability.promise]) : this._readyCapability.promise } get port() { return this._port } get messageHandler() { return this._messageHandler } _initializeFromPort(e) { this._port = e, this._messageHandler = new cp("main", "worker", e), this._messageHandler.on("ready", (function () { })), _o(rg, this, ag).call(this) } _initialize() { if (ng.isWorkerDisabled || sg(ig)) return void this._setupFakeWorker(); let { workerSrc: e } = ig; try { ng.isSameOrigin(window.location.href, e) || (e = ng.createCDNWrapper(new URL(e, window.location).href)); const t = new Worker(e, { type: "module" }), n = new cp("main", "worker", t), r = () => { i.abort(), n.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker() }, i = new AbortController; t.addEventListener("error", (() => { this._webWorker || r() }), { signal: i.signal }), n.on("test", (e => { i.abort(), !this.destroyed && e ? (this._messageHandler = n, this._port = t, this._webWorker = t, _o(rg, this, ag).call(this)) : r() })), n.on("ready", (e => { if (i.abort(), this.destroyed) r(); else try { a() } catch { this._setupFakeWorker() } })); const a = () => { const e = new Uint8Array; n.send("test", e, [e.buffer]) }; return void a() } catch { Pl("The worker has been disabled.") } this._setupFakeWorker() } _setupFakeWorker() { ng.isWorkerDisabled || (Rl("Setting up fake worker."), ng.isWorkerDisabled = !0), ig._setupFakeWorkerGlobal.then((e => { if (this.destroyed) return void this._readyCapability.reject(new Error("Worker was destroyed")); const t = new tg; this._port = t; const n = "fake".concat(ng.fakeWorkerId++), r = new cp(n + "_worker", n, t); e.setup(r, t), this._messageHandler = new cp(n, n + "_worker", t), _o(rg, this, ag).call(this) })).catch((e => { this._readyCapability.reject(new Error('Setting up fake worker failed: "'.concat(e.message, '".'))) })) } destroy() { var e; this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), null === (e = og._) || void 0 === e || e.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null) } static fromPort(e) { var t; if (null === e || void 0 === e || !e.port) throw new Error("PDFWorker.fromPort - invalid method signature."); const n = null === (t = _o(ig, this, og)._) || void 0 === t ? void 0 : t.get(e.port); if (n) { if (n._pendingDestroy) throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls."); return n } return new ig(e) } static get workerSrc() { if (Yf.workerSrc) return Yf.workerSrc; throw new Error('No "GlobalWorkerOptions.workerSrc" specified.') } static get _setupFakeWorkerGlobal() { return Dl(this, "_setupFakeWorkerGlobal", (async () => { if (ko(ig, this, sg)) return ko(ig, this, sg); return (await import(this.workerSrc)).WorkerMessageHandler })()) } } function ag() { this._readyCapability.resolve(), this._messageHandler.send("configure", { verbosity: this.verbosity }) } function sg(e) { try { var t; return (null === (t = globalThis.pdfjsWorker) || void 0 === t ? void 0 : t.WorkerMessageHandler) || null } catch { return null } } var og = { _: void 0 }, lg = new WeakMap, cg = new WeakMap, ug = new WeakMap, dg = new WeakMap, hg = new WeakMap, fg = new WeakSet; class pg { constructor(e, t, n, r, i) { xo(this, fg), Co(this, lg, new Map), Co(this, cg, new Map), Co(this, ug, new Map), Co(this, dg, new Map), Co(this, hg, null), this.messageHandler = e, this.loadingTask = t, this.commonObjs = new yg, this.fontLoader = new df({ ownerDocument: r.ownerDocument, styleElement: r.styleElement }), this.loadingParams = r.loadingParams, this._params = r, this.canvasFactory = i.canvasFactory, this.filterFactory = i.filterFactory, this.cMapReaderFactory = i.cMapReaderFactory, this.standardFontDataFactory = i.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = n, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler() } get annotationStorage() { return Dl(this, "annotationStorage", new sf) } getRenderingIntent(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Uo.ENABLE, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i = jo, a = tf; switch (e) { case "any": i = Oo; break; case "display": break; case "print": i = Fo; break; default: Rl("getRenderingIntent - invalid intent: ".concat(e)) }switch (t) { case Uo.DISABLE: i += Bo; break; case Uo.ENABLE: break; case Uo.ENABLE_FORMS: i += zo; break; case Uo.ENABLE_STORAGE: i += Wo; a = (i & Fo && n instanceof cf ? n : this.annotationStorage).serializable; break; default: Rl("getRenderingIntent - invalid annotationMode: ".concat(t)) }return r && (i += Ho), { renderingIntent: i, cacheKey: "".concat(i, "_").concat(a.hash), annotationStorageSerializable: a } } destroy() { var e; if (this.destroyCapability) return this.destroyCapability.promise; this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), null === (e = Mo(hg, this)) || void 0 === e || e.reject(new Error("Worker was destroyed during onPassword callback")); const t = []; for (const r of Mo(cg, this).values()) t.push(r._destroy()); Mo(cg, this).clear(), Mo(ug, this).clear(), Mo(dg, this).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified(); const n = this.messageHandler.sendWithPromise("Terminate", null); return t.push(n), Promise.all(t).then((() => { var e; this.commonObjs.clear(), this.fontLoader.clear(), Mo(lg, this).clear(), this.filterFactory.destroy(), _m.cleanup(), null === (e = this._networkStream) || void 0 === e || e.cancelAllRequests(new Ul("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve() }), this.destroyCapability.reject), this.destroyCapability.promise } setupMessageHandler() { const { messageHandler: e, loadingTask: t } = this; e.on("GetReader", ((e, t) => { Ll(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = e => { this._lastProgress = { loaded: e.loaded, total: e.total } }, t.onPull = () => { this._fullReader.read().then((function (e) { let { value: n, done: r } = e; r ? t.close() : (Ll(n instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), t.enqueue(new Uint8Array(n), 1, [n])) })).catch((e => { t.error(e) })) }, t.onCancel = e => { this._fullReader.cancel(e), t.ready.catch((e => { if (!this.destroyed) throw e })) } })), e.on("ReaderHeadersReady", (e => { const n = Promise.withResolvers(), r = this._fullReader; return r.headersReady.then((() => { if (!r.isStreamingSupported || !r.isRangeSupported) { var e; if (this._lastProgress) null === (e = t.onProgress) || void 0 === e || e.call(t, this._lastProgress); r.onProgress = e => { var n; null === (n = t.onProgress) || void 0 === n || n.call(t, { loaded: e.loaded, total: e.total }) } } n.resolve({ isStreamingSupported: r.isStreamingSupported, isRangeSupported: r.isRangeSupported, contentLength: r.contentLength }) }), n.reject), n.promise })), e.on("GetRangeReader", ((e, t) => { Ll(this._networkStream, "GetRangeReader - no `IPDFStream` instance available."); const n = this._networkStream.getRangeReader(e.begin, e.end); n ? (t.onPull = () => { n.read().then((function (e) { let { value: n, done: r } = e; r ? t.close() : (Ll(n instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), t.enqueue(new Uint8Array(n), 1, [n])) })).catch((e => { t.error(e) })) }, t.onCancel = e => { n.cancel(e), t.ready.catch((e => { if (!this.destroyed) throw e })) }) : t.close() })), e.on("GetDoc", (e => { let { pdfInfo: n } = e; this._numPages = n.numPages, this._htmlForXfa = n.htmlForXfa, delete n.htmlForXfa, t._capability.resolve(new Gm(n, this)) })), e.on("DocException", (function (e) { let n; switch (e.name) { case "PasswordException": n = new jl(e.message, e.code); break; case "InvalidPDFException": n = new zl(e.message); break; case "MissingPDFException": n = new Wl(e.message); break; case "UnexpectedResponseException": n = new Bl(e.message, e.status); break; case "UnknownErrorException": n = new Fl(e.message, e.details); break; default: Nl("DocException - expected a valid Error.") }t._capability.reject(n) })), e.on("PasswordRequest", (e => { if (To(hg, this, Promise.withResolvers()), t.onPassword) { const r = e => { e instanceof Error ? Mo(hg, this).reject(e) : Mo(hg, this).resolve({ password: e }) }; try { t.onPassword(r, e.code) } catch (n) { Mo(hg, this).reject(n) } } else Mo(hg, this).reject(new jl(e.message, e.code)); return Mo(hg, this).promise })), e.on("DataLoaded", (e => { var n; null === (n = t.onProgress) || void 0 === n || n.call(t, { loaded: e.length, total: e.length }), this.downloadInfoCapability.resolve(e) })), e.on("StartRenderPage", (e => { if (this.destroyed) return; Mo(cg, this).get(e.pageIndex)._startRenderPage(e.transparency, e.cacheKey) })), e.on("commonobj", (t => { var n; let [r, i, a] = t; if (this.destroyed) return null; if (this.commonObjs.has(r)) return null; switch (i) { case "Font": const { disableFontFace: t, fontExtraProperties: s, pdfBug: o } = this._params; if ("error" in a) { const e = a.error; Rl("Error during font loading: ".concat(e)), this.commonObjs.resolve(r, e); break } const l = o && null !== (n = globalThis.FontInspector) && void 0 !== n && n.enabled ? (e, t) => globalThis.FontInspector.fontAdded(e, t) : null, c = new hf(a, { disableFontFace: t, inspectFont: l }); this.fontLoader.bind(c).catch((() => e.sendWithPromise("FontFallback", { id: r }))).finally((() => { !s && c.data && (c.data = null), this.commonObjs.resolve(r, c) })); break; case "CopyLocalImage": const { imageRef: u } = a; Ll(u, "The imageRef must be defined."); for (const e of Mo(cg, this).values()) for (const [, t] of e.objs) if ((null === t || void 0 === t ? void 0 : t.ref) === u) return t.dataLen ? (this.commonObjs.resolve(r, structuredClone(t)), t.dataLen) : null; break; case "FontPath": case "Image": case "Pattern": this.commonObjs.resolve(r, a); break; default: throw new Error("Got unknown common object type ".concat(i)) }return null })), e.on("obj", (e => { let [t, n, r, i] = e; if (this.destroyed) return; const a = Mo(cg, this).get(n); var s; if (!a.objs.has(t)) if (0 !== a._intentStates.size) switch (r) { case "Image": a.objs.resolve(t, i), (null === i || void 0 === i ? void 0 : i.dataLen) > 1e7 && (a._maybeCleanupAfterRender = !0); break; case "Pattern": a.objs.resolve(t, i); break; default: throw new Error("Got unknown object type ".concat(r)) } else null === i || void 0 === i || null === (s = i.bitmap) || void 0 === s || s.close() })), e.on("DocProgress", (e => { var n; this.destroyed || null === (n = t.onProgress) || void 0 === n || n.call(t, { loaded: e.loaded, total: e.total }) })), e.on("FetchBuiltInCMap", (e => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(e) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.")))), e.on("FetchStandardFontData", (e => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(e) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")))) } getData() { return this.messageHandler.sendWithPromise("GetData", null) } saveDocument() { var e, t; this.annotationStorage.size <= 0 && Rl("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."); const { map: n, transfer: r } = this.annotationStorage.serializable; return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: n, filename: null !== (e = null === (t = this._fullReader) || void 0 === t ? void 0 : t.filename) && void 0 !== e ? e : null }, r).finally((() => { this.annotationStorage.resetModified() })) } getPage(e) { if (!Number.isInteger(e) || e <= 0 || e > this._numPages) return Promise.reject(new Error("Invalid page request.")); const t = e - 1, n = Mo(ug, this).get(t); if (n) return n; const r = this.messageHandler.sendWithPromise("GetPage", { pageIndex: t }).then((n => { if (this.destroyed) throw new Error("Transport destroyed"); n.refStr && Mo(dg, this).set(n.refStr, e); const r = new Qm(t, n, this, this._params.pdfBug); return Mo(cg, this).set(t, r), r })); return Mo(ug, this).set(t, r), r } getPageIndex(e) { return Hm(e) ? this.messageHandler.sendWithPromise("GetPageIndex", { num: e.num, gen: e.gen }) : Promise.reject(new Error("Invalid pageIndex request.")) } getAnnotations(e, t) { return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: e, intent: t }) } getFieldObjects() { return _o(fg, this, mg).call(this, "GetFieldObjects") } hasJSActions() { return _o(fg, this, mg).call(this, "HasJSActions") } getCalculationOrderIds() { return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null) } getDestinations() { return this.messageHandler.sendWithPromise("GetDestinations", null) } getDestination(e) { return "string" !== typeof e ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: e }) } getPageLabels() { return this.messageHandler.sendWithPromise("GetPageLabels", null) } getPageLayout() { return this.messageHandler.sendWithPromise("GetPageLayout", null) } getPageMode() { return this.messageHandler.sendWithPromise("GetPageMode", null) } getViewerPreferences() { return this.messageHandler.sendWithPromise("GetViewerPreferences", null) } getOpenAction() { return this.messageHandler.sendWithPromise("GetOpenAction", null) } getAttachments() { return this.messageHandler.sendWithPromise("GetAttachments", null) } getDocJSActions() { return _o(fg, this, mg).call(this, "GetDocJSActions") } getPageJSActions(e) { return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: e }) } getStructTree(e) { return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: e }) } getOutline() { return this.messageHandler.sendWithPromise("GetOutline", null) } getOptionalContentConfig(e) { return _o(fg, this, mg).call(this, "GetOptionalContentConfig").then((t => new Cp(t, e))) } getPermissions() { return this.messageHandler.sendWithPromise("GetPermissions", null) } getMetadata() { const e = "GetMetadata", t = Mo(lg, this).get(e); if (t) return t; const n = this.messageHandler.sendWithPromise(e, null).then((e => { var t, n, r, i; return { info: e[0], metadata: e[1] ? new mp(e[1]) : null, contentDispositionFilename: null !== (t = null === (n = this._fullReader) || void 0 === n ? void 0 : n.filename) && void 0 !== t ? t : null, contentLength: null !== (r = null === (i = this._fullReader) || void 0 === i ? void 0 : i.contentLength) && void 0 !== r ? r : null } })); return Mo(lg, this).set(e, n), n } getMarkInfo() { return this.messageHandler.sendWithPromise("GetMarkInfo", null) } async startCleanup() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (!this.destroyed) { await this.messageHandler.sendWithPromise("Cleanup", null); for (const e of Mo(cg, this).values()) { if (!e.cleanup()) throw new Error("startCleanup: Page ".concat(e.pageNumber, " is currently rendering.")) } this.commonObjs.clear(), e || this.fontLoader.clear(), Mo(lg, this).clear(), this.filterFactory.destroy(!0), _m.cleanup() } } cachedPageNumber(e) { var t; if (!Hm(e)) return null; const n = 0 === e.gen ? "".concat(e.num, "R") : "".concat(e.num, "R").concat(e.gen); return null !== (t = Mo(dg, this).get(n)) && void 0 !== t ? t : null } } function mg(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const n = Mo(lg, this).get(e); if (n) return n; const r = this.messageHandler.sendWithPromise(e, t); return Mo(lg, this).set(e, r), r } const gg = Symbol("INITIAL_DATA"); var vg = new WeakMap, bg = new WeakSet; class yg { constructor() { xo(this, bg), Co(this, vg, Object.create(null)) } get(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (t) { const n = _o(bg, this, wg).call(this, e); return n.promise.then((() => t(n.data))), null } const n = Mo(vg, this)[e]; if (!n || n.data === gg) throw new Error("Requesting object that isn't resolved yet ".concat(e, ".")); return n.data } has(e) { const t = Mo(vg, this)[e]; return !!t && t.data !== gg } resolve(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const n = _o(bg, this, wg).call(this, e); n.data = t, n.resolve() } clear() { for (const t in Mo(vg, this)) { var e; const { data: n } = Mo(vg, this)[t]; null === n || void 0 === n || null === (e = n.bitmap) || void 0 === e || e.close() } To(vg, this, Object.create(null)) } *[Symbol.iterator]() { for (const e in Mo(vg, this)) { const { data: t } = Mo(vg, this)[e]; t !== gg && (yield [e, t]) } } } function wg(e) { var t; return (t = Mo(vg, this))[e] || (t[e] = { ...Promise.withResolvers(), data: gg }) } var xg = new WeakMap; class _g { constructor(e) { Co(this, xg, null), To(xg, this, e), this.onContinue = null } get promise() { return Mo(xg, this).capability.promise } cancel() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; Mo(xg, this).cancel(null, e) } get separateAnnots() { const { separateAnnots: e } = Mo(xg, this).operatorList; if (!e) return !1; const { annotationCanvasMap: t } = Mo(xg, this); return e.form || e.canvas && (null === t || void 0 === t ? void 0 : t.size) > 0 } } var kg = new WeakMap; class Sg { constructor(e) { let { callback: t, params: n, objs: r, commonObjs: i, annotationCanvasMap: a, operatorList: s, pageIndex: o, canvasFactory: l, filterFactory: c, useRequestAnimationFrame: u = !1, pdfBug: d = !1, pageColors: h = null } = e; Co(this, kg, null), this.callback = t, this.params = n, this.objs = r, this.commonObjs = i, this.annotationCanvasMap = a, this.operatorListIdx = null, this.operatorList = s, this._pageIndex = o, this.canvasFactory = l, this.filterFactory = c, this._pdfBug = d, this.pageColors = h, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = !0 === u && "undefined" !== typeof window, this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new _g(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = n.canvasContext.canvas } get completed() { return this.capability.promise.catch((function () { })) } initializeGraphics(e) { var t, n; let { transparency: r = !1, optionalContentConfig: i } = e; if (this.cancelled) return; if (this._canvas) { if (Ag._.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed."); Ag._.add(this._canvas) } this._pdfBug && null !== (t = globalThis.StepperManager) && void 0 !== t && t.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint()); const { canvasContext: a, viewport: s, transform: o, background: l } = this.params; this.gfx = new qf(a, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: i }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({ transform: o, viewport: s, transparency: r, background: l }), this.operatorListIdx = 0, this.graphicsReady = !0, null === (n = this.graphicsReadyCallback) || void 0 === n || n.call(this) } cancel() { var e; let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; this.running = !1, this.cancelled = !0, null === (e = this.gfx) || void 0 === e || e.endDrawing(), Mo(kg, this) && (window.cancelAnimationFrame(Mo(kg, this)), To(kg, this, null)), Ag._.delete(this._canvas), this.callback(t || new Hc("Rendering cancelled, page ".concat(this._pageIndex + 1), n)) } operatorListChanged() { var e; this.graphicsReady ? (null === (e = this.stepper) || void 0 === e || e.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound) } _continue() { this.running = !0, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext()) } _scheduleNext() { this._useRequestAnimationFrame ? To(kg, this, window.requestAnimationFrame((() => { To(kg, this, null), this._nextBound().catch(this._cancelBound) }))) : Promise.resolve().then(this._nextBound).catch(this._cancelBound) } async _next() { this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), Ag._.delete(this._canvas), this.callback()))) } } var Ag = { _: new WeakSet }; const Eg = "4.4.168", Cg = "19fbc8998"; function Mg(e) { return Math.floor(255 * Math.max(0, Math.min(1, e))).toString(16).padStart(2, "0") } function Tg(e) { return Math.max(0, Math.min(255, 255 * e)) } class Pg { static CMYK_G(e) { let [t, n, r, i] = e; return ["G", 1 - Math.min(1, .3 * t + .59 * r + .11 * n + i)] } static G_CMYK(e) { let [t] = e; return ["CMYK", 0, 0, 0, 1 - t] } static G_RGB(e) { let [t] = e; return ["RGB", t, t, t] } static G_rgb(e) { let [t] = e; return t = Tg(t), [t, t, t] } static G_HTML(e) { let [t] = e; const n = Mg(t); return "#".concat(n).concat(n).concat(n) } static RGB_G(e) { let [t, n, r] = e; return ["G", .3 * t + .59 * n + .11 * r] } static RGB_rgb(e) { return e.map(Tg) } static RGB_HTML(e) { return "#".concat(e.map(Mg).join("")) } static T_HTML() { return "#00000000" } static T_rgb() { return [null] } static CMYK_RGB(e) { let [t, n, r, i] = e; return ["RGB", 1 - Math.min(1, t + i), 1 - Math.min(1, r + i), 1 - Math.min(1, n + i)] } static CMYK_rgb(e) { let [t, n, r, i] = e; return [Tg(1 - Math.min(1, t + i)), Tg(1 - Math.min(1, r + i)), Tg(1 - Math.min(1, n + i))] } static CMYK_HTML(e) { const t = this.CMYK_RGB(e).slice(1); return this.RGB_HTML(t) } static RGB_CMYK(e) { let [t, n, r] = e; const i = 1 - t, a = 1 - n, s = 1 - r; return ["CMYK", i, a, s, Math.min(i, a, s)] } } class Rg { static setupStorage(e, t, n, r, i) { const a = r.getValue(t, { value: null }); switch (n.name) { case "textarea": if (null !== a.value && (e.textContent = a.value), "print" === i) break; e.addEventListener("input", (e => { r.setValue(t, { value: e.target.value }) })); break; case "input": if ("radio" === n.attributes.type || "checkbox" === n.attributes.type) { if (a.value === n.attributes.xfaOn ? e.setAttribute("checked", !0) : a.value === n.attributes.xfaOff && e.removeAttribute("checked"), "print" === i) break; e.addEventListener("change", (e => { r.setValue(t, { value: e.target.checked ? e.target.getAttribute("xfaOn") : e.target.getAttribute("xfaOff") }) })) } else { if (null !== a.value && e.setAttribute("value", a.value), "print" === i) break; e.addEventListener("input", (e => { r.setValue(t, { value: e.target.value }) })) } break; case "select": if (null !== a.value) { e.setAttribute("value", a.value); for (const e of n.children) e.attributes.value === a.value ? e.attributes.selected = !0 : e.attributes.hasOwnProperty("selected") && delete e.attributes.selected } e.addEventListener("input", (e => { const n = e.target.options, i = -1 === n.selectedIndex ? "" : n[n.selectedIndex].value; r.setValue(t, { value: i }) })) } } static setAttributes(e) { let { html: t, element: n, storage: r = null, intent: i, linkService: a } = e; const { attributes: s } = n, o = t instanceof HTMLAnchorElement; "radio" === s.type && (s.name = "".concat(s.name, "-").concat(i)); for (const [l, c] of Object.entries(s)) if (null !== c && void 0 !== c) switch (l) { case "class": c.length && t.setAttribute(l, c.join(" ")); break; case "dataId": break; case "id": t.setAttribute("data-element-id", c); break; case "style": Object.assign(t.style, c); break; case "textContent": t.textContent = c; break; default: (!o || "href" !== l && "newWindow" !== l) && t.setAttribute(l, c) }o && a.addLinkAttributes(t, s.href, s.newWindow), r && s.dataId && this.setupStorage(t, s.dataId, n, r) } static render(e) { const t = e.annotationStorage, n = e.linkService, r = e.xfaHtml, i = e.intent || "display", a = document.createElement(r.name); r.attributes && this.setAttributes({ html: a, element: r, intent: i, linkService: n }); const s = "richText" !== i, o = e.div; if (o.append(a), e.viewport) { const t = "matrix(".concat(e.viewport.transform.join(","), ")"); o.style.transform = t } s && o.setAttribute("class", "xfaLayer xfaFont"); const l = []; if (0 === r.children.length) { if (r.value) { const e = document.createTextNode(r.value); a.append(e), s && Dm.shouldBuildText(r.name) && l.push(e) } return { textDivs: l } } const c = [[r, -1, a]]; for (; c.length > 0;) { var u, d; const [e, r, a] = c.at(-1); if (r + 1 === e.children.length) { c.pop(); continue } const o = e.children[++c.at(-1)[1]]; if (null === o) continue; const { name: h } = o; if ("#text" === h) { const e = document.createTextNode(o.value); l.push(e), a.append(e); continue } const f = null !== o && void 0 !== o && null !== (u = o.attributes) && void 0 !== u && u.xmlns ? document.createElementNS(o.attributes.xmlns, h) : document.createElement(h); if (a.append(f), o.attributes && this.setAttributes({ html: f, element: o, storage: t, intent: i, linkService: n }), (null === (d = o.children) || void 0 === d ? void 0 : d.length) > 0) c.push([o, -1, f]); else if (o.value) { const e = document.createTextNode(o.value); s && Dm.shouldBuildText(h) && l.push(e), f.append(e) } } for (const h of o.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) h.setAttribute("readOnly", !0); return { textDivs: l } } static update(e) { const t = "matrix(".concat(e.viewport.transform.join(","), ")"); e.div.style.transform = t, e.div.hidden = !1 } } const Ng = 1e3, Lg = new WeakSet; function Ig(e) { return { width: e[2] - e[0], height: e[3] - e[1] } } class Dg { static create(e) { switch (e.data.annotationType) { case tl: return new Ug(e); case el: return new Xg(e); case vl: switch (e.data.fieldType) { case "Tx": return new Kg(e); case "Btn": return e.data.radioButton ? new Jg(e) : e.data.checkBox ? new $g(e) : new Zg(e); case "Ch": return new ev(e); case "Sig": return new Qg(e) }return new Yg(e); case ml: return new tv(e); case nl: return new Nv(e); case rl: return new Iv(e); case il: return new Ov(e); case al: return new Fv(e); case ol: return new Wv(e); case fl: return new Hv(e); case pl: return new Vv(e); case sl: return new Bv(e); case ll: return new qv(e); case cl: return new Gv(e); case ul: return new Xv(e); case dl: return new Yv(e); case hl: return new Kv(e); case gl: return new Jv(e); default: return new Wg(e) } } } var Og = new WeakMap, jg = new WeakMap, Fg = new WeakMap, zg = new WeakSet; class Wg { constructor(e) { let { isRenderable: t = !1, ignoreBorder: n = !1, createQuadrilaterals: r = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; xo(this, zg), Co(this, Og, null), Co(this, jg, !1), Co(this, Fg, null), this.isRenderable = t, this.data = e.data, this.layer = e.layer, this.linkService = e.linkService, this.downloadManager = e.downloadManager, this.imageResourcesPath = e.imageResourcesPath, this.renderForms = e.renderForms, this.svgFactory = e.svgFactory, this.annotationStorage = e.annotationStorage, this.enableScripting = e.enableScripting, this.hasJSActions = e.hasJSActions, this._fieldObjects = e.fieldObjects, this.parent = e.parent, t && (this.container = this._createContainer(n)), r && this._createQuadrilaterals() } static _hasPopupData(e) { let { titleObj: t, contentsObj: n, richText: r } = e; return !!(null !== t && void 0 !== t && t.str || null !== n && void 0 !== n && n.str || null !== r && void 0 !== r && r.str) } get hasPopupData() { return Wg._hasPopupData(this.data) } updateEdited(e) { var t; if (!this.container) return; Mo(Og, this) || To(Og, this, { rect: this.data.rect.slice(0) }); const { rect: n } = e; n && _o(zg, this, Bg).call(this, n), null === (t = Mo(Fg, this)) || void 0 === t || t.popup.updateEdited(e) } resetEdited() { var e; Mo(Og, this) && (_o(zg, this, Bg).call(this, Mo(Og, this).rect), null === (e = Mo(Fg, this)) || void 0 === e || e.popup.resetEdited(), To(Og, this, null)) } _createContainer(e) { const { data: t, parent: { page: n, viewport: r } } = this, i = document.createElement("section"); i.setAttribute("data-annotation-id", t.id), this instanceof Yg || (i.tabIndex = Ng); const { style: a } = i; if (a.zIndex = this.parent.zIndex++, t.popupRef && i.setAttribute("aria-haspopup", "dialog"), t.alternativeText && (i.title = t.alternativeText), t.noRotate && i.classList.add("norotate"), !t.rect || this instanceof tv) { const { rotation: e } = t; return t.hasOwnCanvas || 0 === e || this.setRotation(e, i), i } const { width: s, height: o } = Ig(t.rect); if (!e && t.borderStyle.width > 0) { a.borderWidth = "".concat(t.borderStyle.width, "px"); const e = t.borderStyle.horizontalCornerRadius, n = t.borderStyle.verticalCornerRadius; if (e > 0 || n > 0) { const t = "calc(".concat(e, "px * var(--scale-factor)) / calc(").concat(n, "px * var(--scale-factor))"); a.borderRadius = t } else if (this instanceof Jg) { const e = "calc(".concat(s, "px * var(--scale-factor)) / calc(").concat(o, "px * var(--scale-factor))"); a.borderRadius = e } switch (t.borderStyle.style) { case bl: a.borderStyle = "solid"; break; case yl: a.borderStyle = "dashed"; break; case wl: Rl("Unimplemented border style: beveled"); break; case xl: Rl("Unimplemented border style: inset"); break; case _l: a.borderBottomStyle = "solid" }const r = t.borderColor || null; r ? (To(jg, this, !0), a.borderColor = Kl.makeHexColor(0 | r[0], 0 | r[1], 0 | r[2])) : a.borderWidth = 0 } const l = Kl.normalizeRect([t.rect[0], n.view[3] - t.rect[1] + n.view[1], t.rect[2], n.view[3] - t.rect[3] + n.view[1]]), { pageWidth: c, pageHeight: u, pageX: d, pageY: h } = r.rawDims; a.left = "".concat(100 * (l[0] - d) / c, "%"), a.top = "".concat(100 * (l[1] - h) / u, "%"); const { rotation: f } = t; return t.hasOwnCanvas || 0 === f ? (a.width = "".concat(100 * s / c, "%"), a.height = "".concat(100 * o / u, "%")) : this.setRotation(f, i), i } setRotation(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.container; if (!this.data.rect) return; const { pageWidth: n, pageHeight: r } = this.parent.viewport.rawDims, { width: i, height: a } = Ig(this.data.rect); let s, o; e % 180 === 0 ? (s = 100 * i / n, o = 100 * a / r) : (s = 100 * a / n, o = 100 * i / r), t.style.width = "".concat(s, "%"), t.style.height = "".concat(o, "%"), t.setAttribute("data-main-rotation", (360 - e) % 360) } get _commonActions() { const e = (e, t, n) => { const r = n.detail[e], i = r[0], a = r.slice(1); n.target.style[t] = Pg["".concat(i, "_HTML")](a), this.annotationStorage.setValue(this.data.id, { [t]: Pg["".concat(i, "_rgb")](a) }) }; return Dl(this, "_commonActions", { display: e => { const { display: t } = e.detail, n = t % 2 === 1; this.container.style.visibility = n ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noView: n, noPrint: 1 === t || 2 === t }) }, print: e => { this.annotationStorage.setValue(this.data.id, { noPrint: !e.detail.print }) }, hidden: e => { const { hidden: t } = e.detail; this.container.style.visibility = t ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noPrint: t, noView: t }) }, focus: e => { setTimeout((() => e.target.focus({ preventScroll: !1 })), 0) }, userName: e => { e.target.title = e.detail.userName }, readonly: e => { e.target.disabled = e.detail.readonly }, required: e => { this._setRequired(e.target, e.detail.required) }, bgColor: t => { e("bgColor", "backgroundColor", t) }, fillColor: t => { e("fillColor", "backgroundColor", t) }, fgColor: t => { e("fgColor", "color", t) }, textColor: t => { e("textColor", "color", t) }, borderColor: t => { e("borderColor", "borderColor", t) }, strokeColor: t => { e("strokeColor", "borderColor", t) }, rotation: e => { const t = e.detail.rotation; this.setRotation(t), this.annotationStorage.setValue(this.data.id, { rotation: t }) } }) } _dispatchEventFromSandbox(e, t) { const n = this._commonActions; for (const r of Object.keys(t.detail)) { const i = e[r] || n[r]; null === i || void 0 === i || i(t) } } _setDefaultPropertiesFromJS(e) { if (!this.enableScripting) return; const t = this.annotationStorage.getRawValue(this.data.id); if (!t) return; const n = this._commonActions; for (const [r, i] of Object.entries(t)) { const a = n[r]; if (a) { a({ detail: { [r]: i }, target: e }), delete t[r] } } } _createQuadrilaterals() { if (!this.container) return; const { quadPoints: e } = this.data; if (!e) return; const [t, n, r, i] = this.data.rect.map((e => Math.fround(e))); if (8 === e.length) { const [a, s, o, l] = e.subarray(2, 6); if (r === a && i === s && t === o && n === l) return } const { style: a } = this.container; let s; if (Mo(jg, this)) { const { borderColor: e, borderWidth: t } = a; a.borderWidth = 0, s = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', '<g fill="transparent" stroke="'.concat(e, '" stroke-width="').concat(t, '">')], this.container.classList.add("hasBorder") } const o = r - t, l = i - n, { svgFactory: c } = this, u = c.createElement("svg"); u.classList.add("quadrilateralsContainer"), u.setAttribute("width", 0), u.setAttribute("height", 0); const d = c.createElement("defs"); u.append(d); const h = c.createElement("clipPath"), f = "clippath_".concat(this.data.id); h.setAttribute("id", f), h.setAttribute("clipPathUnits", "objectBoundingBox"), d.append(h); for (let m = 2, g = e.length; m < g; m += 8) { var p; const n = e[m], r = e[m + 1], a = e[m + 2], u = e[m + 3], d = c.createElement("rect"), f = (a - t) / o, g = (i - r) / l, v = (n - a) / o, b = (r - u) / l; d.setAttribute("x", f), d.setAttribute("y", g), d.setAttribute("width", v), d.setAttribute("height", b), h.append(d), null === (p = s) || void 0 === p || p.push('<rect vector-effect="non-scaling-stroke" x="'.concat(f, '" y="').concat(g, '" width="').concat(v, '" height="').concat(b, '"/>')) } Mo(jg, this) && (s.push("</g></svg>')"), a.backgroundImage = s.join("")), this.container.append(u), this.container.style.clipPath = "url(#".concat(f, ")") } _createPopup() { const { container: e, data: t } = this; e.setAttribute("aria-haspopup", "dialog"); const n = To(Fg, this, new tv({ data: { color: t.color, titleObj: t.titleObj, modificationDate: t.modificationDate, contentsObj: t.contentsObj, richText: t.richText, parentRect: t.rect, borderStyle: 0, id: "popup_".concat(t.id), rotation: t.rotation }, parent: this.parent, elements: [this] })); this.parent.div.append(n.render()) } render() { Nl("Abstract method `AnnotationElement.render` called") } _getElementsByName(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const n = []; if (this._fieldObjects) { const r = this._fieldObjects[e]; if (r) for (const { page: e, id: i, exportValues: a } of r) { if (-1 === e) continue; if (i === t) continue; const r = "string" === typeof a ? a : null, s = document.querySelector('[data-element-id="'.concat(i, '"]')); !s || Lg.has(s) ? n.push({ id: i, exportValue: r, domElement: s }) : Rl("_getElementsByName - element not allowed: ".concat(i)) } return n } for (const r of document.getElementsByName(e)) { const { exportValue: e } = r, i = r.getAttribute("data-element-id"); i !== t && (Lg.has(r) && n.push({ id: i, exportValue: e, domElement: r })) } return n } show() { var e; this.container && (this.container.hidden = !1), null === (e = this.popup) || void 0 === e || e.maybeShow() } hide() { var e; this.container && (this.container.hidden = !0), null === (e = this.popup) || void 0 === e || e.forceHide() } getElementsToTriggerPopup() { return this.container } addHighlightArea() { const e = this.getElementsToTriggerPopup(); if (Array.isArray(e)) for (const t of e) t.classList.add("highlightArea"); else e.classList.add("highlightArea") } get _isEditable() { return !1 } _editOnDoubleClick() { if (!this._isEditable) return; const { annotationEditorType: e, data: { id: t } } = this; this.container.addEventListener("dblclick", (() => { var n; null === (n = this.linkService.eventBus) || void 0 === n || n.dispatch("switchannotationeditormode", { source: this, mode: e, editId: t }) })) } } function Bg(e) { const { container: { style: t }, data: { rect: n, rotation: r }, parent: { viewport: { rawDims: { pageWidth: i, pageHeight: a, pageX: s, pageY: o } } } } = this; null === n || void 0 === n || n.splice(0, 4, ...e); const { width: l, height: c } = Ig(e); t.left = "".concat(100 * (e[0] - s) / i, "%"), t.top = "".concat(100 * (a - e[3] + o) / a, "%"), 0 === r ? (t.width = "".concat(100 * l / i, "%"), t.height = "".concat(100 * c / a, "%")) : this.setRotation(r) } var Hg = new WeakSet; class Ug extends Wg { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; super(e, { isRenderable: !0, ignoreBorder: !(null === t || void 0 === t || !t.ignoreBorder), createQuadrilaterals: !0 }), xo(this, Hg), this.isTooltipOnly = e.data.isTooltipOnly } render() { const { data: e, linkService: t } = this, n = document.createElement("a"); n.setAttribute("data-element-id", e.id); let r = !1; return e.url ? (t.addLinkAttributes(n, e.url, e.newWindow), r = !0) : e.action ? (this._bindNamedAction(n, e.action), r = !0) : e.attachment ? (_o(Hg, this, qg).call(this, n, e.attachment, e.attachmentDest), r = !0) : e.setOCGState ? (_o(Hg, this, Gg).call(this, n, e.setOCGState), r = !0) : e.dest ? (this._bindLink(n, e.dest), r = !0) : (e.actions && (e.actions.Action || e.actions["Mouse Up"] || e.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(n, e), r = !0), e.resetForm ? (this._bindResetFormAction(n, e.resetForm), r = !0) : this.isTooltipOnly && !r && (this._bindLink(n, ""), r = !0)), this.container.classList.add("linkAnnotation"), r && this.container.append(n), this.container } _bindLink(e, t) { e.href = this.linkService.getDestinationHash(t), e.onclick = () => (t && this.linkService.goToDestination(t), !1), (t || "" === t) && _o(Hg, this, Vg).call(this) } _bindNamedAction(e, t) { e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeNamedAction(t), !1), _o(Hg, this, Vg).call(this) } _bindJSAction(e, t) { e.href = this.linkService.getAnchorUrl(""); const n = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]); for (const r of Object.keys(t.actions)) { const i = n.get(r); i && (e[i] = () => { var e; return null === (e = this.linkService.eventBus) || void 0 === e || e.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t.id, name: r } }), !1 }) } e.onclick || (e.onclick = () => !1), _o(Hg, this, Vg).call(this) } _bindResetFormAction(e, t) { const n = e.onclick; if (n || (e.href = this.linkService.getAnchorUrl("")), _o(Hg, this, Vg).call(this), !this._fieldObjects) return Rl('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), void (n || (e.onclick = () => !1)); e.onclick = () => { null === n || void 0 === n || n(); const { fields: e, refs: r, include: i } = t, a = []; if (0 !== e.length || 0 !== r.length) { const t = new Set(r); for (const n of e) { const e = this._fieldObjects[n] || []; for (const { id: n } of e) t.add(n) } for (const e of Object.values(this._fieldObjects)) for (const n of e) t.has(n.id) === i && a.push(n) } else for (const t of Object.values(this._fieldObjects)) a.push(...t); const s = this.annotationStorage, o = []; for (const t of a) { const { id: e } = t; switch (o.push(e), t.type) { case "text": { const n = t.defaultValue || ""; s.setValue(e, { value: n }); break } case "checkbox": case "radiobutton": { const n = t.defaultValue === t.exportValues; s.setValue(e, { value: n }); break } case "combobox": case "listbox": { const n = t.defaultValue || ""; s.setValue(e, { value: n }); break } default: continue }const n = document.querySelector('[data-element-id="'.concat(e, '"]')); n && (Lg.has(n) ? n.dispatchEvent(new Event("resetform")) : Rl("_bindResetFormAction - element not allowed: ".concat(e))) } var l; this.enableScripting && (null === (l = this.linkService.eventBus) || void 0 === l || l.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: o, name: "ResetForm" } })); return !1 } } } function Vg() { this.container.setAttribute("data-internal-link", "") } function qg(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; e.href = this.linkService.getAnchorUrl(""), t.description && (e.title = t.description), e.onclick = () => { var e; return null === (e = this.downloadManager) || void 0 === e || e.openOrDownloadData(t.content, t.filename, n), !1 }, _o(Hg, this, Vg).call(this) } function Gg(e, t) { e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeSetOCGState(t), !1), _o(Hg, this, Vg).call(this) } class Xg extends Wg { constructor(e) { super(e, { isRenderable: !0 }) } render() { this.container.classList.add("textAnnotation"); const e = document.createElement("img"); return e.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e.setAttribute("data-l10n-args", JSON.stringify({ type: this.data.name })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e), this.container } } class Yg extends Wg { render() { return this.container } showElementAndHideCanvas(e) { var t; this.data.hasOwnCanvas && ("CANVAS" === (null === (t = e.previousSibling) || void 0 === t ? void 0 : t.nodeName) && (e.previousSibling.hidden = !0), e.hidden = !1) } _getKeyModifier(e) { return Xl.platform.isMac ? e.metaKey : e.ctrlKey } _setEventListener(e, t, n, r, i) { n.includes("mouse") ? e.addEventListener(n, (e => { var t; null === (t = this.linkService.eventBus) || void 0 === t || t.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: r, value: i(e), shift: e.shiftKey, modifier: this._getKeyModifier(e) } }) })) : e.addEventListener(n, (e => { var a; if ("blur" === n) { if (!t.focused || !e.relatedTarget) return; t.focused = !1 } else if ("focus" === n) { if (t.focused) return; t.focused = !0 } i && (null === (a = this.linkService.eventBus) || void 0 === a || a.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: r, value: i(e) } })) })) } _setEventListeners(e, t, n, r) { for (const [o, l] of n) { var i, a, s; if ("Action" === l || null !== (i = this.data.actions) && void 0 !== i && i[l]) "Focus" !== l && "Blur" !== l || t || (t = { focused: !1 }), this._setEventListener(e, t, o, l, r), "Focus" !== l || null !== (a = this.data.actions) && void 0 !== a && a.Blur ? "Blur" !== l || null !== (s = this.data.actions) && void 0 !== s && s.Focus || this._setEventListener(e, t, "focus", "Focus", null) : this._setEventListener(e, t, "blur", "Blur", null) } } _setBackgroundColor(e) { const t = this.data.backgroundColor || null; e.style.backgroundColor = null === t ? "transparent" : Kl.makeHexColor(t[0], t[1], t[2]) } _setTextStyle(e) { const t = ["left", "center", "right"], { fontColor: n } = this.data.defaultAppearanceData, r = this.data.defaultAppearanceData.fontSize || 9, i = e.style; let a; const s = e => Math.round(10 * e) / 10; if (this.data.multiLine) { const e = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), t = e / (Math.round(e / (Do * r)) || 1); a = Math.min(r, s(t / Do)) } else { const e = Math.abs(this.data.rect[3] - this.data.rect[1] - 2); a = Math.min(r, s(e / Do)) } i.fontSize = "calc(".concat(a, "px * var(--scale-factor))"), i.color = Kl.makeHexColor(n[0], n[1], n[2]), null !== this.data.textAlignment && (i.textAlign = t[this.data.textAlignment]) } _setRequired(e, t) { t ? e.setAttribute("required", !0) : e.removeAttribute("required"), e.setAttribute("aria-required", t) } } class Kg extends Yg { constructor(e) { super(e, { isRenderable: e.renderForms || e.data.hasOwnCanvas || !e.data.hasAppearance && !!e.data.fieldValue }) } setPropertyOnSiblings(e, t, n, r) { const i = this.annotationStorage; for (const a of this._getElementsByName(e.name, e.id)) a.domElement && (a.domElement[t] = n), i.setValue(a.id, { [r]: n }) } render() { const e = this.annotationStorage, t = this.data.id; this.container.classList.add("textWidgetAnnotation"); let n = null; if (this.renderForms) { var r; const o = e.getValue(t, { value: this.data.fieldValue }); let l = o.value || ""; const c = e.getValue(t, { charLimit: this.data.maxLen }).charLimit; c && l.length > c && (l = l.slice(0, c)); let u = o.formattedValue || (null === (r = this.data.textContent) || void 0 === r ? void 0 : r.join("\n")) || null; u && this.data.comb && (u = u.replaceAll(/\s+/g, "")); const d = { userValue: l, formattedValue: u, lastCommittedValue: null, commitKey: 1, focused: !1 }; var i, a; if (this.data.multiLine) n = document.createElement("textarea"), n.textContent = null !== (i = u) && void 0 !== i ? i : l, this.data.doNotScroll && (n.style.overflowY = "hidden"); else n = document.createElement("input"), n.type = "text", n.setAttribute("value", null !== (a = u) && void 0 !== a ? a : l), this.data.doNotScroll && (n.style.overflowX = "hidden"); this.data.hasOwnCanvas && (n.hidden = !0), Lg.add(n), n.setAttribute("data-element-id", t), n.disabled = this.data.readOnly, n.name = this.data.fieldName, n.tabIndex = Ng, this._setRequired(n, this.data.required), c && (n.maxLength = c), n.addEventListener("input", (r => { e.setValue(t, { value: r.target.value }), this.setPropertyOnSiblings(n, "value", r.target.value, "value"), d.formattedValue = null })), n.addEventListener("resetform", (e => { var t; const r = null !== (t = this.data.defaultFieldValue) && void 0 !== t ? t : ""; n.value = d.userValue = r, d.formattedValue = null })); let h = e => { const { formattedValue: t } = d; null !== t && void 0 !== t && (e.target.value = t), e.target.scrollLeft = 0 }; if (this.enableScripting && this.hasJSActions) { var s; n.addEventListener("focus", (e => { var t; if (d.focused) return; const { target: n } = e; d.userValue && (n.value = d.userValue), d.lastCommittedValue = n.value, d.commitKey = 1, null !== (t = this.data.actions) && void 0 !== t && t.Focus || (d.focused = !0) })), n.addEventListener("updatefromsandbox", (n => { this.showElementAndHideCanvas(n.target); const r = { value(n) { var r; d.userValue = null !== (r = n.detail.value) && void 0 !== r ? r : "", e.setValue(t, { value: d.userValue.toString() }), n.target.value = d.userValue }, formattedValue(n) { const { formattedValue: r } = n.detail; d.formattedValue = r, null !== r && void 0 !== r && n.target !== document.activeElement && (n.target.value = r), e.setValue(t, { formattedValue: r }) }, selRange(e) { e.target.setSelectionRange(...e.detail.selRange) }, charLimit: n => { var r; const { charLimit: i } = n.detail, { target: a } = n; if (0 === i) return void a.removeAttribute("maxLength"); a.setAttribute("maxLength", i); let s = d.userValue; !s || s.length <= i || (s = s.slice(0, i), a.value = d.userValue = s, e.setValue(t, { value: s }), null === (r = this.linkService.eventBus) || void 0 === r || r.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t, name: "Keystroke", value: s, willCommit: !0, commitKey: 1, selStart: a.selectionStart, selEnd: a.selectionEnd } })) } }; this._dispatchEventFromSandbox(r, n) })), n.addEventListener("keydown", (e => { var n; d.commitKey = 1; let r = -1; if ("Escape" === e.key ? r = 0 : "Enter" !== e.key || this.data.multiLine ? "Tab" === e.key && (d.commitKey = 3) : r = 2, -1 === r) return; const { value: i } = e.target; d.lastCommittedValue !== i && (d.lastCommittedValue = i, d.userValue = i, null === (n = this.linkService.eventBus) || void 0 === n || n.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t, name: "Keystroke", value: i, willCommit: !0, commitKey: r, selStart: e.target.selectionStart, selEnd: e.target.selectionEnd } })) })); const r = h; h = null, n.addEventListener("blur", (e => { var n; if (!d.focused || !e.relatedTarget) return; null !== (n = this.data.actions) && void 0 !== n && n.Blur || (d.focused = !1); const { value: i } = e.target; var a; (d.userValue = i, d.lastCommittedValue !== i) && (null === (a = this.linkService.eventBus) || void 0 === a || a.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t, name: "Keystroke", value: i, willCommit: !0, commitKey: d.commitKey, selStart: e.target.selectionStart, selEnd: e.target.selectionEnd } })); r(e) })), null !== (s = this.data.actions) && void 0 !== s && s.Keystroke && n.addEventListener("beforeinput", (e => { var n; d.lastCommittedValue = null; const { data: r, target: i } = e, { value: a, selectionStart: s, selectionEnd: o } = i; let l = s, c = o; switch (e.inputType) { case "deleteWordBackward": { const e = a.substring(0, s).match(/\w*[^\w]*$/); e && (l -= e[0].length); break } case "deleteWordForward": { const e = a.substring(s).match(/^[^\w]*\w*/); e && (c += e[0].length); break } case "deleteContentBackward": s === o && (l -= 1); break; case "deleteContentForward": s === o && (c += 1) }e.preventDefault(), null === (n = this.linkService.eventBus) || void 0 === n || n.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t, name: "Keystroke", value: a, change: r || "", willCommit: !1, selStart: l, selEnd: c } }) })), this._setEventListeners(n, d, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e => e.target.value)) } if (h && n.addEventListener("blur", h), this.data.comb) { const e = (this.data.rect[2] - this.data.rect[0]) / c; n.classList.add("comb"), n.style.letterSpacing = "calc(".concat(e, "px * var(--scale-factor) - 1ch)") } } else n = document.createElement("div"), n.textContent = this.data.fieldValue, n.style.verticalAlign = "middle", n.style.display = "table-cell", this.data.hasOwnCanvas && (n.hidden = !0); return this._setTextStyle(n), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container } } class Qg extends Yg { constructor(e) { super(e, { isRenderable: !!e.data.hasOwnCanvas }) } } class $g extends Yg { constructor(e) { super(e, { isRenderable: e.renderForms }) } render() { const e = this.annotationStorage, t = this.data, n = t.id; let r = e.getValue(n, { value: t.exportValue === t.fieldValue }).value; "string" === typeof r && (r = "Off" !== r, e.setValue(n, { value: r })), this.container.classList.add("buttonWidgetAnnotation", "checkBox"); const i = document.createElement("input"); return Lg.add(i), i.setAttribute("data-element-id", n), i.disabled = t.readOnly, this._setRequired(i, this.data.required), i.type = "checkbox", i.name = t.fieldName, r && i.setAttribute("checked", !0), i.setAttribute("exportValue", t.exportValue), i.tabIndex = Ng, i.addEventListener("change", (r => { const { name: i, checked: a } = r.target; for (const s of this._getElementsByName(i, n)) { const n = a && s.exportValue === t.exportValue; s.domElement && (s.domElement.checked = n), e.setValue(s.id, { value: n }) } e.setValue(n, { value: a }) })), i.addEventListener("resetform", (e => { const n = t.defaultFieldValue || "Off"; e.target.checked = n === t.exportValue })), this.enableScripting && this.hasJSActions && (i.addEventListener("updatefromsandbox", (t => { const r = { value(t) { t.target.checked = "Off" !== t.detail.value, e.setValue(n, { value: t.target.checked }) } }; this._dispatchEventFromSandbox(r, t) })), this._setEventListeners(i, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e => e.target.checked))), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container } } class Jg extends Yg { constructor(e) { super(e, { isRenderable: e.renderForms }) } render() { this.container.classList.add("buttonWidgetAnnotation", "radioButton"); const e = this.annotationStorage, t = this.data, n = t.id; let r = e.getValue(n, { value: t.fieldValue === t.buttonValue }).value; if ("string" === typeof r && (r = r !== t.buttonValue, e.setValue(n, { value: r })), r) for (const a of this._getElementsByName(t.fieldName, n)) e.setValue(a.id, { value: !1 }); const i = document.createElement("input"); if (Lg.add(i), i.setAttribute("data-element-id", n), i.disabled = t.readOnly, this._setRequired(i, this.data.required), i.type = "radio", i.name = t.fieldName, r && i.setAttribute("checked", !0), i.tabIndex = Ng, i.addEventListener("change", (t => { const { name: r, checked: i } = t.target; for (const a of this._getElementsByName(r, n)) e.setValue(a.id, { value: !1 }); e.setValue(n, { value: i }) })), i.addEventListener("resetform", (e => { const n = t.defaultFieldValue; e.target.checked = null !== n && void 0 !== n && n === t.buttonValue })), this.enableScripting && this.hasJSActions) { const r = t.buttonValue; i.addEventListener("updatefromsandbox", (t => { const i = { value: t => { const i = r === t.detail.value; for (const r of this._getElementsByName(t.target.name)) { const t = i && r.id === n; r.domElement && (r.domElement.checked = t), e.setValue(r.id, { value: t }) } } }; this._dispatchEventFromSandbox(i, t) })), this._setEventListeners(i, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e => e.target.checked)) } return this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container } } class Zg extends Ug { constructor(e) { super(e, { ignoreBorder: e.data.hasAppearance }) } render() { const e = super.render(); e.classList.add("buttonWidgetAnnotation", "pushButton"); const t = e.lastChild; return this.enableScripting && this.hasJSActions && t && (this._setDefaultPropertiesFromJS(t), t.addEventListener("updatefromsandbox", (e => { this._dispatchEventFromSandbox({}, e) }))), e } } class ev extends Yg { constructor(e) { super(e, { isRenderable: e.renderForms }) } render() { this.container.classList.add("choiceWidgetAnnotation"); const e = this.annotationStorage, t = this.data.id, n = e.getValue(t, { value: this.data.fieldValue }), r = document.createElement("select"); Lg.add(r), r.setAttribute("data-element-id", t), r.disabled = this.data.readOnly, this._setRequired(r, this.data.required), r.name = this.data.fieldName, r.tabIndex = Ng; let i = this.data.combo && this.data.options.length > 0; this.data.combo || (r.size = this.data.options.length, this.data.multiSelect && (r.multiple = !0)), r.addEventListener("resetform", (e => { const t = this.data.defaultFieldValue; for (const n of r.options) n.selected = n.value === t })); for (const c of this.data.options) { const e = document.createElement("option"); e.textContent = c.displayValue, e.value = c.exportValue, n.value.includes(c.exportValue) && (e.setAttribute("selected", !0), i = !1), r.append(e) } let a = null; if (i) { const e = document.createElement("option"); e.value = " ", e.setAttribute("hidden", !0), e.setAttribute("selected", !0), r.prepend(e), a = () => { e.remove(), r.removeEventListener("input", a), a = null }, r.addEventListener("input", a) } const s = e => { const t = e ? "value" : "textContent", { options: n, multiple: i } = r; return i ? Array.prototype.filter.call(n, (e => e.selected)).map((e => e[t])) : -1 === n.selectedIndex ? null : n[n.selectedIndex][t] }; let o = s(!1); const l = e => { const t = e.target.options; return Array.prototype.map.call(t, (e => ({ displayValue: e.textContent, exportValue: e.value }))) }; return this.enableScripting && this.hasJSActions ? (r.addEventListener("updatefromsandbox", (n => { const i = { value(n) { var i; null === (i = a) || void 0 === i || i(); const l = n.detail.value, c = new Set(Array.isArray(l) ? l : [l]); for (const e of r.options) e.selected = c.has(e.value); e.setValue(t, { value: s(!0) }), o = s(!1) }, multipleSelection(e) { r.multiple = !0 }, remove(n) { const i = r.options, a = n.detail.remove; if (i[a].selected = !1, r.remove(a), i.length > 0) { -1 === Array.prototype.findIndex.call(i, (e => e.selected)) && (i[0].selected = !0) } e.setValue(t, { value: s(!0), items: l(n) }), o = s(!1) }, clear(n) { for (; 0 !== r.length;)r.remove(0); e.setValue(t, { value: null, items: [] }), o = s(!1) }, insert(n) { const { index: i, displayValue: a, exportValue: c } = n.detail.insert, u = r.children[i], d = document.createElement("option"); d.textContent = a, d.value = c, u ? u.before(d) : r.append(d), e.setValue(t, { value: s(!0), items: l(n) }), o = s(!1) }, items(n) { const { items: i } = n.detail; for (; 0 !== r.length;)r.remove(0); for (const e of i) { const { displayValue: t, exportValue: n } = e, i = document.createElement("option"); i.textContent = t, i.value = n, r.append(i) } r.options.length > 0 && (r.options[0].selected = !0), e.setValue(t, { value: s(!0), items: l(n) }), o = s(!1) }, indices(n) { const r = new Set(n.detail.indices); for (const e of n.target.options) e.selected = r.has(e.index); e.setValue(t, { value: s(!0) }), o = s(!1) }, editable(e) { e.target.disabled = !e.detail.editable } }; this._dispatchEventFromSandbox(i, n) })), r.addEventListener("input", (n => { var r; const i = s(!0), a = s(!1); e.setValue(t, { value: i }), n.preventDefault(), null === (r = this.linkService.eventBus) || void 0 === r || r.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t, name: "Keystroke", value: o, change: a, changeEx: i, willCommit: !1, commitKey: 1, keyDown: !1 } }) })), this._setEventListeners(r, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (e => e.target.value))) : r.addEventListener("input", (function (n) { e.setValue(t, { value: s(!0) }) })), this.data.combo && this._setTextStyle(r), this._setBackgroundColor(r), this._setDefaultPropertiesFromJS(r), this.container.append(r), this.container } } class tv extends Wg { constructor(e) { const { data: t, elements: n } = e; super(e, { isRenderable: Wg._hasPopupData(t) }), this.elements = n, this.popup = null } render() { this.container.classList.add("popupAnnotation"); const e = this.popup = new _v({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open }), t = []; for (const n of this.elements) n.popup = e, t.push(n.data.id), n.addHighlightArea(); return this.container.setAttribute("aria-controls", t.map((e => "".concat(tc).concat(e))).join(",")), this.container } } var nv = new WeakMap, rv = new WeakMap, iv = new WeakMap, av = new WeakMap, sv = new WeakMap, ov = new WeakMap, lv = new WeakMap, cv = new WeakMap, uv = new WeakMap, dv = new WeakMap, hv = new WeakMap, fv = new WeakMap, pv = new WeakMap, mv = new WeakMap, gv = new WeakMap, vv = new WeakMap, bv = new WeakMap, yv = new WeakMap, wv = new WeakMap, xv = new WeakSet; class _v { constructor(e) { let { container: t, color: n, elements: r, titleObj: i, modificationDate: a, contentsObj: s, richText: o, parent: l, rect: c, parentRect: u, open: d } = e; xo(this, xv), Co(this, nv, _o(xv, this, Cv).bind(this)), Co(this, rv, _o(xv, this, Rv).bind(this)), Co(this, iv, _o(xv, this, Pv).bind(this)), Co(this, av, _o(xv, this, Tv).bind(this)), Co(this, sv, null), Co(this, ov, null), Co(this, lv, null), Co(this, cv, null), Co(this, uv, null), Co(this, dv, null), Co(this, hv, null), Co(this, fv, !1), Co(this, pv, null), Co(this, mv, null), Co(this, gv, null), Co(this, vv, null), Co(this, bv, null), Co(this, yv, null), Co(this, wv, !1), To(ov, this, t), To(bv, this, i), To(lv, this, s), To(vv, this, o), To(dv, this, l), To(sv, this, n), To(gv, this, c), To(hv, this, u), To(uv, this, r), To(cv, this, Jc.toDateObject(a)), this.trigger = r.flatMap((e => e.getElementsToTriggerPopup())); for (const f of this.trigger) f.addEventListener("click", Mo(av, this)), f.addEventListener("mouseenter", Mo(iv, this)), f.addEventListener("mouseleave", Mo(rv, this)), f.classList.add("popupTriggerArea"); for (const f of r) { var h; null === (h = f.container) || void 0 === h || h.addEventListener("keydown", Mo(nv, this)) } Mo(ov, this).hidden = !0, d && _o(xv, this, Tv).call(this) } render() { if (Mo(pv, this)) return; const e = To(pv, this, document.createElement("div")); if (e.className = "popup", Mo(sv, this)) { const t = e.style.outlineColor = Kl.makeHexColor(...Mo(sv, this)); if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) e.style.backgroundColor = "color-mix(in srgb, ".concat(t, " 30%, white)"); else { const t = .7; e.style.backgroundColor = Kl.makeHexColor(...Mo(sv, this).map((e => Math.floor(t * (255 - e) + e)))) } } const t = document.createElement("span"); t.className = "header"; const n = document.createElement("h1"); if (t.append(n), ({ dir: n.dir, str: n.textContent } = Mo(bv, this)), e.append(t), Mo(cv, this)) { const e = document.createElement("span"); e.classList.add("popupDate"), e.setAttribute("data-l10n-id", "pdfjs-annotation-date-string"), e.setAttribute("data-l10n-args", JSON.stringify({ date: Mo(cv, this).toLocaleDateString(), time: Mo(cv, this).toLocaleTimeString() })), t.append(e) } const r = ko(xv, this, kv); if (r) Rg.render({ xfaHtml: r, intent: "richText", div: e }), e.lastChild.classList.add("richText", "popupContent"); else { const t = this._formatContents(Mo(lv, this)); e.append(t) } Mo(ov, this).append(e) } _formatContents(e) { let { str: t, dir: n } = e; const r = document.createElement("p"); r.classList.add("popupContent"), r.dir = n; const i = t.split(/(?:\r\n?|\n)/); for (let a = 0, s = i.length; a < s; ++a) { const e = i[a]; r.append(document.createTextNode(e)), a < s - 1 && r.append(document.createElement("br")) } return r } updateEdited(e) { var t; let { rect: n, popupContent: r } = e; Mo(yv, this) || To(yv, this, { contentsObj: Mo(lv, this), richText: Mo(vv, this) }), n && To(mv, this, null), r && (To(vv, this, _o(xv, this, Ev).call(this, r)), To(lv, this, null)), null === (t = Mo(pv, this)) || void 0 === t || t.remove(), To(pv, this, null) } resetEdited() { var e; Mo(yv, this) && (({ contentsObj: yo(To, [lv, this])._, richText: yo(To, [vv, this])._ } = Mo(yv, this)), To(yv, this, null), null === (e = Mo(pv, this)) || void 0 === e || e.remove(), To(pv, this, null), To(mv, this, null)) } forceHide() { To(wv, this, this.isVisible), Mo(wv, this) && (Mo(ov, this).hidden = !0) } maybeShow() { Mo(wv, this) && (Mo(pv, this) || _o(xv, this, Pv).call(this), To(wv, this, !1), Mo(ov, this).hidden = !1) } get isVisible() { return !1 === Mo(ov, this).hidden } } function kv(e) { const t = Mo(vv, e), n = Mo(lv, e); return null === t || void 0 === t || !t.str || null !== n && void 0 !== n && n.str && n.str !== t.str ? null : Mo(vv, e).html || null } function Sv(e) { var t; return (null === (t = ko(xv, e, kv)) || void 0 === t || null === (t = t.attributes) || void 0 === t || null === (t = t.style) || void 0 === t ? void 0 : t.fontSize) || 0 } function Av(e) { var t; return (null === (t = ko(xv, e, kv)) || void 0 === t || null === (t = t.attributes) || void 0 === t || null === (t = t.style) || void 0 === t ? void 0 : t.color) || null } function Ev(e) { const t = [], n = { str: e, html: { name: "div", attributes: { dir: "auto" }, children: [{ name: "p", children: t }] } }, r = { style: { color: ko(xv, this, Av), fontSize: ko(xv, this, Sv) ? "calc(".concat(ko(xv, this, Sv), "px * var(--scale-factor))") : "" } }; for (const i of e.split("\n")) t.push({ name: "span", value: i, attributes: r }); return n } function Cv(e) { e.altKey || e.shiftKey || e.ctrlKey || e.metaKey || ("Enter" === e.key || "Escape" === e.key && Mo(fv, this)) && _o(xv, this, Tv).call(this) } function Mv() { if (null !== Mo(mv, this)) return; const { page: { view: e }, viewport: { rawDims: { pageWidth: t, pageHeight: n, pageX: r, pageY: i } } } = Mo(dv, this); let a = !!Mo(hv, this), s = Mo(a ? hv : gv, this); for (const h of Mo(uv, this)) if (!s || null !== Kl.intersect(h.data.rect, s)) { s = h.data.rect, a = !0; break } const o = Kl.normalizeRect([s[0], e[3] - s[1] + e[1], s[2], e[3] - s[3] + e[1]]), l = a ? s[2] - s[0] + 5 : 0, c = o[0] + l, u = o[1]; To(mv, this, [100 * (c - r) / t, 100 * (u - i) / n]); const { style: d } = Mo(ov, this); d.left = "".concat(Mo(mv, this)[0], "%"), d.top = "".concat(Mo(mv, this)[1], "%") } function Tv() { To(fv, this, !Mo(fv, this)), Mo(fv, this) ? (_o(xv, this, Pv).call(this), Mo(ov, this).addEventListener("click", Mo(av, this)), Mo(ov, this).addEventListener("keydown", Mo(nv, this))) : (_o(xv, this, Rv).call(this), Mo(ov, this).removeEventListener("click", Mo(av, this)), Mo(ov, this).removeEventListener("keydown", Mo(nv, this))) } function Pv() { Mo(pv, this) || this.render(), this.isVisible ? Mo(fv, this) && Mo(ov, this).classList.add("focused") : (_o(xv, this, Mv).call(this), Mo(ov, this).hidden = !1, Mo(ov, this).style.zIndex = parseInt(Mo(ov, this).style.zIndex) + 1e3) } function Rv() { Mo(ov, this).classList.remove("focused"), !Mo(fv, this) && this.isVisible && (Mo(ov, this).hidden = !0, Mo(ov, this).style.zIndex = parseInt(Mo(ov, this).style.zIndex) - 1e3) } class Nv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }), this.textContent = e.data.textContent, this.textPosition = e.data.textPosition, this.annotationEditorType = Vo.FREETEXT } render() { if (this.container.classList.add("freeTextAnnotation"), this.textContent) { const e = document.createElement("div"); e.classList.add("annotationTextContent"), e.setAttribute("role", "comment"); for (const t of this.textContent) { const n = document.createElement("span"); n.textContent = t, e.append(n) } this.container.append(e) } return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container } get _isEditable() { return this.data.hasOwnCanvas } } var Lv = new WeakMap; class Iv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }), Co(this, Lv, null) } render() { this.container.classList.add("lineAnnotation"); const e = this.data, { width: t, height: n } = Ig(e.rect), r = this.svgFactory.create(t, n, !0), i = To(Lv, this, this.svgFactory.createElement("svg:line")); return i.setAttribute("x1", e.rect[2] - e.lineCoordinates[0]), i.setAttribute("y1", e.rect[3] - e.lineCoordinates[1]), i.setAttribute("x2", e.rect[2] - e.lineCoordinates[2]), i.setAttribute("y2", e.rect[3] - e.lineCoordinates[3]), i.setAttribute("stroke-width", e.borderStyle.width || 1), i.setAttribute("stroke", "transparent"), i.setAttribute("fill", "transparent"), r.append(i), this.container.append(r), !e.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return Mo(Lv, this) } addHighlightArea() { this.container.classList.add("highlightArea") } } var Dv = new WeakMap; class Ov extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }), Co(this, Dv, null) } render() { this.container.classList.add("squareAnnotation"); const e = this.data, { width: t, height: n } = Ig(e.rect), r = this.svgFactory.create(t, n, !0), i = e.borderStyle.width, a = To(Dv, this, this.svgFactory.createElement("svg:rect")); return a.setAttribute("x", i / 2), a.setAttribute("y", i / 2), a.setAttribute("width", t - i), a.setAttribute("height", n - i), a.setAttribute("stroke-width", i || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), r.append(a), this.container.append(r), !e.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return Mo(Dv, this) } addHighlightArea() { this.container.classList.add("highlightArea") } } var jv = new WeakMap; class Fv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }), Co(this, jv, null) } render() { this.container.classList.add("circleAnnotation"); const e = this.data, { width: t, height: n } = Ig(e.rect), r = this.svgFactory.create(t, n, !0), i = e.borderStyle.width, a = To(jv, this, this.svgFactory.createElement("svg:ellipse")); return a.setAttribute("cx", t / 2), a.setAttribute("cy", n / 2), a.setAttribute("rx", t / 2 - i / 2), a.setAttribute("ry", n / 2 - i / 2), a.setAttribute("stroke-width", i || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), r.append(a), this.container.append(r), !e.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return Mo(jv, this) } addHighlightArea() { this.container.classList.add("highlightArea") } } var zv = new WeakMap; class Wv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }), Co(this, zv, null), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline" } render() { this.container.classList.add(this.containerClassName); const { data: { rect: e, vertices: t, borderStyle: n, popupRef: r } } = this; if (!t) return this.container; const { width: i, height: a } = Ig(e), s = this.svgFactory.create(i, a, !0); let o = []; for (let c = 0, u = t.length; c < u; c += 2) { const n = t[c] - e[0], r = e[3] - t[c + 1]; o.push("".concat(n, ",").concat(r)) } o = o.join(" "); const l = To(zv, this, this.svgFactory.createElement(this.svgElementName)); return l.setAttribute("points", o), l.setAttribute("stroke-width", n.width || 1), l.setAttribute("stroke", "transparent"), l.setAttribute("fill", "transparent"), s.append(l), this.container.append(s), !r && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return Mo(zv, this) } addHighlightArea() { this.container.classList.add("highlightArea") } } class Bv extends Wv { constructor(e) { super(e), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon" } } class Hv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }) } render() { return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container } } var Uv = new WeakMap; class Vv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }), Co(this, Uv, []), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = Vo.INK } render() { this.container.classList.add(this.containerClassName); const { data: { rect: e, inkLists: t, borderStyle: n, popupRef: r } } = this, { width: i, height: a } = Ig(e), s = this.svgFactory.create(i, a, !0); for (const o of t) { let t = []; for (let n = 0, r = o.length; n < r; n += 2) { const r = o[n] - e[0], i = e[3] - o[n + 1]; t.push("".concat(r, ",").concat(i)) } t = t.join(" "); const i = this.svgFactory.createElement(this.svgElementName); Mo(Uv, this).push(i), i.setAttribute("points", t), i.setAttribute("stroke-width", n.width || 1), i.setAttribute("stroke", "transparent"), i.setAttribute("fill", "transparent"), !r && this.hasPopupData && this._createPopup(), s.append(i) } return this.container.append(s), this.container } getElementsToTriggerPopup() { return Mo(Uv, this) } addHighlightArea() { this.container.classList.add("highlightArea") } } class qv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container } } class Gv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container } } class Xv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container } } class Yv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container } } class Kv extends Wg { constructor(e) { super(e, { isRenderable: !0, ignoreBorder: !0 }) } render() { return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container } } var Qv = new WeakMap, $v = new WeakSet; class Jv extends Wg { constructor(e) { var t; super(e, { isRenderable: !0 }), xo(this, $v), Co(this, Qv, null); const { file: n } = this.data; this.filename = n.filename, this.content = n.content, null === (t = this.linkService.eventBus) || void 0 === t || t.dispatch("fileattachmentannotation", { source: this, ...n }) } render() { this.container.classList.add("fileAttachmentAnnotation"); const { container: e, data: t } = this; let n; t.hasAppearance || 0 === t.fillAlpha ? n = document.createElement("div") : (n = document.createElement("img"), n.src = "".concat(this.imageResourcesPath, "annotation-").concat(/paperclip/i.test(t.name) ? "paperclip" : "pushpin", ".svg"), t.fillAlpha && t.fillAlpha < 1 && (n.style = "filter: opacity(".concat(Math.round(100 * t.fillAlpha), "%);"))), n.addEventListener("dblclick", _o($v, this, Zv).bind(this)), To(Qv, this, n); const { isMac: r } = Xl.platform; return e.addEventListener("keydown", (e => { "Enter" === e.key && (r ? e.metaKey : e.ctrlKey) && _o($v, this, Zv).call(this) })), !t.popupRef && this.hasPopupData ? this._createPopup() : n.classList.add("popupTriggerArea"), e.append(n), e } getElementsToTriggerPopup() { return Mo(Qv, this) } addHighlightArea() { this.container.classList.add("highlightArea") } } function Zv() { var e; null === (e = this.downloadManager) || void 0 === e || e.openOrDownloadData(this.content, this.filename) } var eb = new WeakMap, tb = new WeakMap, nb = new WeakMap, rb = new WeakSet; class ib { constructor(e) { let { div: t, accessibilityManager: n, annotationCanvasMap: r, annotationEditorUIManager: i, page: a, viewport: s } = e; xo(this, rb), Co(this, eb, null), Co(this, tb, null), Co(this, nb, new Map), this.div = t, To(eb, this, n), To(tb, this, r), this.page = a, this.viewport = s, this.zIndex = 0, this._annotationEditorUIManager = i } async render(e) { const { annotations: t } = e, n = this.div; ru(n, this.viewport); const r = new Map, i = { data: null, layer: n, linkService: e.linkService, downloadManager: e.downloadManager, imageResourcesPath: e.imageResourcesPath || "", renderForms: !1 !== e.renderForms, svgFactory: new Wc, annotationStorage: e.annotationStorage || new sf, enableScripting: !0 === e.enableScripting, hasJSActions: e.hasJSActions, fieldObjects: e.fieldObjects, parent: this, elements: null }; for (const s of t) { if (s.noHTML) continue; const e = s.annotationType === ml; if (e) { const e = r.get(s.id); if (!e) continue; i.elements = e } else { const { width: e, height: t } = Ig(s.rect); if (e <= 0 || t <= 0) continue } i.data = s; const t = Dg.create(i); if (!t.isRenderable) continue; if (!e && s.popupRef) { const e = r.get(s.popupRef); e ? e.push(t) : r.set(s.popupRef, [t]) } const n = t.render(); var a; if (s.hidden && (n.style.visibility = "hidden"), _o(rb, this, ab).call(this, n, s.id), t.annotationEditorType > 0) Mo(nb, this).set(t.data.id, t), null === (a = this._annotationEditorUIManager) || void 0 === a || a.renderAnnotationElement(t) } _o(rb, this, sb).call(this) } update(e) { let { viewport: t } = e; const n = this.div; this.viewport = t, ru(n, { rotation: t.rotation }), _o(rb, this, sb).call(this), n.hidden = !1 } getEditableAnnotations() { return Array.from(Mo(nb, this).values()) } getEditableAnnotation(e) { return Mo(nb, this).get(e) } } function ab(e, t) { var n; const r = e.firstChild || e; r.id = "".concat(tc).concat(t), this.div.append(e), null === (n = Mo(eb, this)) || void 0 === n || n.moveElementInDOM(this.div, e, r, !1) } function sb() { if (!Mo(tb, this)) return; const e = this.div; for (const [t, n] of Mo(tb, this)) { const r = e.querySelector('[data-annotation-id="'.concat(t, '"]')); if (!r) continue; n.className = "annotationContent"; const { firstChild: i } = r; i ? "CANVAS" === i.nodeName ? i.replaceWith(n) : i.classList.contains("annotationContent") ? i.after(n) : i.before(n) : r.append(n) } Mo(tb, this).clear() } const ob = /\r\n?|\n/g; var lb = new WeakMap, cb = new WeakMap, ub = new WeakMap, db = new WeakMap, hb = new WeakMap, fb = new WeakMap, pb = new WeakMap, mb = new WeakMap, gb = new WeakMap, vb = new WeakMap, bb = new WeakSet; class yb extends Dh { static get _keyboardManager() { const e = yb.prototype, t = e => e.isEmpty(), n = Dd.TRANSLATE_SMALL, r = Dd.TRANSLATE_BIG; return Dl(this, "_keyboardManager", new zu([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e.commitOrRemove, { bubbles: !0 }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e._translateEmpty, { args: [-n, 0], checker: t }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e._translateEmpty, { args: [-r, 0], checker: t }], [["ArrowRight", "mac+ArrowRight"], e._translateEmpty, { args: [n, 0], checker: t }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e._translateEmpty, { args: [r, 0], checker: t }], [["ArrowUp", "mac+ArrowUp"], e._translateEmpty, { args: [0, -n], checker: t }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e._translateEmpty, { args: [0, -r], checker: t }], [["ArrowDown", "mac+ArrowDown"], e._translateEmpty, { args: [0, n], checker: t }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e._translateEmpty, { args: [0, r], checker: t }]])) } constructor(e) { super({ ...e, name: "freeTextEditor" }), xo(this, bb), Co(this, lb, this.editorDivBlur.bind(this)), Co(this, cb, this.editorDivFocus.bind(this)), Co(this, ub, this.editorDivInput.bind(this)), Co(this, db, this.editorDivKeydown.bind(this)), Co(this, hb, this.editorDivPaste.bind(this)), Co(this, fb, void 0), Co(this, pb, ""), Co(this, mb, "".concat(this.id, "-editor")), Co(this, gb, void 0), Co(this, vb, null), To(fb, this, e.color || yb._defaultColor || Dh._defaultLineColor), To(gb, this, e.fontSize || yb._defaultFontSize) } static initialize(e, t) { Dh.initialize(e, t, { strings: ["pdfjs-free-text-default-content"] }); const n = getComputedStyle(document.documentElement); this._internalPadding = parseFloat(n.getPropertyValue("--freetext-padding")) } static updateDefaultParams(e, t) { switch (e) { case qo.FREETEXT_SIZE: yb._defaultFontSize = t; break; case qo.FREETEXT_COLOR: yb._defaultColor = t } } updateParams(e, t) { switch (e) { case qo.FREETEXT_SIZE: _o(bb, this, wb).call(this, t); break; case qo.FREETEXT_COLOR: _o(bb, this, xb).call(this, t) } } static get defaultPropertiesToUpdate() { return [[qo.FREETEXT_SIZE, yb._defaultFontSize], [qo.FREETEXT_COLOR, yb._defaultColor || Dh._defaultLineColor]] } get propertiesToUpdate() { return [[qo.FREETEXT_SIZE, Mo(gb, this)], [qo.FREETEXT_COLOR, Mo(fb, this)]] } _translateEmpty(e, t) { this._uiManager.translateSelectedEditors(e, t, !0) } getInitialTranslation() { const e = this.parentScale; return [-yb._internalPadding * e, -(yb._internalPadding + Mo(gb, this)) * e] } rebuild() { this.parent && (super.rebuild(), null !== this.div && (this.isAttachedToDOM || this.parent.add(this))) } enableEditMode() { if (this.isInEditMode()) return; this.parent.setEditingState(!1), this.parent.updateToolbar(Vo.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"); const e = this._uiManager._signal; this.editorDiv.addEventListener("keydown", Mo(db, this), { signal: e }), this.editorDiv.addEventListener("focus", Mo(cb, this), { signal: e }), this.editorDiv.addEventListener("blur", Mo(lb, this), { signal: e }), this.editorDiv.addEventListener("input", Mo(ub, this), { signal: e }), this.editorDiv.addEventListener("paste", Mo(hb, this), { signal: e }) } disableEditMode() { this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", Mo(mb, this)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", Mo(db, this)), this.editorDiv.removeEventListener("focus", Mo(cb, this)), this.editorDiv.removeEventListener("blur", Mo(lb, this)), this.editorDiv.removeEventListener("input", Mo(ub, this)), this.editorDiv.removeEventListener("paste", Mo(hb, this)), this.div.focus({ preventScroll: !0 }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing")) } focusin(e) { this._focusEventsAllowed && (super.focusin(e), e.target !== this.editorDiv && this.editorDiv.focus()) } onceAdded() { var e; this.width || (this.enableEditMode(), this.editorDiv.focus(), null !== (e = this._initialOptions) && void 0 !== e && e.isCentered && this.center(), this._initialOptions = null) } isEmpty() { return !this.editorDiv || "" === this.editorDiv.innerText.trim() } remove() { this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove() } commit() { if (!this.isInEditMode()) return; super.commit(), this.disableEditMode(); const e = Mo(pb, this), t = To(pb, this, _o(bb, this, _b).call(this).trimEnd()); if (e === t) return; const n = e => { To(pb, this, e), e ? (_o(bb, this, Ab).call(this), this._uiManager.rebuild(this), _o(bb, this, kb).call(this)) : this.remove() }; this.addCommands({ cmd: () => { n(t) }, undo: () => { n(e) }, mustExec: !1 }), _o(bb, this, kb).call(this) } shouldGetKeyboardEvents() { return this.isInEditMode() } enterInEditMode() { this.enableEditMode(), this.editorDiv.focus() } dblclick(e) { this.enterInEditMode() } keydown(e) { e.target === this.div && "Enter" === e.key && (this.enterInEditMode(), e.preventDefault()) } editorDivKeydown(e) { yb._keyboardManager.exec(this, e) } editorDivFocus(e) { this.isEditing = !0 } editorDivBlur(e) { this.isEditing = !1 } editorDivInput(e) { this.parent.div.classList.toggle("freetextEditing", this.isEmpty()) } disableEditing() { this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline") } enableEditing() { this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0) } render() { if (this.div) return this.div; let e, t; this.width && (e = this.x, t = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", Mo(mb, this)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), Dh._l10nPromise.get("pdfjs-free-text-default-content").then((e => { var t; return null === (t = this.editorDiv) || void 0 === t ? void 0 : t.setAttribute("default-content", e) })), this.editorDiv.contentEditable = !0; const { style: n } = this.editorDiv; if (n.fontSize = "calc(".concat(Mo(gb, this), "px * var(--scale-factor))"), n.color = Mo(fb, this), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), Su(this, this.div, ["dblclick", "keydown"]), this.width) { const [n, r] = this.parentDimensions; if (this.annotationElementId) { const { position: i } = Mo(vb, this); let [a, s] = this.getInitialTranslation();[a, s] = this.pageTranslationToScreen(a, s); const [o, l] = this.pageDimensions, [c, u] = this.pageTranslation; let d, h; switch (this.rotation) { case 0: d = e + (i[0] - c) / o, h = t + this.height - (i[1] - u) / l; break; case 90: d = e + (i[0] - c) / o, h = t - (i[1] - u) / l, [a, s] = [s, -a]; break; case 180: d = e - this.width + (i[0] - c) / o, h = t - (i[1] - u) / l, [a, s] = [-a, -s]; break; case 270: d = e + (i[0] - c - this.height * l) / o, h = t + (i[1] - u - this.width * o) / l, [a, s] = [-s, a] }this.setAt(d * n, h * r, a, s) } else this.setAt(e * n, t * r, this.width * n, this.height * r); _o(bb, this, Ab).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1 } else this._isDraggable = !1, this.editorDiv.contentEditable = !0; return this.div } editorDivPaste(e) { const t = e.clipboardData || window.clipboardData, { types: n } = t; if (1 === n.length && "text/plain" === n[0]) return; e.preventDefault(); const r = Cb.call(yb, t.getData("text") || "").replaceAll(ob, "\n"); if (!r) return; const i = window.getSelection(); if (!i.rangeCount) return; this.editorDiv.normalize(), i.deleteFromDocument(); const a = i.getRangeAt(0); if (!r.includes("\n")) return a.insertNode(document.createTextNode(r)), this.editorDiv.normalize(), void i.collapseToStart(); const { startContainer: s, startOffset: o } = a, l = [], c = []; if (s.nodeType === Node.TEXT_NODE) { const e = s.parentElement; if (c.push(s.nodeValue.slice(o).replaceAll(ob, "")), e !== this.editorDiv) { let t = l; for (const n of this.editorDiv.childNodes) n !== e ? t.push(Sb.call(yb, n)) : t = c } l.push(s.nodeValue.slice(0, o).replaceAll(ob, "")) } else if (s === this.editorDiv) { let e = l, t = 0; for (const n of this.editorDiv.childNodes) t++ === o && (e = c), e.push(Sb.call(yb, n)) } To(pb, this, "".concat(l.join("\n")).concat(r).concat(c.join("\n"))), _o(bb, this, Ab).call(this); const u = new Range; let d = l.reduce(((e, t) => e + t.length), 0); for (const { firstChild: h } of this.editorDiv.childNodes) if (h.nodeType === Node.TEXT_NODE) { const e = h.nodeValue.length; if (d <= e) { u.setStart(h, d), u.setEnd(h, d); break } d -= e } i.removeAllRanges(), i.addRange(u) } get contentDiv() { return this.editorDiv } static deserialize(e, t, n) { let r = null; if (e instanceof Nv) { const { data: { defaultAppearanceData: { fontSize: t, fontColor: n }, rect: i, rotation: a, id: s }, textContent: o, textPosition: l, parent: { page: { pageNumber: c } } } = e; if (!o || 0 === o.length) return null; r = e = { annotationType: Vo.FREETEXT, color: Array.from(n), fontSize: t, value: o.join("\n"), position: l, pageIndex: c - 1, rect: i.slice(0), rotation: a, id: s, deleted: !1 } } const i = super.deserialize(e, t, n); return To(gb, i, e.fontSize), To(fb, i, Kl.makeHexColor(...e.color)), To(pb, i, Cb.call(yb, e.value)), i.annotationElementId = e.id || null, To(vb, i, r), i } serialize() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (this.isEmpty()) return null; if (this.deleted) return { pageIndex: this.pageIndex, id: this.annotationElementId, deleted: !0 }; const t = yb._internalPadding * this.parentScale, n = this.getRect(t, t), r = Dh._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : Mo(fb, this)), i = { annotationType: Vo.FREETEXT, color: r, fontSize: Mo(gb, this), value: _o(bb, this, Eb).call(this), pageIndex: this.pageIndex, rect: n, rotation: this.rotation, structTreeParentId: this._structTreeParentId }; return e ? i : this.annotationElementId && !_o(bb, this, Mb).call(this, i) ? null : (i.id = this.annotationElementId, i) } renderAnnotationElement(e) { const t = super.renderAnnotationElement(e); if (this.deleted) return t; const { style: n } = t; n.fontSize = "calc(".concat(Mo(gb, this), "px * var(--scale-factor))"), n.color = Mo(fb, this), t.replaceChildren(); for (const i of Mo(pb, this).split("\n")) { const e = document.createElement("div"); e.append(i ? document.createTextNode(i) : document.createElement("br")), t.append(e) } const r = yb._internalPadding * this.parentScale; return e.updateEdited({ rect: this.getRect(r, r), popupContent: Mo(pb, this) }), t } resetAnnotationElement(e) { super.resetAnnotationElement(e), e.resetEdited() } } function wb(e) { const t = e => { this.editorDiv.style.fontSize = "calc(".concat(e, "px * var(--scale-factor))"), this.translate(0, -(e - Mo(gb, this)) * this.parentScale), To(gb, this, e), _o(bb, this, kb).call(this) }, n = Mo(gb, this); this.addCommands({ cmd: t.bind(this, e), undo: t.bind(this, n), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.FREETEXT_SIZE, overwriteIfSameType: !0, keepUndo: !0 }) } function xb(e) { const t = e => { To(fb, this, this.editorDiv.style.color = e) }, n = Mo(fb, this); this.addCommands({ cmd: t.bind(this, e), undo: t.bind(this, n), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.FREETEXT_COLOR, overwriteIfSameType: !0, keepUndo: !0 }) } function _b() { const e = []; this.editorDiv.normalize(); for (const t of this.editorDiv.childNodes) e.push(Sb.call(lo, t)); return e.join("\n") } function kb() { const [e, t] = this.parentDimensions; let n; if (this.isAttachedToDOM) n = this.div.getBoundingClientRect(); else { const { currentLayer: e, div: t } = this, r = t.style.display, i = t.classList.contains("hidden"); t.classList.remove("hidden"), t.style.display = "hidden", e.div.append(this.div), n = t.getBoundingClientRect(), t.remove(), t.style.display = r, t.classList.toggle("hidden", i) } this.rotation % 180 === this.parentRotation % 180 ? (this.width = n.width / e, this.height = n.height / t) : (this.width = n.height / e, this.height = n.width / t), this.fixAndSetPosition() } function Sb(e) { return (e.nodeType === Node.TEXT_NODE ? e.nodeValue : e.innerText).replaceAll(ob, "") } function Ab() { if (this.editorDiv.replaceChildren(), Mo(pb, this)) for (const e of Mo(pb, this).split("\n")) { const t = document.createElement("div"); t.append(e ? document.createTextNode(e) : document.createElement("br")), this.editorDiv.append(t) } } function Eb() { return Mo(pb, this).replaceAll("\xa0", " ") } function Cb(e) { return e.replaceAll(" ", "\xa0") } function Mb(e) { const { value: t, fontSize: n, color: r, pageIndex: i } = Mo(vb, this); return this._hasBeenMoved || e.value !== t || e.fontSize !== n || e.color.some(((e, t) => e !== r[t])) || e.pageIndex !== i } lo = yb, Eo(yb, "_freeTextDefaultContent", ""), Eo(yb, "_internalPadding", 0), Eo(yb, "_defaultColor", null), Eo(yb, "_defaultFontSize", 10), Eo(yb, "_type", "freetext"), Eo(yb, "_editorType", Vo.FREETEXT); var Tb = new WeakMap, Pb = new WeakMap, Rb = new WeakMap, Nb = new WeakSet; class Lb { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; xo(this, Nb), Co(this, Tb, void 0), Co(this, Pb, []), Co(this, Rb, []); let i = 1 / 0, a = -1 / 0, s = 1 / 0, o = -1 / 0; const l = 10 ** -4; for (const { x: m, y: g, width: v, height: b } of e) { const e = Math.floor((m - t) / l) * l, n = Math.ceil((m + v + t) / l) * l, r = Math.floor((g - t) / l) * l, c = Math.ceil((g + b + t) / l) * l, u = [e, r, c, !0], d = [n, r, c, !1]; Mo(Pb, this).push(u, d), i = Math.min(i, e), a = Math.max(a, n), s = Math.min(s, r), o = Math.max(o, c) } const c = a - i + 2 * n, u = o - s + 2 * n, d = i - n, h = s - n, f = Mo(Pb, this).at(r ? -1 : -2), p = [f[0], f[2]]; for (const m of Mo(Pb, this)) { const [e, t, n] = m; m[0] = (e - d) / c, m[1] = (t - h) / u, m[2] = (n - h) / u } To(Tb, this, { x: d, y: h, width: c, height: u, lastPoint: p }) } getOutlines() { Mo(Pb, this).sort(((e, t) => e[0] - t[0] || e[1] - t[1] || e[2] - t[2])); const e = []; for (const t of Mo(Pb, this)) t[3] ? (e.push(..._o(Nb, this, Fb).call(this, t)), _o(Nb, this, Ob).call(this, t)) : (_o(Nb, this, jb).call(this, t), e.push(..._o(Nb, this, Fb).call(this, t))); return _o(Nb, this, Ib).call(this, e) } } function Ib(e) { const t = [], n = new Set; for (const a of e) { const [e, n, r] = a; t.push([e, n, a], [e, r, a]) } t.sort(((e, t) => e[1] - t[1] || e[0] - t[0])); for (let a = 0, s = t.length; a < s; a += 2) { const e = t[a][2], r = t[a + 1][2]; e.push(r), r.push(e), n.add(e), n.add(r) } const r = []; let i; for (; n.size > 0;) { const e = n.values().next().value; let [t, a, s, o, l] = e; n.delete(e); let c = t, u = a; for (i = [t, s], r.push(i); ;) { let e; if (n.has(o)) e = o; else { if (!n.has(l)) break; e = l } n.delete(e), [t, a, s, o, l] = e, c !== t && (i.push(c, u, t, u === a ? a : s), c = t), u = u === a ? s : a } i.push(c, u) } return new Hb(r, Mo(Tb, this)) } function Db(e) { const t = Mo(Rb, this); let n = 0, r = t.length - 1; for (; n <= r;) { const i = n + r >> 1, a = t[i][0]; if (a === e) return i; a < e ? n = i + 1 : r = i - 1 } return r + 1 } function Ob(e) { let [, t, n] = e; const r = _o(Nb, this, Db).call(this, t); Mo(Rb, this).splice(r, 0, [t, n]) } function jb(e) { let [, t, n] = e; const r = _o(Nb, this, Db).call(this, t); for (let i = r; i < Mo(Rb, this).length; i++) { const [e, r] = Mo(Rb, this)[i]; if (e !== t) break; if (e === t && r === n) return void Mo(Rb, this).splice(i, 1) } for (let i = r - 1; i >= 0; i--) { const [e, r] = Mo(Rb, this)[i]; if (e !== t) break; if (e === t && r === n) return void Mo(Rb, this).splice(i, 1) } } function Fb(e) { const [t, n, r] = e, i = [[t, n, r]], a = _o(Nb, this, Db).call(this, r); for (let s = 0; s < a; s++) { const [e, n] = Mo(Rb, this)[s]; for (let r = 0, a = i.length; r < a; r++) { const [, s, o] = i[r]; if (!(n <= s || o <= e)) if (s >= e) if (o > n) i[r][1] = n; else { if (1 === a) return []; i.splice(r, 1), r--, a-- } else i[r][2] = e, o > n && i.push([t, n, o]) } } return i } class zb { toSVGPath() { throw new Error("Abstract method `toSVGPath` must be implemented.") } get box() { throw new Error("Abstract getter `box` must be implemented.") } serialize(e, t) { throw new Error("Abstract method `serialize` must be implemented.") } get free() { return this instanceof my } } var Wb = new WeakMap, Bb = new WeakMap; class Hb extends zb { constructor(e, t) { super(), Co(this, Wb, void 0), Co(this, Bb, void 0), To(Bb, this, e), To(Wb, this, t) } toSVGPath() { const e = []; for (const t of Mo(Bb, this)) { let [n, r] = t; e.push("M".concat(n, " ").concat(r)); for (let i = 2; i < t.length; i += 2) { const a = t[i], s = t[i + 1]; a === n ? (e.push("V".concat(s)), r = s) : s === r && (e.push("H".concat(a)), n = a) } e.push("Z") } return e.join(" ") } serialize(e, t) { let [n, r, i, a] = e; const s = [], o = i - n, l = a - r; for (const c of Mo(Bb, this)) { const e = new Array(c.length); for (let t = 0; t < c.length; t += 2)e[t] = n + c[t] * o, e[t + 1] = a - c[t + 1] * l; s.push(e) } return s } get box() { return Mo(Wb, this) } } var Ub = new WeakMap, Vb = new WeakMap, qb = new WeakMap, Gb = new WeakMap, Xb = new WeakMap, Yb = new WeakMap, Kb = new WeakMap, Qb = new WeakMap, $b = new WeakMap, Jb = new WeakMap, Zb = new WeakMap, ey = new WeakMap, ty = new WeakMap, ny = new WeakSet; class ry { constructor(e, t, n, r, i) { let { x: a, y: s } = e, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; xo(this, ny), Co(this, Ub, void 0), Co(this, Vb, []), Co(this, qb, void 0), Co(this, Gb, void 0), Co(this, Xb, []), Co(this, Yb, new Float64Array(18)), Co(this, Kb, void 0), Co(this, Qb, void 0), Co(this, $b, void 0), Co(this, Jb, void 0), Co(this, Zb, void 0), Co(this, ey, void 0), Co(this, ty, []), To(Ub, this, t), To(ey, this, r * n), To(Gb, this, i), Mo(Yb, this).set([NaN, NaN, NaN, NaN, a, s], 6), To(qb, this, o), To(Jb, this, ay._ * n), To($b, this, sy._ * n), To(Zb, this, n), Mo(ty, this).push(a, s) } get free() { return !0 } isEmpty() { return isNaN(Mo(Yb, this)[8]) } add(e) { var t; let { x: n, y: r } = e; To(Kb, this, n), To(Qb, this, r); const [i, a, s, o] = Mo(Ub, this); let [l, c, u, d] = Mo(Yb, this).subarray(8, 12); const h = n - u, f = r - d, p = Math.hypot(h, f); if (p < Mo($b, this)) return !1; const m = p - Mo(Jb, this), g = m / p, v = g * h, b = g * f; let y = l, w = c; l = u, c = d, u += v, d += b, null === (t = Mo(ty, this)) || void 0 === t || t.push(n, r); const x = v / m, _ = -b / m * Mo(ey, this), k = x * Mo(ey, this); if (Mo(Yb, this).set(Mo(Yb, this).subarray(2, 8), 0), Mo(Yb, this).set([u + _, d + k], 4), Mo(Yb, this).set(Mo(Yb, this).subarray(14, 18), 12), Mo(Yb, this).set([u - _, d - k], 16), isNaN(Mo(Yb, this)[6])) return 0 === Mo(Xb, this).length && (Mo(Yb, this).set([l + _, c + k], 2), Mo(Xb, this).push(NaN, NaN, NaN, NaN, (l + _ - i) / s, (c + k - a) / o), Mo(Yb, this).set([l - _, c - k], 14), Mo(Vb, this).push(NaN, NaN, NaN, NaN, (l - _ - i) / s, (c - k - a) / o)), Mo(Yb, this).set([y, w, l, c, u, d], 6), !this.isEmpty(); Mo(Yb, this).set([y, w, l, c, u, d], 6); return Math.abs(Math.atan2(w - c, y - l) - Math.atan2(b, v)) < Math.PI / 2 ? ([l, c, u, d] = Mo(Yb, this).subarray(2, 6), Mo(Xb, this).push(NaN, NaN, NaN, NaN, ((l + u) / 2 - i) / s, ((c + d) / 2 - a) / o), [l, c, y, w] = Mo(Yb, this).subarray(14, 18), Mo(Vb, this).push(NaN, NaN, NaN, NaN, ((y + l) / 2 - i) / s, ((w + c) / 2 - a) / o), !0) : ([y, w, l, c, u, d] = Mo(Yb, this).subarray(0, 6), Mo(Xb, this).push(((y + 5 * l) / 6 - i) / s, ((w + 5 * c) / 6 - a) / o, ((5 * l + u) / 6 - i) / s, ((5 * c + d) / 6 - a) / o, ((l + u) / 2 - i) / s, ((c + d) / 2 - a) / o), [u, d, l, c, y, w] = Mo(Yb, this).subarray(12, 18), Mo(Vb, this).push(((y + 5 * l) / 6 - i) / s, ((w + 5 * c) / 6 - a) / o, ((5 * l + u) / 6 - i) / s, ((5 * c + d) / 6 - a) / o, ((l + u) / 2 - i) / s, ((c + d) / 2 - a) / o), !0) } toSVGPath() { if (this.isEmpty()) return ""; const e = Mo(Xb, this), t = Mo(Vb, this), n = Mo(Yb, this).subarray(4, 6), r = Mo(Yb, this).subarray(16, 18), [i, a, s, o] = Mo(Ub, this), [l, c, u, d] = _o(ny, this, iy).call(this); if (isNaN(Mo(Yb, this)[6]) && !this.isEmpty()) return "M".concat((Mo(Yb, this)[2] - i) / s, " ").concat((Mo(Yb, this)[3] - a) / o, " L").concat((Mo(Yb, this)[4] - i) / s, " ").concat((Mo(Yb, this)[5] - a) / o, " L").concat(l, " ").concat(c, " L").concat(u, " ").concat(d, " L").concat((Mo(Yb, this)[16] - i) / s, " ").concat((Mo(Yb, this)[17] - a) / o, " L").concat((Mo(Yb, this)[14] - i) / s, " ").concat((Mo(Yb, this)[15] - a) / o, " Z"); const h = []; h.push("M".concat(e[4], " ").concat(e[5])); for (let f = 6; f < e.length; f += 6)isNaN(e[f]) ? h.push("L".concat(e[f + 4], " ").concat(e[f + 5])) : h.push("C".concat(e[f], " ").concat(e[f + 1], " ").concat(e[f + 2], " ").concat(e[f + 3], " ").concat(e[f + 4], " ").concat(e[f + 5])); h.push("L".concat((n[0] - i) / s, " ").concat((n[1] - a) / o, " L").concat(l, " ").concat(c, " L").concat(u, " ").concat(d, " L").concat((r[0] - i) / s, " ").concat((r[1] - a) / o)); for (let f = t.length - 6; f >= 6; f -= 6)isNaN(t[f]) ? h.push("L".concat(t[f + 4], " ").concat(t[f + 5])) : h.push("C".concat(t[f], " ").concat(t[f + 1], " ").concat(t[f + 2], " ").concat(t[f + 3], " ").concat(t[f + 4], " ").concat(t[f + 5])); return h.push("L".concat(t[4], " ").concat(t[5], " Z")), h.join(" ") } getOutlines() { var e, t; const n = Mo(Xb, this), r = Mo(Vb, this), i = Mo(Yb, this), a = i.subarray(4, 6), s = i.subarray(16, 18), [o, l, c, u] = Mo(Ub, this), d = new Float64Array((null !== (e = null === (t = Mo(ty, this)) || void 0 === t ? void 0 : t.length) && void 0 !== e ? e : 0) + 2); for (let b = 0, y = d.length - 2; b < y; b += 2)d[b] = (Mo(ty, this)[b] - o) / c, d[b + 1] = (Mo(ty, this)[b + 1] - l) / u; d[d.length - 2] = (Mo(Kb, this) - o) / c, d[d.length - 1] = (Mo(Qb, this) - l) / u; const [h, f, p, m] = _o(ny, this, iy).call(this); if (isNaN(i[6]) && !this.isEmpty()) { const e = new Float64Array(36); return e.set([NaN, NaN, NaN, NaN, (i[2] - o) / c, (i[3] - l) / u, NaN, NaN, NaN, NaN, (i[4] - o) / c, (i[5] - l) / u, NaN, NaN, NaN, NaN, h, f, NaN, NaN, NaN, NaN, p, m, NaN, NaN, NaN, NaN, (i[16] - o) / c, (i[17] - l) / u, NaN, NaN, NaN, NaN, (i[14] - o) / c, (i[15] - l) / u], 0), new my(e, d, Mo(Ub, this), Mo(Zb, this), Mo(qb, this), Mo(Gb, this)) } const g = new Float64Array(Mo(Xb, this).length + 24 + Mo(Vb, this).length); let v = n.length; for (let b = 0; b < v; b += 2)isNaN(n[b]) ? g[b] = g[b + 1] = NaN : (g[b] = n[b], g[b + 1] = n[b + 1]); g.set([NaN, NaN, NaN, NaN, (a[0] - o) / c, (a[1] - l) / u, NaN, NaN, NaN, NaN, h, f, NaN, NaN, NaN, NaN, p, m, NaN, NaN, NaN, NaN, (s[0] - o) / c, (s[1] - l) / u], v), v += 24; for (let b = r.length - 6; b >= 6; b -= 6)for (let e = 0; e < 6; e += 2)isNaN(r[b + e]) ? (g[v] = g[v + 1] = NaN, v += 2) : (g[v] = r[b + e], g[v + 1] = r[b + e + 1], v += 2); return g.set([NaN, NaN, NaN, NaN, r[4], r[5]], v), new my(g, d, Mo(Ub, this), Mo(Zb, this), Mo(qb, this), Mo(Gb, this)) } } function iy() { const e = Mo(Yb, this).subarray(4, 6), t = Mo(Yb, this).subarray(16, 18), [n, r, i, a] = Mo(Ub, this); return [(Mo(Kb, this) + (e[0] - t[0]) / 2 - n) / i, (Mo(Qb, this) + (e[1] - t[1]) / 2 - r) / a, (Mo(Kb, this) + (t[0] - e[0]) / 2 - n) / i, (Mo(Qb, this) + (t[1] - e[1]) / 2 - r) / a] } var ay = { _: 8 }, sy = { _: ay._ + 2 }, oy = new WeakMap, ly = new WeakMap, cy = new WeakMap, uy = new WeakMap, dy = new WeakMap, hy = new WeakMap, fy = new WeakMap, py = new WeakSet; class my extends zb { constructor(e, t, n, r, i, a) { super(), xo(this, py), Co(this, oy, void 0), Co(this, ly, null), Co(this, cy, void 0), Co(this, uy, void 0), Co(this, dy, void 0), Co(this, hy, void 0), Co(this, fy, void 0), To(fy, this, e), To(dy, this, t), To(oy, this, n), To(hy, this, r), To(cy, this, i), To(uy, this, a), _o(py, this, by).call(this, a); const { x: s, y: o, width: l, height: c } = Mo(ly, this); for (let u = 0, d = e.length; u < d; u += 2)e[u] = (e[u] - s) / l, e[u + 1] = (e[u + 1] - o) / c; for (let u = 0, d = t.length; u < d; u += 2)t[u] = (t[u] - s) / l, t[u + 1] = (t[u + 1] - o) / c } toSVGPath() { const e = ["M".concat(Mo(fy, this)[4], " ").concat(Mo(fy, this)[5])]; for (let t = 6, n = Mo(fy, this).length; t < n; t += 6)isNaN(Mo(fy, this)[t]) ? e.push("L".concat(Mo(fy, this)[t + 4], " ").concat(Mo(fy, this)[t + 5])) : e.push("C".concat(Mo(fy, this)[t], " ").concat(Mo(fy, this)[t + 1], " ").concat(Mo(fy, this)[t + 2], " ").concat(Mo(fy, this)[t + 3], " ").concat(Mo(fy, this)[t + 4], " ").concat(Mo(fy, this)[t + 5])); return e.push("Z"), e.join(" ") } serialize(e, t) { let [n, r, i, a] = e; const s = i - n, o = a - r; let l, c; switch (t) { case 0: l = _o(py, this, gy).call(this, Mo(fy, this), n, a, s, -o), c = _o(py, this, gy).call(this, Mo(dy, this), n, a, s, -o); break; case 90: l = _o(py, this, vy).call(this, Mo(fy, this), n, r, s, o), c = _o(py, this, vy).call(this, Mo(dy, this), n, r, s, o); break; case 180: l = _o(py, this, gy).call(this, Mo(fy, this), i, r, -s, o), c = _o(py, this, gy).call(this, Mo(dy, this), i, r, -s, o); break; case 270: l = _o(py, this, vy).call(this, Mo(fy, this), i, a, -s, -o), c = _o(py, this, vy).call(this, Mo(dy, this), i, a, -s, -o) }return { outline: Array.from(l), points: [Array.from(c)] } } get box() { return Mo(ly, this) } getNewOutline(e, t) { const { x: n, y: r, width: i, height: a } = Mo(ly, this), [s, o, l, c] = Mo(oy, this), u = i * l, d = a * c, h = n * l + s, f = r * c + o, p = new ry({ x: Mo(dy, this)[0] * u + h, y: Mo(dy, this)[1] * d + f }, Mo(oy, this), Mo(hy, this), e, Mo(uy, this), null !== t && void 0 !== t ? t : Mo(cy, this)); for (let m = 2; m < Mo(dy, this).length; m += 2)p.add({ x: Mo(dy, this)[m] * u + h, y: Mo(dy, this)[m + 1] * d + f }); return p.getOutlines() } } function gy(e, t, n, r, i) { const a = new Float64Array(e.length); for (let s = 0, o = e.length; s < o; s += 2)a[s] = t + e[s] * r, a[s + 1] = n + e[s + 1] * i; return a } function vy(e, t, n, r, i) { const a = new Float64Array(e.length); for (let s = 0, o = e.length; s < o; s += 2)a[s] = t + e[s + 1] * r, a[s + 1] = n + e[s] * i; return a } function by(e) { const t = Mo(fy, this); let n = t[4], r = t[5], i = n, a = r, s = n, o = r, l = n, c = r; const u = e ? Math.max : Math.min; for (let m = 6, g = t.length; m < g; m += 6) { if (isNaN(t[m])) i = Math.min(i, t[m + 4]), a = Math.min(a, t[m + 5]), s = Math.max(s, t[m + 4]), o = Math.max(o, t[m + 5]), c < t[m + 5] ? (l = t[m + 4], c = t[m + 5]) : c === t[m + 5] && (l = u(l, t[m + 4])); else { const e = Kl.bezierBoundingBox(n, r, ...t.slice(m, m + 6)); i = Math.min(i, e[0]), a = Math.min(a, e[1]), s = Math.max(s, e[2]), o = Math.max(o, e[3]), c < e[3] ? (l = e[2], c = e[3]) : c === e[3] && (l = u(l, e[2])) } n = t[m + 4], r = t[m + 5] } const d = i - Mo(cy, this), h = a - Mo(cy, this), f = s - i + 2 * Mo(cy, this), p = o - a + 2 * Mo(cy, this); To(ly, this, { x: d, y: h, width: f, height: p, lastPoint: [l, c] }) } var yy = new WeakMap, wy = new WeakMap, xy = new WeakMap, _y = new WeakMap, ky = new WeakMap, Sy = new WeakMap, Ay = new WeakMap, Ey = new WeakMap, Cy = new WeakMap, My = new WeakMap, Ty = new WeakMap, Py = new WeakMap, Ry = new WeakSet; class Ny { static get _keyboardManager() { return Dl(this, "_keyboardManager", new zu([[["Escape", "mac+Escape"], Ny.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], Ny.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], Ny.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], Ny.prototype._moveToPrevious], [["Home", "mac+Home"], Ny.prototype._moveToBeginning], [["End", "mac+End"], Ny.prototype._moveToEnd]])) } constructor(e) { var t; let { editor: n = null, uiManager: r = null } = e; xo(this, Ry), Co(this, yy, _o(Ry, this, Dy).bind(this)), Co(this, wy, _o(Ry, this, jy).bind(this)), Co(this, xy, null), Co(this, _y, null), Co(this, ky, void 0), Co(this, Sy, null), Co(this, Ay, !1), Co(this, Ey, !1), Co(this, Cy, null), Co(this, My, void 0), Co(this, Ty, null), Co(this, Py, void 0), n ? (To(Ey, this, !1), To(Py, this, qo.HIGHLIGHT_COLOR), To(Cy, this, n)) : (To(Ey, this, !0), To(Py, this, qo.HIGHLIGHT_DEFAULT_COLOR)), To(Ty, this, (null === n || void 0 === n ? void 0 : n._uiManager) || r), To(My, this, Mo(Ty, this)._eventBus), To(ky, this, (null === n || void 0 === n ? void 0 : n.color) || (null === (t = Mo(Ty, this)) || void 0 === t ? void 0 : t.highlightColors.values().next().value) || "#FFFF98") } renderButton() { const e = To(xy, this, document.createElement("button")); e.className = "colorPicker", e.tabIndex = "0", e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e.setAttribute("aria-haspopup", !0); const t = Mo(Ty, this)._signal; e.addEventListener("click", _o(Ry, this, Oy).bind(this), { signal: t }), e.addEventListener("keydown", Mo(yy, this), { signal: t }); const n = To(_y, this, document.createElement("span")); return n.className = "swatch", n.setAttribute("aria-hidden", !0), n.style.backgroundColor = Mo(ky, this), e.append(n), e } renderMainDropdown() { const e = To(Sy, this, _o(Ry, this, Ly).call(this)); return e.setAttribute("aria-orientation", "horizontal"), e.setAttribute("aria-labelledby", "highlightColorPickerLabel"), e } _colorSelectFromKeyboard(e) { if (e.target === Mo(xy, this)) return void _o(Ry, this, Oy).call(this, e); const t = e.target.getAttribute("data-color"); t && _o(Ry, this, Iy).call(this, t, e) } _moveToNext(e) { var t, n; ko(Ry, this, Fy) ? e.target !== Mo(xy, this) ? null === (t = e.target.nextSibling) || void 0 === t || t.focus() : null === (n = Mo(Sy, this).firstChild) || void 0 === n || n.focus() : _o(Ry, this, Oy).call(this, e) } _moveToPrevious(e) { var t, n; e.target !== (null === (t = Mo(Sy, this)) || void 0 === t ? void 0 : t.firstChild) && e.target !== Mo(xy, this) ? (ko(Ry, this, Fy) || _o(Ry, this, Oy).call(this, e), null === (n = e.target.previousSibling) || void 0 === n || n.focus()) : ko(Ry, this, Fy) && this._hideDropdownFromKeyboard() } _moveToBeginning(e) { var t; ko(Ry, this, Fy) ? null === (t = Mo(Sy, this).firstChild) || void 0 === t || t.focus() : _o(Ry, this, Oy).call(this, e) } _moveToEnd(e) { var t; ko(Ry, this, Fy) ? null === (t = Mo(Sy, this).lastChild) || void 0 === t || t.focus() : _o(Ry, this, Oy).call(this, e) } hideDropdown() { var e; null === (e = Mo(Sy, this)) || void 0 === e || e.classList.add("hidden"), window.removeEventListener("pointerdown", Mo(wy, this)) } _hideDropdownFromKeyboard() { var e; Mo(Ey, this) || (ko(Ry, this, Fy) ? (this.hideDropdown(), Mo(xy, this).focus({ preventScroll: !0, focusVisible: Mo(Ay, this) })) : null === (e = Mo(Cy, this)) || void 0 === e || e.unselect()) } updateColor(e) { if (Mo(_y, this) && (Mo(_y, this).style.backgroundColor = e), !Mo(Sy, this)) return; const t = Mo(Ty, this).highlightColors.values(); for (const n of Mo(Sy, this).children) n.setAttribute("aria-selected", t.next().value === e) } destroy() { var e, t; null === (e = Mo(xy, this)) || void 0 === e || e.remove(), To(xy, this, null), To(_y, this, null), null === (t = Mo(Sy, this)) || void 0 === t || t.remove(), To(Sy, this, null) } } function Ly() { const e = document.createElement("div"), t = Mo(Ty, this)._signal; e.addEventListener("contextmenu", Kc, { signal: t }), e.className = "dropdown", e.role = "listbox", e.setAttribute("aria-multiselectable", !1), e.setAttribute("aria-orientation", "vertical"), e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown"); for (const [n, r] of Mo(Ty, this).highlightColors) { const i = document.createElement("button"); i.tabIndex = "0", i.role = "option", i.setAttribute("data-color", r), i.title = n, i.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-".concat(n)); const a = document.createElement("span"); i.append(a), a.className = "swatch", a.style.backgroundColor = r, i.setAttribute("aria-selected", r === Mo(ky, this)), i.addEventListener("click", _o(Ry, this, Iy).bind(this, r), { signal: t }), e.append(i) } return e.addEventListener("keydown", Mo(yy, this), { signal: t }), e } function Iy(e, t) { t.stopPropagation(), Mo(My, this).dispatch("switchannotationeditorparams", { source: this, type: Mo(Py, this), value: e }) } function Dy(e) { co._keyboardManager.exec(this, e) } function Oy(e) { if (ko(Ry, this, Fy)) return void this.hideDropdown(); if (To(Ay, this, 0 === e.detail), window.addEventListener("pointerdown", Mo(wy, this), { signal: Mo(Ty, this)._signal }), Mo(Sy, this)) return void Mo(Sy, this).classList.remove("hidden"); const t = To(Sy, this, _o(Ry, this, Ly).call(this)); Mo(xy, this).append(t) } function jy(e) { var t; null !== (t = Mo(Sy, this)) && void 0 !== t && t.contains(e.target) || this.hideDropdown() } function Fy(e) { return Mo(Sy, e) && !Mo(Sy, e).classList.contains("hidden") } co = Ny; var zy = new WeakMap, Wy = new WeakMap, By = new WeakMap, Hy = new WeakMap, Uy = new WeakMap, Vy = new WeakMap, qy = new WeakMap, Gy = new WeakMap, Xy = new WeakMap, Yy = new WeakMap, Ky = new WeakMap, Qy = new WeakMap, $y = new WeakMap, Jy = new WeakMap, Zy = new WeakMap, ew = new WeakMap, tw = new WeakMap, nw = new WeakMap, rw = new WeakMap, iw = new WeakSet; class aw extends Dh { static get _keyboardManager() { const e = aw.prototype; return Dl(this, "_keyboardManager", new zu([[["ArrowLeft", "mac+ArrowLeft"], e._moveCaret, { args: [0] }], [["ArrowRight", "mac+ArrowRight"], e._moveCaret, { args: [1] }], [["ArrowUp", "mac+ArrowUp"], e._moveCaret, { args: [2] }], [["ArrowDown", "mac+ArrowDown"], e._moveCaret, { args: [3] }]])) } constructor(e) { super({ ...e, name: "highlightEditor" }), xo(this, iw), Co(this, zy, null), Co(this, Wy, 0), Co(this, By, void 0), Co(this, Hy, null), Co(this, Uy, null), Co(this, Vy, null), Co(this, qy, null), Co(this, Gy, 0), Co(this, Xy, null), Co(this, Yy, null), Co(this, Ky, null), Co(this, Qy, !1), Co(this, $y, _o(iw, this, pw).bind(this)), Co(this, Jy, null), Co(this, Zy, void 0), Co(this, ew, null), Co(this, tw, ""), Co(this, nw, void 0), Co(this, rw, ""), this.color = e.color || aw._defaultColor, To(nw, this, e.thickness || aw._defaultThickness), To(Zy, this, e.opacity || aw._defaultOpacity), To(By, this, e.boxes || null), To(rw, this, e.methodOfCreation || ""), To(tw, this, e.text || ""), this._isDraggable = !1, e.highlightId > -1 ? (To(Qy, this, !0), _o(iw, this, ow).call(this, e), _o(iw, this, hw).call(this)) : (To(zy, this, e.anchorNode), To(Wy, this, e.anchorOffset), To(qy, this, e.focusNode), To(Gy, this, e.focusOffset), _o(iw, this, sw).call(this), _o(iw, this, hw).call(this), this.rotate(this.rotation)) } get telemetryInitialData() { return { action: "added", type: Mo(Qy, this) ? "free_highlight" : "highlight", color: this._uiManager.highlightColorNames.get(this.color), thickness: Mo(nw, this), methodOfCreation: Mo(rw, this) } } get telemetryFinalData() { return { type: "highlight", color: this._uiManager.highlightColorNames.get(this.color) } } static computeTelemetryFinalData(e) { return { numberOfColors: e.get("color").size } } static initialize(e, t) { var n; Dh.initialize(e, t), aw._defaultColor || (aw._defaultColor = (null === (n = t.highlightColors) || void 0 === n ? void 0 : n.values().next().value) || "#fff066") } static updateDefaultParams(e, t) { switch (e) { case qo.HIGHLIGHT_DEFAULT_COLOR: aw._defaultColor = t; break; case qo.HIGHLIGHT_THICKNESS: aw._defaultThickness = t } } translateInPage(e, t) { } get toolbarPosition() { return Mo(Jy, this) } updateParams(e, t) { switch (e) { case qo.HIGHLIGHT_COLOR: _o(iw, this, lw).call(this, t); break; case qo.HIGHLIGHT_THICKNESS: _o(iw, this, cw).call(this, t) } } static get defaultPropertiesToUpdate() { return [[qo.HIGHLIGHT_DEFAULT_COLOR, aw._defaultColor], [qo.HIGHLIGHT_THICKNESS, aw._defaultThickness]] } get propertiesToUpdate() { return [[qo.HIGHLIGHT_COLOR, this.color || aw._defaultColor], [qo.HIGHLIGHT_THICKNESS, Mo(nw, this) || aw._defaultThickness], [qo.HIGHLIGHT_FREE, Mo(Qy, this)]] } async addEditToolbar() { const e = await super.addEditToolbar(); return e ? (this._uiManager.highlightColors && (To(Uy, this, new Ny({ editor: this })), e.addColorPicker(Mo(Uy, this))), e) : null } disableEditing() { super.disableEditing(), this.div.classList.toggle("disabled", !0) } enableEditing() { super.enableEditing(), this.div.classList.toggle("disabled", !1) } fixAndSetPosition() { return super.fixAndSetPosition(_o(iw, this, gw).call(this)) } getBaseTranslation() { return [0, 0] } getRect(e, t) { return super.getRect(e, t, _o(iw, this, gw).call(this)) } onceAdded() { this.parent.addUndoableEditor(this), this.div.focus() } remove() { _o(iw, this, dw).call(this), this._reportTelemetry({ action: "deleted" }), super.remove() } rebuild() { this.parent && (super.rebuild(), null !== this.div && (_o(iw, this, hw).call(this), this.isAttachedToDOM || this.parent.add(this))) } setParent(e) { let t = !1; if (this.parent && !e) _o(iw, this, dw).call(this); else if (e) { var n; _o(iw, this, hw).call(this, e), t = !this.parent && (null === (n = this.div) || void 0 === n ? void 0 : n.classList.contains("selectedEditor")) } super.setParent(e), this.show(this._isVisible), t && this.select() } rotate(e) { const { drawLayer: t } = this.parent; let n; Mo(Qy, this) ? (e = (e - this.rotation + 360) % 360, n = fw.call(aw, Mo(Yy, this).box, e)) : n = fw.call(aw, this, e), t.rotate(Mo(Ky, this), e), t.rotate(Mo(ew, this), e), t.updateBox(Mo(Ky, this), n), t.updateBox(Mo(ew, this), fw.call(aw, Mo(Vy, this).box, e)) } render() { if (this.div) return this.div; const e = super.render(); Mo(tw, this) && (e.setAttribute("aria-label", Mo(tw, this)), e.setAttribute("role", "mark")), Mo(Qy, this) ? e.classList.add("free") : this.div.addEventListener("keydown", Mo($y, this), { signal: this._uiManager._signal }); const t = To(Xy, this, document.createElement("div")); e.append(t), t.setAttribute("aria-hidden", "true"), t.className = "internal", t.style.clipPath = Mo(Hy, this); const [n, r] = this.parentDimensions; return this.setDims(this.width * n, this.height * r), Su(this, Mo(Xy, this), ["pointerover", "pointerleave"]), this.enableEditing(), e } pointerover() { this.parent.drawLayer.addClass(Mo(ew, this), "hovered") } pointerleave() { this.parent.drawLayer.removeClass(Mo(ew, this), "hovered") } _moveCaret(e) { switch (this.parent.unselect(this), e) { case 0: case 2: _o(iw, this, mw).call(this, !0); break; case 1: case 3: _o(iw, this, mw).call(this, !1) } } select() { var e, t; super.select(), Mo(ew, this) && (null === (e = this.parent) || void 0 === e || e.drawLayer.removeClass(Mo(ew, this), "hovered"), null === (t = this.parent) || void 0 === t || t.drawLayer.addClass(Mo(ew, this), "selected")) } unselect() { var e; super.unselect(), Mo(ew, this) && (null === (e = this.parent) || void 0 === e || e.drawLayer.removeClass(Mo(ew, this), "selected"), Mo(Qy, this) || _o(iw, this, mw).call(this, !1)) } get _mustFixPosition() { return !Mo(Qy, this) } show() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._isVisible; super.show(e), this.parent && (this.parent.drawLayer.show(Mo(Ky, this), e), this.parent.drawLayer.show(Mo(ew, this), e)) } static startHighlighting(e, t, n) { let { target: r, x: i, y: a } = n; const { x: s, y: o, width: l, height: c } = r.getBoundingClientRect(), u = t => { _o(aw, this, yw).call(this, e, t) }, d = e._signal, h = { capture: !0, passive: !1, signal: d }, f = e => { e.preventDefault(), e.stopPropagation() }, p = t => { r.removeEventListener("pointermove", u), window.removeEventListener("blur", p), window.removeEventListener("pointerup", p), window.removeEventListener("pointerdown", f, h), window.removeEventListener("contextmenu", Kc), _o(aw, this, ww).call(this, e, t) }; window.addEventListener("blur", p, { signal: d }), window.addEventListener("pointerup", p, { signal: d }), window.addEventListener("pointerdown", f, h), window.addEventListener("contextmenu", Kc, { signal: d }), r.addEventListener("pointermove", u, { signal: d }), this._freeHighlight = new ry({ x: i, y: a }, [s, o, l, c], e.scale, this._defaultThickness / 2, t, .001), ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = e.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0)) } static deserialize(e, t, n) { const r = super.deserialize(e, t, n), { rect: [i, a, s, o], color: l, quadPoints: c } = e; r.color = Kl.makeHexColor(...l), To(Zy, r, e.opacity); const [u, d] = r.pageDimensions; r.width = (s - i) / u, r.height = (o - a) / d; const h = To(By, r, []); for (let f = 0; f < c.length; f += 8)h.push({ x: (c[4] - s) / u, y: (o - (1 - c[f + 5])) / d, width: (c[f + 2] - c[f]) / u, height: (c[f + 5] - c[f + 1]) / d }); return _o(iw, r, sw).call(r), r } serialize() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (this.isEmpty() || e) return null; const t = this.getRect(0, 0), n = Dh._colorManager.convert(this.color); return { annotationType: Vo.HIGHLIGHT, color: n, opacity: Mo(Zy, this), thickness: Mo(nw, this), quadPoints: _o(iw, this, vw).call(this), outlines: _o(iw, this, bw).call(this, t), pageIndex: this.pageIndex, rect: t, rotation: _o(iw, this, gw).call(this), structTreeParentId: this._structTreeParentId } } static canCreateNewEmptyEditor() { return !1 } } function sw() { const e = new Lb(Mo(By, this), .001); To(Yy, this, e.getOutlines()), ({ x: this.x, y: this.y, width: this.width, height: this.height } = Mo(Yy, this).box); const t = new Lb(Mo(By, this), .0025, .001, "ltr" === this._uiManager.direction); To(Vy, this, t.getOutlines()); const { lastPoint: n } = Mo(Vy, this).box; To(Jy, this, [(n[0] - this.x) / this.width, (n[1] - this.y) / this.height]) } function ow(e) { let { highlightOutlines: t, highlightId: n, clipPathId: r } = e; To(Yy, this, t); if (To(Vy, this, t.getNewOutline(Mo(nw, this) / 2 + 1.5, .0025)), n >= 0) To(Ky, this, n), To(Hy, this, r), this.parent.drawLayer.finalizeLine(n, t), To(ew, this, this.parent.drawLayer.highlightOutline(Mo(Vy, this))); else if (this.parent) { const e = this.parent.viewport.rotation; this.parent.drawLayer.updateLine(Mo(Ky, this), t), this.parent.drawLayer.updateBox(Mo(Ky, this), fw.call(uo, Mo(Yy, this).box, (e - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(Mo(ew, this), Mo(Vy, this)), this.parent.drawLayer.updateBox(Mo(ew, this), fw.call(uo, Mo(Vy, this).box, e)) } const { x: i, y: a, width: s, height: o } = t.box; switch (this.rotation) { case 0: this.x = i, this.y = a, this.width = s, this.height = o; break; case 90: { const [e, t] = this.parentDimensions; this.x = a, this.y = 1 - i, this.width = s * t / e, this.height = o * e / t; break } case 180: this.x = 1 - i, this.y = 1 - a, this.width = s, this.height = o; break; case 270: { const [e, t] = this.parentDimensions; this.x = 1 - a, this.y = i, this.width = s * t / e, this.height = o * e / t; break } }const { lastPoint: l } = Mo(Vy, this).box; To(Jy, this, [(l[0] - i) / s, (l[1] - a) / o]) } function lw(e) { const t = e => { var t, n; this.color = e, null === (t = this.parent) || void 0 === t || t.drawLayer.changeColor(Mo(Ky, this), e), null === (n = Mo(Uy, this)) || void 0 === n || n.updateColor(e) }, n = this.color; this.addCommands({ cmd: t.bind(this, e), undo: t.bind(this, n), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.HIGHLIGHT_COLOR, overwriteIfSameType: !0, keepUndo: !0 }), this._reportTelemetry({ action: "color_changed", color: this._uiManager.highlightColorNames.get(e) }, !0) } function cw(e) { const t = Mo(nw, this), n = e => { To(nw, this, e), _o(iw, this, uw).call(this, e) }; this.addCommands({ cmd: n.bind(this, e), undo: n.bind(this, t), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.INK_THICKNESS, overwriteIfSameType: !0, keepUndo: !0 }), this._reportTelemetry({ action: "thickness_changed", thickness: e }, !0) } function uw(e) { if (!Mo(Qy, this)) return; _o(iw, this, ow).call(this, { highlightOutlines: Mo(Yy, this).getNewOutline(e / 2) }), this.fixAndSetPosition(); const [t, n] = this.parentDimensions; this.setDims(this.width * t, this.height * n) } function dw() { null !== Mo(Ky, this) && this.parent && (this.parent.drawLayer.remove(Mo(Ky, this)), To(Ky, this, null), this.parent.drawLayer.remove(Mo(ew, this)), To(ew, this, null)) } function hw() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.parent; null === Mo(Ky, this) && (({ id: yo(To, [Ky, this])._, clipPathId: yo(To, [Hy, this])._ } = e.drawLayer.highlight(Mo(Yy, this), this.color, Mo(Zy, this))), To(ew, this, e.drawLayer.highlightOutline(Mo(Vy, this))), Mo(Xy, this) && (Mo(Xy, this).style.clipPath = Mo(Hy, this))) } function fw(e, t) { let { x: n, y: r, width: i, height: a } = e; switch (t) { case 90: return { x: 1 - r - a, y: n, width: a, height: i }; case 180: return { x: 1 - n - i, y: 1 - r - a, width: i, height: a }; case 270: return { x: r, y: 1 - n - i, width: a, height: i } }return { x: n, y: r, width: i, height: a } } function pw(e) { uo._keyboardManager.exec(this, e) } function mw(e) { if (!Mo(zy, this)) return; const t = window.getSelection(); e ? t.setPosition(Mo(zy, this), Mo(Wy, this)) : t.setPosition(Mo(qy, this), Mo(Gy, this)) } function gw() { return Mo(Qy, this) ? this.rotation : 0 } function vw() { if (Mo(Qy, this)) return null; const [e, t] = this.pageDimensions, n = Mo(By, this), r = new Float32Array(8 * n.length); let i = 0; for (const { x: a, y: s, width: o, height: l } of n) { const n = a * e, c = (1 - s - l) * t; r[i] = r[i + 4] = n, r[i + 1] = r[i + 3] = c, r[i + 2] = r[i + 6] = n + o * e, r[i + 5] = r[i + 7] = c + l * t, i += 8 } return r } function bw(e) { return Mo(Yy, this).serialize(e, _o(iw, this, gw).call(this)) } function yw(e, t) { this._freeHighlight.add(t) && e.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight) } function ww(e, t) { this._freeHighlight.isEmpty() ? e.drawLayer.removeFreeHighlight(this._freeHighlightId) : e.createAndAddNewEditor(t, !1, { highlightId: this._freeHighlightId, highlightOutlines: this._freeHighlight.getOutlines(), clipPathId: this._freeHighlightClipId, methodOfCreation: "main_toolbar" }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "" } uo = aw, Eo(aw, "_defaultColor", null), Eo(aw, "_defaultOpacity", 1), Eo(aw, "_defaultThickness", 12), Eo(aw, "_l10nPromise", void 0), Eo(aw, "_type", "highlight"), Eo(aw, "_editorType", Vo.HIGHLIGHT), Eo(aw, "_freeHighlightId", -1), Eo(aw, "_freeHighlight", null), Eo(aw, "_freeHighlightClipId", ""); var xw = new WeakMap, _w = new WeakMap, kw = new WeakMap, Sw = new WeakMap, Aw = new WeakMap, Ew = new WeakMap, Cw = new WeakMap, Mw = new WeakMap, Tw = new WeakMap, Pw = new WeakMap, Rw = new WeakMap, Nw = new WeakMap, Lw = new WeakMap, Iw = new WeakMap, Dw = new WeakMap, Ow = new WeakSet; class jw extends Dh { constructor(e) { super({ ...e, name: "inkEditor" }), xo(this, Ow), Co(this, xw, 0), Co(this, _w, 0), Co(this, kw, this.canvasPointermove.bind(this)), Co(this, Sw, this.canvasPointerleave.bind(this)), Co(this, Aw, this.canvasPointerup.bind(this)), Co(this, Ew, this.canvasPointerdown.bind(this)), Co(this, Cw, null), Co(this, Mw, new Path2D), Co(this, Tw, !1), Co(this, Pw, !1), Co(this, Rw, !1), Co(this, Nw, null), Co(this, Lw, 0), Co(this, Iw, 0), Co(this, Dw, null), this.color = e.color || null, this.thickness = e.thickness || null, this.opacity = e.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0 } static initialize(e, t) { Dh.initialize(e, t) } static updateDefaultParams(e, t) { switch (e) { case qo.INK_THICKNESS: jw._defaultThickness = t; break; case qo.INK_COLOR: jw._defaultColor = t; break; case qo.INK_OPACITY: jw._defaultOpacity = t / 100 } } updateParams(e, t) { switch (e) { case qo.INK_THICKNESS: _o(Ow, this, Fw).call(this, t); break; case qo.INK_COLOR: _o(Ow, this, zw).call(this, t); break; case qo.INK_OPACITY: _o(Ow, this, Ww).call(this, t) } } static get defaultPropertiesToUpdate() { return [[qo.INK_THICKNESS, jw._defaultThickness], [qo.INK_COLOR, jw._defaultColor || Dh._defaultLineColor], [qo.INK_OPACITY, Math.round(100 * jw._defaultOpacity)]] } get propertiesToUpdate() { var e; return [[qo.INK_THICKNESS, this.thickness || jw._defaultThickness], [qo.INK_COLOR, this.color || jw._defaultColor || Dh._defaultLineColor], [qo.INK_OPACITY, Math.round(100 * (null !== (e = this.opacity) && void 0 !== e ? e : jw._defaultOpacity))]] } rebuild() { this.parent && (super.rebuild(), null !== this.div && (this.canvas || (_o(Ow, this, Jw).call(this), _o(Ow, this, Zw).call(this)), this.isAttachedToDOM || (this.parent.add(this), _o(Ow, this, ex).call(this)), _o(Ow, this, cx).call(this))) } remove() { var e; null !== this.canvas && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, Mo(Cw, this) && (clearTimeout(Mo(Cw, this)), To(Cw, this, null)), null === (e = Mo(Nw, this)) || void 0 === e || e.disconnect(), To(Nw, this, null), super.remove()) } setParent(e) { !this.parent && e ? this._uiManager.removeShouldRescale(this) : this.parent && null === e && this._uiManager.addShouldRescale(this), super.setParent(e) } onScaleChanging() { const [e, t] = this.parentDimensions, n = this.width * e, r = this.height * t; this.setDimensions(n, r) } enableEditMode() { Mo(Tw, this) || null === this.canvas || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", Mo(Ew, this), { signal: this._uiManager._signal })) } disableEditMode() { this.isInEditMode() && null !== this.canvas && (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", Mo(Ew, this))) } onceAdded() { this._isDraggable = !this.isEmpty() } isEmpty() { return 0 === this.paths.length || 1 === this.paths.length && 0 === this.paths[0].length } commit() { Mo(Tw, this) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), To(Tw, this, !0), this.div.classList.add("disabled"), _o(Ow, this, cx).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({ preventScroll: !0 })) } focusin(e) { this._focusEventsAllowed && (super.focusin(e), this.enableEditMode()) } canvasPointerdown(e) { 0 === e.button && this.isInEditMode() && !Mo(Tw, this) && (this.setInForeground(), e.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({ preventScroll: !0 }), _o(Ow, this, Uw).call(this, e.offsetX, e.offsetY)) } canvasPointermove(e) { e.preventDefault(), _o(Ow, this, Vw).call(this, e.offsetX, e.offsetY) } canvasPointerup(e) { e.preventDefault(), _o(Ow, this, $w).call(this, e) } canvasPointerleave(e) { _o(Ow, this, $w).call(this, e) } get isResizable() { return !this.isEmpty() && Mo(Tw, this) } render() { if (this.div) return this.div; let e, t; this.width && (e = this.x, t = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink"); const [n, r, i, a] = _o(Ow, this, Bw).call(this); if (this.setAt(n, r, 0, 0), this.setDims(i, a), _o(Ow, this, Jw).call(this), this.width) { const [n, r] = this.parentDimensions; this.setAspectRatio(this.width * n, this.height * r), this.setAt(e * n, t * r, this.width * n, this.height * r), To(Rw, this, !0), _o(Ow, this, ex).call(this), this.setDims(this.width * n, this.height * r), _o(Ow, this, Qw).call(this), this.div.classList.add("disabled") } else this.div.classList.add("editing"), this.enableEditMode(); return _o(Ow, this, Zw).call(this), this.div } setDimensions(e, t) { const n = Math.round(e), r = Math.round(t); if (Mo(Lw, this) === n && Mo(Iw, this) === r) return; To(Lw, this, n), To(Iw, this, r), this.canvas.style.visibility = "hidden"; const [i, a] = this.parentDimensions; this.width = e / i, this.height = t / a, this.fixAndSetPosition(), Mo(Tw, this) && _o(Ow, this, tx).call(this, e, t), _o(Ow, this, ex).call(this), _o(Ow, this, Qw).call(this), this.canvas.style.visibility = "visible", this.fixDims() } static deserialize(e, t, n) { if (e instanceof Vv) return null; const r = super.deserialize(e, t, n); r.thickness = e.thickness, r.color = Kl.makeHexColor(...e.color), r.opacity = e.opacity; const [i, a] = r.pageDimensions, s = r.width * i, o = r.height * a, l = r.parentScale, c = e.thickness / 2; To(Tw, r, !0), To(Lw, r, Math.round(s)), To(Iw, r, Math.round(o)); const { paths: u, rect: d, rotation: h } = e; for (let { bezier: p } of u) { p = ax.call(jw, p, d, h); const e = []; r.paths.push(e); let t = l * (p[0] - c), n = l * (p[1] - c); for (let r = 2, a = p.length; r < a; r += 6) { const i = l * (p[r] - c), a = l * (p[r + 1] - c), s = l * (p[r + 2] - c), o = l * (p[r + 3] - c), u = l * (p[r + 4] - c), d = l * (p[r + 5] - c); e.push([[t, n], [i, a], [s, o], [u, d]]), t = u, n = d } const i = _o(jw, this, rx).call(this, e); r.bezierPath2D.push(i) } const f = _o(Ow, r, ox).call(r); return To(_w, r, Math.max(Dh.MIN_SIZE, f[2] - f[0])), To(xw, r, Math.max(Dh.MIN_SIZE, f[3] - f[1])), _o(Ow, r, tx).call(r, s, o), r } serialize() { if (this.isEmpty()) return null; const e = this.getRect(0, 0), t = Dh._colorManager.convert(this.ctx.strokeStyle); return { annotationType: Vo.INK, color: t, thickness: this.thickness, opacity: this.opacity, paths: _o(Ow, this, sx).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, e), pageIndex: this.pageIndex, rect: e, rotation: this.rotation, structTreeParentId: this._structTreeParentId } } } function Fw(e) { const t = e => { this.thickness = e, _o(Ow, this, cx).call(this) }, n = this.thickness; this.addCommands({ cmd: t.bind(this, e), undo: t.bind(this, n), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.INK_THICKNESS, overwriteIfSameType: !0, keepUndo: !0 }) } function zw(e) { const t = e => { this.color = e, _o(Ow, this, Qw).call(this) }, n = this.color; this.addCommands({ cmd: t.bind(this, e), undo: t.bind(this, n), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.INK_COLOR, overwriteIfSameType: !0, keepUndo: !0 }) } function Ww(e) { const t = e => { this.opacity = e, _o(Ow, this, Qw).call(this) }; e /= 100; const n = this.opacity; this.addCommands({ cmd: t.bind(this, e), undo: t.bind(this, n), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: qo.INK_OPACITY, overwriteIfSameType: !0, keepUndo: !0 }) } function Bw() { const { parentRotation: e, parentDimensions: [t, n] } = this; switch (e) { case 90: return [0, n, n, t]; case 180: return [t, n, t, n]; case 270: return [t, 0, n, t]; default: return [0, 0, t, n] } } function Hw() { const { ctx: e, color: t, opacity: n, thickness: r, parentScale: i, scaleFactor: a } = this; e.lineWidth = r * i / a, e.lineCap = "round", e.lineJoin = "round", e.miterLimit = 10, e.strokeStyle = "".concat(t).concat(function (e) { return Math.round(Math.min(255, Math.max(1, 255 * e))).toString(16).padStart(2, "0") }(n)) } function Uw(e, t) { const n = this._uiManager._signal; var r; (this.canvas.addEventListener("contextmenu", Kc, { signal: n }), this.canvas.addEventListener("pointerleave", Mo(Sw, this), { signal: n }), this.canvas.addEventListener("pointermove", Mo(kw, this), { signal: n }), this.canvas.addEventListener("pointerup", Mo(Aw, this), { signal: n }), this.canvas.removeEventListener("pointerdown", Mo(Ew, this)), this.isEditing = !0, Mo(Rw, this)) || (To(Rw, this, !0), _o(Ow, this, ex).call(this), this.thickness || (this.thickness = ho._defaultThickness), this.color || (this.color = ho._defaultColor || Dh._defaultLineColor), null !== (r = this.opacity) && void 0 !== r || (this.opacity = ho._defaultOpacity)); this.currentPath.push([e, t]), To(Pw, this, !1), _o(Ow, this, Hw).call(this), To(Dw, this, (() => { _o(Ow, this, Xw).call(this), Mo(Dw, this) && window.requestAnimationFrame(Mo(Dw, this)) })), window.requestAnimationFrame(Mo(Dw, this)) } function Vw(e, t) { const [n, r] = this.currentPath.at(-1); if (this.currentPath.length > 1 && e === n && t === r) return; const i = this.currentPath; let a = Mo(Mw, this); if (i.push([e, t]), To(Pw, this, !0), i.length <= 2) return a.moveTo(...i[0]), void a.lineTo(e, t); 3 === i.length && (To(Mw, this, a = new Path2D), a.moveTo(...i[0])), _o(Ow, this, Yw).call(this, a, ...i.at(-3), ...i.at(-2), e, t) } function qw() { if (0 === this.currentPath.length) return; const e = this.currentPath.at(-1); Mo(Mw, this).lineTo(...e) } function Gw(e, t) { let n; if (To(Dw, this, null), e = Math.min(Math.max(e, 0), this.canvas.width), t = Math.min(Math.max(t, 0), this.canvas.height), _o(Ow, this, Vw).call(this, e, t), _o(Ow, this, qw).call(this), 1 !== this.currentPath.length) n = _o(Ow, this, Kw).call(this); else { const r = [e, t]; n = [[r, r.slice(), r.slice(), r]] } const r = Mo(Mw, this), i = this.currentPath; this.currentPath = [], To(Mw, this, new Path2D); this.addCommands({ cmd: () => { this.allRawPaths.push(i), this.paths.push(n), this.bezierPath2D.push(r), this._uiManager.rebuild(this) }, undo: () => { this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), 0 === this.paths.length ? this.remove() : (this.canvas || (_o(Ow, this, Jw).call(this), _o(Ow, this, Zw).call(this)), _o(Ow, this, cx).call(this)) }, mustExec: !0 }) } function Xw() { if (!Mo(Pw, this)) return; To(Pw, this, !1); const e = Math.ceil(this.thickness * this.parentScale), t = this.currentPath.slice(-3), n = t.map((e => e[0])), r = t.map((e => e[1])), { ctx: i } = (Math.min(...n), Math.max(...n), Math.min(...r), Math.max(...r), this); i.save(), i.clearRect(0, 0, this.canvas.width, this.canvas.height); for (const a of this.bezierPath2D) i.stroke(a); i.stroke(Mo(Mw, this)), i.restore() } function Yw(e, t, n, r, i, a, s) { const o = (t + r) / 2, l = (n + i) / 2, c = (r + a) / 2, u = (i + s) / 2; e.bezierCurveTo(o + 2 * (r - o) / 3, l + 2 * (i - l) / 3, c + 2 * (r - c) / 3, u + 2 * (i - u) / 3, c, u) } function Kw() { const e = this.currentPath; if (e.length <= 2) return [[e[0], e[0], e.at(-1), e.at(-1)]]; const t = []; let n, [r, i] = e[0]; for (n = 1; n < e.length - 2; n++) { const [a, s] = e[n], [o, l] = e[n + 1], c = (a + o) / 2, u = (s + l) / 2, d = [r + 2 * (a - r) / 3, i + 2 * (s - i) / 3], h = [c + 2 * (a - c) / 3, u + 2 * (s - u) / 3]; t.push([[r, i], d, h, [c, u]]), [r, i] = [c, u] } const [a, s] = e[n], [o, l] = e[n + 1], c = [r + 2 * (a - r) / 3, i + 2 * (s - i) / 3], u = [o + 2 * (a - o) / 3, l + 2 * (s - l) / 3]; return t.push([[r, i], c, u, [o, l]]), t } function Qw() { if (this.isEmpty()) return void _o(Ow, this, nx).call(this); _o(Ow, this, Hw).call(this); const { canvas: e, ctx: t } = this; t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.width, e.height), _o(Ow, this, nx).call(this); for (const n of this.bezierPath2D) t.stroke(n) } function $w(e) { this.canvas.removeEventListener("pointerleave", Mo(Sw, this)), this.canvas.removeEventListener("pointermove", Mo(kw, this)), this.canvas.removeEventListener("pointerup", Mo(Aw, this)), this.canvas.addEventListener("pointerdown", Mo(Ew, this), { signal: this._uiManager._signal }), Mo(Cw, this) && clearTimeout(Mo(Cw, this)), To(Cw, this, setTimeout((() => { To(Cw, this, null), this.canvas.removeEventListener("contextmenu", Kc) }), 10)), _o(Ow, this, Gw).call(this, e.offsetX, e.offsetY), this.addToAnnotationStorage(), this.setInBackground() } function Jw() { this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d") } function Zw() { To(Nw, this, new ResizeObserver((e => { const t = e[0].contentRect; t.width && t.height && this.setDimensions(t.width, t.height) }))), Mo(Nw, this).observe(this.div), this._uiManager._signal.addEventListener("abort", (() => { var e; null === (e = Mo(Nw, this)) || void 0 === e || e.disconnect(), To(Nw, this, null) }), { once: !0 }) } function ex() { if (!Mo(Rw, this)) return; const [e, t] = this.parentDimensions; this.canvas.width = Math.ceil(this.width * e), this.canvas.height = Math.ceil(this.height * t), _o(Ow, this, nx).call(this) } function tx(e, t) { const n = _o(Ow, this, lx).call(this), r = (e - n) / Mo(_w, this), i = (t - n) / Mo(xw, this); this.scaleFactor = Math.min(r, i) } function nx() { const e = _o(Ow, this, lx).call(this) / 2; this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + e, this.translationY * this.scaleFactor + e) } function rx(e) { const t = new Path2D; for (let n = 0, r = e.length; n < r; n++) { const [r, i, a, s] = e[n]; 0 === n && t.moveTo(...r), t.bezierCurveTo(i[0], i[1], a[0], a[1], s[0], s[1]) } return t } function ix(e, t, n) { const [r, i, a, s] = t; switch (n) { case 0: for (let t = 0, n = e.length; t < n; t += 2)e[t] += r, e[t + 1] = s - e[t + 1]; break; case 90: for (let t = 0, n = e.length; t < n; t += 2) { const n = e[t]; e[t] = e[t + 1] + r, e[t + 1] = n + i } break; case 180: for (let t = 0, n = e.length; t < n; t += 2)e[t] = a - e[t], e[t + 1] += i; break; case 270: for (let t = 0, n = e.length; t < n; t += 2) { const n = e[t]; e[t] = a - e[t + 1], e[t + 1] = s - n } break; default: throw new Error("Invalid rotation") }return e } function ax(e, t, n) { const [r, i, a, s] = t; switch (n) { case 0: for (let t = 0, n = e.length; t < n; t += 2)e[t] -= r, e[t + 1] = s - e[t + 1]; break; case 90: for (let t = 0, n = e.length; t < n; t += 2) { const n = e[t]; e[t] = e[t + 1] - i, e[t + 1] = n - r } break; case 180: for (let t = 0, n = e.length; t < n; t += 2)e[t] = a - e[t], e[t + 1] -= i; break; case 270: for (let t = 0, n = e.length; t < n; t += 2) { const n = e[t]; e[t] = s - e[t + 1], e[t + 1] = a - n } break; default: throw new Error("Invalid rotation") }return e } function sx(e, t, n, r) { const i = [], a = this.thickness / 2, s = e * t + a, o = e * n + a; for (const l of this.paths) { const t = [], n = []; for (let r = 0, i = l.length; r < i; r++) { const [a, c, u, d] = l[r]; if (a[0] === d[0] && a[1] === d[1] && 1 === i) { const r = e * a[0] + s, i = e * a[1] + o; t.push(r, i), n.push(r, i); break } const h = e * a[0] + s, f = e * a[1] + o, p = e * c[0] + s, m = e * c[1] + o, g = e * u[0] + s, v = e * u[1] + o, b = e * d[0] + s, y = e * d[1] + o; 0 === r && (t.push(h, f), n.push(h, f)), t.push(p, m, g, v, b, y), n.push(p, m), r === i - 1 && n.push(b, y) } i.push({ bezier: ix.call(ho, t, r, this.rotation), points: ix.call(ho, n, r, this.rotation) }) } return i } function ox() { let e = 1 / 0, t = -1 / 0, n = 1 / 0, r = -1 / 0; for (const i of this.paths) for (const [a, s, o, l] of i) { const i = Kl.bezierBoundingBox(...a, ...s, ...o, ...l); e = Math.min(e, i[0]), n = Math.min(n, i[1]), t = Math.max(t, i[2]), r = Math.max(r, i[3]) } return [e, n, t, r] } function lx() { return Mo(Tw, this) ? Math.ceil(this.thickness * this.parentScale) : 0 } function cx() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (this.isEmpty()) return; if (!Mo(Tw, this)) return void _o(Ow, this, Qw).call(this); const t = _o(Ow, this, ox).call(this), n = _o(Ow, this, lx).call(this); To(_w, this, Math.max(Dh.MIN_SIZE, t[2] - t[0])), To(xw, this, Math.max(Dh.MIN_SIZE, t[3] - t[1])); const r = Math.ceil(n + Mo(_w, this) * this.scaleFactor), i = Math.ceil(n + Mo(xw, this) * this.scaleFactor), [a, s] = this.parentDimensions; this.width = r / a, this.height = i / s, this.setAspectRatio(r, i); const o = this.translationX, l = this.translationY; this.translationX = -t[0], this.translationY = -t[1], _o(Ow, this, ex).call(this), _o(Ow, this, Qw).call(this), To(Lw, this, r), To(Iw, this, i), this.setDims(r, i); const c = e ? n / this.scaleFactor / 2 : 0; this.translate(o - this.translationX - c, l - this.translationY - c) } ho = jw, Eo(jw, "_defaultColor", null), Eo(jw, "_defaultOpacity", 1), Eo(jw, "_defaultThickness", 1), Eo(jw, "_type", "ink"), Eo(jw, "_editorType", Vo.INK); var ux = new WeakMap, dx = new WeakMap, hx = new WeakMap, fx = new WeakMap, px = new WeakMap, mx = new WeakMap, gx = new WeakMap, vx = new WeakMap, bx = new WeakMap, yx = new WeakMap, wx = new WeakMap, xx = new WeakSet; class _x extends Dh { constructor(e) { super({ ...e, name: "stampEditor" }), xo(this, xx), Co(this, ux, null), Co(this, dx, null), Co(this, hx, null), Co(this, fx, null), Co(this, px, null), Co(this, mx, ""), Co(this, gx, null), Co(this, vx, null), Co(this, bx, null), Co(this, yx, !1), Co(this, wx, !1), To(fx, this, e.bitmapUrl), To(px, this, e.bitmapFile) } static initialize(e, t) { Dh.initialize(e, t) } static get supportedTypes() { return Dl(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((e => "image/".concat(e)))) } static get supportedTypesStr() { return Dl(this, "supportedTypesStr", this.supportedTypes.join(",")) } static isHandlingMimeForPasting(e) { return this.supportedTypes.includes(e) } static paste(e, t) { t.pasteEditor(Vo.STAMP, { bitmapFile: e.getAsFile() }) } remove() { var e, t; Mo(dx, this) && (To(ux, this, null), this._uiManager.imageManager.deleteId(Mo(dx, this)), null === (e = Mo(gx, this)) || void 0 === e || e.remove(), To(gx, this, null), null === (t = Mo(vx, this)) || void 0 === t || t.disconnect(), To(vx, this, null), Mo(bx, this) && (clearTimeout(Mo(bx, this)), To(bx, this, null))); super.remove() } rebuild() { this.parent ? (super.rebuild(), null !== this.div && (Mo(dx, this) && null === Mo(gx, this) && _o(xx, this, Ax).call(this), this.isAttachedToDOM || this.parent.add(this))) : Mo(dx, this) && _o(xx, this, Ax).call(this) } onceAdded() { this._isDraggable = !0, this.div.focus() } isEmpty() { return !(Mo(hx, this) || Mo(ux, this) || Mo(fx, this) || Mo(px, this) || Mo(dx, this)) } get isResizable() { return !0 } render() { if (this.div) return this.div; let e, t; if (this.width && (e = this.x, t = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), Mo(ux, this) ? _o(xx, this, Ex).call(this) : _o(xx, this, Ax).call(this), this.width) { const [n, r] = this.parentDimensions; this.setAt(e * n, t * r, this.width * n, this.height * r) } return this.div } getImageForAltText() { return Mo(gx, this) } static deserialize(e, t, n) { if (e instanceof Kv) return null; const r = super.deserialize(e, t, n), { rect: i, bitmapUrl: a, bitmapId: s, isSvg: o, accessibilityData: l } = e; s && n.imageManager.isValidId(s) ? To(dx, r, s) : To(fx, r, a), To(yx, r, o); const [c, u] = r.pageDimensions; return r.width = (i[2] - i[0]) / c, r.height = (i[3] - i[1]) / u, l && (r.altTextData = l), r } serialize() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (this.isEmpty()) return null; const n = { annotationType: Vo.STAMP, bitmapId: Mo(dx, this), pageIndex: this.pageIndex, rect: this.getRect(0, 0), rotation: this.rotation, isSvg: Mo(yx, this), structTreeParentId: this._structTreeParentId }; if (e) return n.bitmapUrl = _o(xx, this, Px).call(this, !0), n.accessibilityData = this.altTextData, n; const { decorative: r, altText: i } = this.altTextData; if (!r && i && (n.accessibilityData = { type: "Figure", alt: i }), null === t) return n; t.stamps || (t.stamps = new Map); const a = Mo(yx, this) ? (n.rect[2] - n.rect[0]) * (n.rect[3] - n.rect[1]) : null; if (t.stamps.has(Mo(dx, this))) { if (Mo(yx, this)) { const e = t.stamps.get(Mo(dx, this)); a > e.area && (e.area = a, e.serialized.bitmap.close(), e.serialized.bitmap = _o(xx, this, Px).call(this, !1)) } } else t.stamps.set(Mo(dx, this), { area: a, serialized: n }), n.bitmap = _o(xx, this, Px).call(this, !1); return n } } function kx(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; e ? (To(ux, this, e.bitmap), t || (To(dx, this, e.id), To(yx, this, e.isSvg)), e.file && To(mx, this, e.file.name), _o(xx, this, Ex).call(this)) : this.remove() } function Sx() { To(hx, this, null), this._uiManager.enableWaiting(!1), Mo(gx, this) && this.div.focus() } function Ax() { if (Mo(dx, this)) return this._uiManager.enableWaiting(!0), void this._uiManager.imageManager.getFromId(Mo(dx, this)).then((e => _o(xx, this, kx).call(this, e, !0))).finally((() => _o(xx, this, Sx).call(this))); if (Mo(fx, this)) { const e = Mo(fx, this); return To(fx, this, null), this._uiManager.enableWaiting(!0), void To(hx, this, this._uiManager.imageManager.getFromUrl(e).then((e => _o(xx, this, kx).call(this, e))).finally((() => _o(xx, this, Sx).call(this)))) } if (Mo(px, this)) { const e = Mo(px, this); return To(px, this, null), this._uiManager.enableWaiting(!0), void To(hx, this, this._uiManager.imageManager.getFromFile(e).then((e => _o(xx, this, kx).call(this, e))).finally((() => _o(xx, this, Sx).call(this)))) } const e = document.createElement("input"); e.type = "file", e.accept = fo.supportedTypesStr; const t = this._uiManager._signal; To(hx, this, new Promise((n => { e.addEventListener("change", (async () => { if (e.files && 0 !== e.files.length) { this._uiManager.enableWaiting(!0); const t = await this._uiManager.imageManager.getFromFile(e.files[0]); _o(xx, this, kx).call(this, t) } else this.remove(); n() }), { signal: t }), e.addEventListener("cancel", (() => { this.remove(), n() }), { signal: t }) })).finally((() => _o(xx, this, Sx).call(this)))), e.click() } function Ex() { const { div: e } = this; let { width: t, height: n } = Mo(ux, this); const [r, i] = this.pageDimensions, a = .75; if (this.width) t = this.width * r, n = this.height * i; else if (t > a * r || n > a * i) { const e = Math.min(a * r / t, a * i / n); t *= e, n *= e } const [s, o] = this.parentDimensions; this.setDims(t * s / r, n * o / i), this._uiManager.enableWaiting(!1); const l = To(gx, this, document.createElement("canvas")); e.append(l), e.hidden = !1, _o(xx, this, Tx).call(this, t, n), _o(xx, this, Rx).call(this), Mo(wx, this) || (this.parent.addUndoableEditor(this), To(wx, this, !0)), this._reportTelemetry({ action: "inserted_image" }), Mo(mx, this) && l.setAttribute("aria-label", Mo(mx, this)) } function Cx(e, t) { var n; const [r, i] = this.parentDimensions; this.width = e / r, this.height = t / i, this.setDims(e, t), null !== (n = this._initialOptions) && void 0 !== n && n.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, null !== Mo(bx, this) && clearTimeout(Mo(bx, this)); To(bx, this, setTimeout((() => { To(bx, this, null), _o(xx, this, Tx).call(this, e, t) }), 200)) } function Mx(e, t) { const { width: n, height: r } = Mo(ux, this); let i = n, a = r, s = Mo(ux, this); for (; i > 2 * e || a > 2 * t;) { const n = i, r = a; i > 2 * e && (i = i >= 16384 ? Math.floor(i / 2) - 1 : Math.ceil(i / 2)), a > 2 * t && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2)); const o = new OffscreenCanvas(i, a); o.getContext("2d").drawImage(s, 0, 0, n, r, 0, 0, i, a), s = o.transferToImageBitmap() } return s } function Tx(e, t) { e = Math.ceil(e), t = Math.ceil(t); const n = Mo(gx, this); if (!n || n.width === e && n.height === t) return; n.width = e, n.height = t; const r = Mo(yx, this) ? Mo(ux, this) : _o(xx, this, Mx).call(this, e, t); if (this._uiManager.hasMLManager && !this.hasAltText()) { const n = new OffscreenCanvas(e, t).getContext("2d"); n.drawImage(r, 0, 0, r.width, r.height, 0, 0, e, t), this._uiManager.mlGuess({ service: "image-to-text", request: { data: n.getImageData(0, 0, e, t).data, width: e, height: t, channels: 4 } }).then((e => { const t = (null === e || void 0 === e ? void 0 : e.output) || ""; this.parent && t && !this.hasAltText() && (this.altTextData = { altText: t, decorative: !1 }) })) } const i = n.getContext("2d"); i.filter = this._uiManager.hcmFilter, i.drawImage(r, 0, 0, r.width, r.height, 0, 0, e, t) } function Px(e) { if (e) { if (Mo(yx, this)) { const e = this._uiManager.imageManager.getSvgUrl(Mo(dx, this)); if (e) return e } const e = document.createElement("canvas"); ({ width: e.width, height: e.height } = Mo(ux, this)); return e.getContext("2d").drawImage(Mo(ux, this), 0, 0), e.toDataURL() } if (Mo(yx, this)) { const [e, t] = this.pageDimensions, n = Math.round(this.width * e * bc.PDF_TO_CSS_UNITS), r = Math.round(this.height * t * bc.PDF_TO_CSS_UNITS), i = new OffscreenCanvas(n, r); return i.getContext("2d").drawImage(Mo(ux, this), 0, 0, Mo(ux, this).width, Mo(ux, this).height, 0, 0, n, r), i.transferToImageBitmap() } return structuredClone(Mo(ux, this)) } function Rx() { this._uiManager._signal && (To(vx, this, new ResizeObserver((e => { const t = e[0].contentRect; t.width && t.height && _o(xx, this, Cx).call(this, t.width, t.height) }))), Mo(vx, this).observe(this.div), this._uiManager._signal.addEventListener("abort", (() => { var e; null === (e = Mo(vx, this)) || void 0 === e || e.disconnect(), To(vx, this, null) }), { once: !0 })) } fo = _x, Eo(_x, "_type", "stamp"), Eo(_x, "_editorType", Vo.STAMP); var Nx = new WeakMap, Lx = new WeakMap, Ix = new WeakMap, Dx = new WeakMap, Ox = new WeakMap, jx = new WeakMap, Fx = new WeakMap, zx = new WeakMap, Wx = new WeakMap, Bx = new WeakMap, Hx = new WeakMap, Ux = new WeakMap, Vx = new WeakMap, qx = new WeakSet; class Gx { constructor(e) { let { uiManager: t, pageIndex: n, div: r, accessibilityManager: i, annotationLayer: a, drawLayer: s, textLayer: o, viewport: l, l10n: c } = e; xo(this, qx), Co(this, Nx, void 0), Co(this, Lx, !1), Co(this, Ix, null), Co(this, Dx, null), Co(this, Ox, null), Co(this, jx, null), Co(this, Fx, null), Co(this, zx, new Map), Co(this, Wx, !1), Co(this, Bx, !1), Co(this, Hx, !1), Co(this, Ux, null), Co(this, Vx, void 0); const u = [...Jx._.values()]; if (!Gx._initialized) { Gx._initialized = !0; for (const e of u) e.initialize(c, t) } t.registerEditorTypes(u), To(Vx, this, t), this.pageIndex = n, this.div = r, To(Nx, this, i), To(Ix, this, a), this.viewport = l, To(Ux, this, o), this.drawLayer = s, Mo(Vx, this).addLayer(this) } get isEmpty() { return 0 === Mo(zx, this).size } get isInvisible() { return this.isEmpty && Mo(Vx, this).getMode() === Vo.NONE } updateToolbar(e) { Mo(Vx, this).updateToolbar(e) } updateMode() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mo(Vx, this).getMode(); switch (_o(qx, this, $x).call(this), e) { case Vo.NONE: return this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), void this.disableClick(); case Vo.INK: this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick(); break; case Vo.HIGHLIGHT: this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick(); break; default: this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick() }this.toggleAnnotationLayerPointerEvents(!1); const { classList: t } = this.div; for (const n of Jx._.values()) t.toggle("".concat(n._type, "Editing"), e === n._editorType); this.div.hidden = !1 } hasTextLayer(e) { var t; return e === (null === (t = Mo(Ux, this)) || void 0 === t ? void 0 : t.div) } addInkEditorIfNeeded(e) { if (Mo(Vx, this).getMode() !== Vo.INK) return; if (!e) for (const t of Mo(zx, this).values()) if (t.isEmpty()) return void t.setInBackground(); this.createAndAddNewEditor({ offsetX: 0, offsetY: 0 }, !1).setInBackground() } setEditingState(e) { Mo(Vx, this).setEditingState(e) } addCommands(e) { Mo(Vx, this).addCommands(e) } togglePointerEvents() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.div.classList.toggle("disabled", !e) } toggleAnnotationLayerPointerEvents() { var e; let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; null === (e = Mo(Ix, this)) || void 0 === e || e.div.classList.toggle("disabled", !t) } enable() { this.div.tabIndex = 0, this.togglePointerEvents(!0); const e = new Set; for (const n of Mo(zx, this).values()) n.enableEditing(), n.show(!0), n.annotationElementId && (Mo(Vx, this).removeChangedExistingAnnotation(n), e.add(n.annotationElementId)); if (!Mo(Ix, this)) return; const t = Mo(Ix, this).getEditableAnnotations(); for (const n of t) { if (n.hide(), Mo(Vx, this).isDeletedAnnotationElement(n.data.id)) continue; if (e.has(n.data.id)) continue; const t = this.deserialize(n); t && (this.addOrRebuild(t), t.enableEditing()) } } disable() { To(Hx, this, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1); const e = new Map, t = new Map; for (const i of Mo(zx, this).values()) { var n; i.disableEditing(), i.annotationElementId && (null === i.serialize() ? (t.set(i.annotationElementId, i), null === (n = this.getEditableAnnotation(i.annotationElementId)) || void 0 === n || n.show(), i.remove()) : e.set(i.annotationElementId, i)) } if (Mo(Ix, this)) { const n = Mo(Ix, this).getEditableAnnotations(); for (const r of n) { const { id: n } = r.data; if (Mo(Vx, this).isDeletedAnnotationElement(n)) continue; let i = t.get(n); i ? (i.resetAnnotationElement(r), i.show(!1), r.show()) : (i = e.get(n), i && (Mo(Vx, this).addChangedExistingAnnotation(i), i.renderAnnotationElement(r), i.show(!1)), r.show()) } } _o(qx, this, $x).call(this), this.isEmpty && (this.div.hidden = !0); const { classList: r } = this.div; for (const i of Jx._.values()) r.remove("".concat(i._type, "Editing")); this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), To(Hx, this, !1) } getEditableAnnotation(e) { var t; return (null === (t = Mo(Ix, this)) || void 0 === t ? void 0 : t.getEditableAnnotation(e)) || null } setActiveEditor(e) { Mo(Vx, this).getActive() !== e && Mo(Vx, this).setActiveEditor(e) } enableTextSelection() { var e; this.div.tabIndex = -1, null !== (e = Mo(Ux, this)) && void 0 !== e && e.div && !Mo(jx, this) && (To(jx, this, _o(qx, this, Xx).bind(this)), Mo(Ux, this).div.addEventListener("pointerdown", Mo(jx, this), { signal: Mo(Vx, this)._signal }), Mo(Ux, this).div.classList.add("highlighting")) } disableTextSelection() { var e; this.div.tabIndex = 0, null !== (e = Mo(Ux, this)) && void 0 !== e && e.div && Mo(jx, this) && (Mo(Ux, this).div.removeEventListener("pointerdown", Mo(jx, this)), To(jx, this, null), Mo(Ux, this).div.classList.remove("highlighting")) } enableClick() { if (Mo(Ox, this)) return; const e = Mo(Vx, this)._signal; To(Ox, this, this.pointerdown.bind(this)), To(Dx, this, this.pointerup.bind(this)), this.div.addEventListener("pointerdown", Mo(Ox, this), { signal: e }), this.div.addEventListener("pointerup", Mo(Dx, this), { signal: e }) } disableClick() { Mo(Ox, this) && (this.div.removeEventListener("pointerdown", Mo(Ox, this)), this.div.removeEventListener("pointerup", Mo(Dx, this)), To(Ox, this, null), To(Dx, this, null)) } attach(e) { Mo(zx, this).set(e.id, e); const { annotationElementId: t } = e; t && Mo(Vx, this).isDeletedAnnotationElement(t) && Mo(Vx, this).removeDeletedAnnotationElement(e) } detach(e) { var t; Mo(zx, this).delete(e.id), null === (t = Mo(Nx, this)) || void 0 === t || t.removePointerInTextLayer(e.contentDiv), !Mo(Hx, this) && e.annotationElementId && Mo(Vx, this).addDeletedAnnotationElement(e) } remove(e) { this.detach(e), Mo(Vx, this).removeEditor(e), e.div.remove(), e.isAttachedToDOM = !1, Mo(Bx, this) || this.addInkEditorIfNeeded(!1) } changeParent(e) { var t; e.parent !== this && (e.parent && e.annotationElementId && (Mo(Vx, this).addDeletedAnnotationElement(e.annotationElementId), Dh.deleteAnnotationElement(e), e.annotationElementId = null), this.attach(e), null === (t = e.parent) || void 0 === t || t.detach(e), e.setParent(this), e.div && e.isAttachedToDOM && (e.div.remove(), this.div.append(e.div))) } add(e) { if (e.parent !== this || !e.isAttachedToDOM) { if (this.changeParent(e), Mo(Vx, this).addEditor(e), this.attach(e), !e.isAttachedToDOM) { const t = e.render(); this.div.append(t), e.isAttachedToDOM = !0 } e.fixAndSetPosition(), e.onceAdded(), Mo(Vx, this).addToAnnotationStorage(e), e._reportTelemetry(e.telemetryInitialData) } } moveEditorInDOM(e) { var t; if (!e.isAttachedToDOM) return; const { activeElement: n } = document; e.div.contains(n) && !Mo(Fx, this) && (e._focusEventsAllowed = !1, To(Fx, this, setTimeout((() => { To(Fx, this, null), e.div.contains(document.activeElement) ? e._focusEventsAllowed = !0 : (e.div.addEventListener("focusin", (() => { e._focusEventsAllowed = !0 }), { once: !0, signal: Mo(Vx, this)._signal }), n.focus()) }), 0))), e._structTreeParentId = null === (t = Mo(Nx, this)) || void 0 === t ? void 0 : t.moveElementInDOM(this.div, e.div, e.contentDiv, !0) } addOrRebuild(e) { e.needsToBeRebuilt() ? (e.parent || (e.parent = this), e.rebuild(), e.show()) : this.add(e) } addUndoableEditor(e) { this.addCommands({ cmd: () => e._uiManager.rebuild(e), undo: () => { e.remove() }, mustExec: !1 }) } getNextId() { return Mo(Vx, this).getId() } get _signal() { return Mo(Vx, this)._signal } canCreateNewEmptyEditor() { var e; return null === (e = ko(qx, this, Yx)) || void 0 === e ? void 0 : e.canCreateNewEmptyEditor() } pasteEditor(e, t) { Mo(Vx, this).updateToolbar(e), Mo(Vx, this).updateMode(e); const { offsetX: n, offsetY: r } = _o(qx, this, Qx).call(this), i = this.getNextId(), a = _o(qx, this, Kx).call(this, { parent: this, id: i, x: n, y: r, uiManager: Mo(Vx, this), isCentered: !0, ...t }); a && this.add(a) } deserialize(e) { var t, n; return (null === (t = Jx._.get(null !== (n = e.annotationType) && void 0 !== n ? n : e.annotationEditorType)) || void 0 === t ? void 0 : t.deserialize(e, this, Mo(Vx, this))) || null } createAndAddNewEditor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = this.getNextId(), i = _o(qx, this, Kx).call(this, { parent: this, id: r, x: e.offsetX, y: e.offsetY, uiManager: Mo(Vx, this), isCentered: t, ...n }); return i && this.add(i), i } addNewEditor() { this.createAndAddNewEditor(_o(qx, this, Qx).call(this), !0) } setSelected(e) { Mo(Vx, this).setSelected(e) } toggleSelected(e) { Mo(Vx, this).toggleSelected(e) } isSelected(e) { return Mo(Vx, this).isSelected(e) } unselect(e) { Mo(Vx, this).unselect(e) } pointerup(e) { const { isMac: t } = Xl.platform; 0 !== e.button || e.ctrlKey && t || e.target === this.div && Mo(Wx, this) && (To(Wx, this, !1), Mo(Lx, this) ? Mo(Vx, this).getMode() !== Vo.STAMP ? this.createAndAddNewEditor(e, !1) : Mo(Vx, this).unselectAll() : To(Lx, this, !0)) } pointerdown(e) { if (Mo(Vx, this).getMode() === Vo.HIGHLIGHT && this.enableTextSelection(), Mo(Wx, this)) return void To(Wx, this, !1); const { isMac: t } = Xl.platform; if (0 !== e.button || e.ctrlKey && t) return; if (e.target !== this.div) return; To(Wx, this, !0); const n = Mo(Vx, this).getActive(); To(Lx, this, !n || n.isEmpty()) } findNewParent(e, t, n) { const r = Mo(Vx, this).findParent(t, n); return null !== r && r !== this && (r.changeParent(e), !0) } destroy() { var e; (null === (e = Mo(Vx, this).getActive()) || void 0 === e ? void 0 : e.parent) === this && (Mo(Vx, this).commitOrRemove(), Mo(Vx, this).setActiveEditor(null)), Mo(Fx, this) && (clearTimeout(Mo(Fx, this)), To(Fx, this, null)); for (const n of Mo(zx, this).values()) { var t; null === (t = Mo(Nx, this)) || void 0 === t || t.removePointerInTextLayer(n.contentDiv), n.setParent(null), n.isAttachedToDOM = !1, n.div.remove() } this.div = null, Mo(zx, this).clear(), Mo(Vx, this).removeLayer(this) } render(e) { let { viewport: t } = e; this.viewport = t, ru(this.div, t); for (const n of Mo(Vx, this).getEditors(this.pageIndex)) this.add(n), n.rebuild(); this.updateMode() } update(e) { let { viewport: t } = e; Mo(Vx, this).commitOrRemove(), _o(qx, this, $x).call(this); const n = this.viewport.rotation, r = t.rotation; if (this.viewport = t, ru(this.div, { rotation: r }), n !== r) for (const i of Mo(zx, this).values()) i.rotate(r); this.addInkEditorIfNeeded(!1) } get pageDimensions() { const { pageWidth: e, pageHeight: t } = this.viewport.rawDims; return [e, t] } get scale() { return Mo(Vx, this).viewParameters.realScale } } function Xx(e) { if (Mo(Vx, this).unselectAll(), e.target === Mo(Ux, this).div) { const { isMac: t } = Xl.platform; if (0 !== e.button || e.ctrlKey && t) return; Mo(Vx, this).showAllEditors("highlight", !0, !0), Mo(Ux, this).div.classList.add("free"), aw.startHighlighting(this, "ltr" === Mo(Vx, this).direction, e), Mo(Ux, this).div.addEventListener("pointerup", (() => { Mo(Ux, this).div.classList.remove("free") }), { once: !0, signal: Mo(Vx, this)._signal }), e.preventDefault() } } function Yx(e) { return Jx._.get(Mo(Vx, e).getMode()) } function Kx(e) { const t = ko(qx, this, Yx); return t ? new t.prototype.constructor(e) : null } function Qx() { const { x: e, y: t, width: n, height: r } = this.div.getBoundingClientRect(), i = Math.max(0, e), a = Math.max(0, t), s = (i + Math.min(window.innerWidth, e + n)) / 2 - e, o = (a + Math.min(window.innerHeight, t + r)) / 2 - t, [l, c] = this.viewport.rotation % 180 === 0 ? [s, o] : [o, s]; return { offsetX: l, offsetY: c } } function $x() { To(Bx, this, !0); for (const e of Mo(zx, this).values()) e.isEmpty() && e.remove(); To(Bx, this, !1) } Eo(Gx, "_initialized", !1); var Jx = { _: new Map([yb, jw, _x, aw].map((e => [e._editorType, e]))) }, Zx = new WeakMap, e_ = new WeakMap, t_ = new WeakMap, n_ = new WeakMap, r_ = new WeakSet; class i_ { constructor(e) { let { pageIndex: t } = e; xo(this, r_), Co(this, Zx, null), Co(this, e_, 0), Co(this, t_, new Map), Co(this, n_, new Map), this.pageIndex = t } setParent(e) { if (Mo(Zx, this)) { if (Mo(Zx, this) !== e) { if (Mo(t_, this).size > 0) for (const t of Mo(t_, this).values()) t.remove(), e.append(t); To(Zx, this, e) } } else To(Zx, this, e) } static get _svgFactory() { return Dl(this, "_svgFactory", new Wc) } highlight(e, t, n) { var r, i; let a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const s = (To(e_, this, (r = Mo(e_, this), i = r++, r)), i), o = _o(r_, this, s_).call(this, e.box); o.classList.add("highlight"), e.free && o.classList.add("free"); const l = i_._svgFactory.createElement("defs"); o.append(l); const c = i_._svgFactory.createElement("path"); l.append(c); const u = "path_p".concat(this.pageIndex, "_").concat(s); c.setAttribute("id", u), c.setAttribute("d", e.toSVGPath()), a && Mo(n_, this).set(s, c); const d = _o(r_, this, o_).call(this, l, u), h = i_._svgFactory.createElement("use"); return o.append(h), o.setAttribute("fill", t), o.setAttribute("fill-opacity", n), h.setAttribute("href", "#".concat(u)), Mo(t_, this).set(s, o), { id: s, clipPathId: "url(#".concat(d, ")") } } highlightOutline(e) { var t, n; const r = (To(e_, this, (t = Mo(e_, this), n = t++, t)), n), i = _o(r_, this, s_).call(this, e.box); i.classList.add("highlightOutline"); const a = i_._svgFactory.createElement("defs"); i.append(a); const s = i_._svgFactory.createElement("path"); a.append(s); const o = "path_p".concat(this.pageIndex, "_").concat(r); let l; if (s.setAttribute("id", o), s.setAttribute("d", e.toSVGPath()), s.setAttribute("vector-effect", "non-scaling-stroke"), e.free) { i.classList.add("free"); const e = i_._svgFactory.createElement("mask"); a.append(e), l = "mask_p".concat(this.pageIndex, "_").concat(r), e.setAttribute("id", l), e.setAttribute("maskUnits", "objectBoundingBox"); const t = i_._svgFactory.createElement("rect"); e.append(t), t.setAttribute("width", "1"), t.setAttribute("height", "1"), t.setAttribute("fill", "white"); const n = i_._svgFactory.createElement("use"); e.append(n), n.setAttribute("href", "#".concat(o)), n.setAttribute("stroke", "none"), n.setAttribute("fill", "black"), n.setAttribute("fill-rule", "nonzero"), n.classList.add("mask") } const c = i_._svgFactory.createElement("use"); i.append(c), c.setAttribute("href", "#".concat(o)), l && c.setAttribute("mask", "url(#".concat(l, ")")); const u = c.cloneNode(); return i.append(u), c.classList.add("mainOutline"), u.classList.add("secondaryOutline"), Mo(t_, this).set(r, i), r } finalizeLine(e, t) { const n = Mo(n_, this).get(e); Mo(n_, this).delete(e), this.updateBox(e, t.box), n.setAttribute("d", t.toSVGPath()) } updateLine(e, t) { Mo(t_, this).get(e).firstChild.firstChild.setAttribute("d", t.toSVGPath()) } removeFreeHighlight(e) { this.remove(e), Mo(n_, this).delete(e) } updatePath(e, t) { Mo(n_, this).get(e).setAttribute("d", t.toSVGPath()) } updateBox(e, t) { a_.call(i_, Mo(t_, this).get(e), t) } show(e, t) { Mo(t_, this).get(e).classList.toggle("hidden", !t) } rotate(e, t) { Mo(t_, this).get(e).setAttribute("data-main-rotation", t) } changeColor(e, t) { Mo(t_, this).get(e).setAttribute("fill", t) } changeOpacity(e, t) { Mo(t_, this).get(e).setAttribute("fill-opacity", t) } addClass(e, t) { Mo(t_, this).get(e).classList.add(t) } removeClass(e, t) { Mo(t_, this).get(e).classList.remove(t) } remove(e) { null !== Mo(Zx, this) && (Mo(t_, this).get(e).remove(), Mo(t_, this).delete(e)) } destroy() { To(Zx, this, null); for (const e of Mo(t_, this).values()) e.remove(); Mo(t_, this).clear() } } function a_(e) { let { x: t = 0, y: n = 0, width: r = 1, height: i = 1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const { style: a } = e; a.top = "".concat(100 * n, "%"), a.left = "".concat(100 * t, "%"), a.width = "".concat(100 * r, "%"), a.height = "".concat(100 * i, "%") } function s_(e) { const t = po._svgFactory.create(1, 1, !0); return Mo(Zx, this).append(t), t.setAttribute("aria-hidden", !0), a_.call(po, t, e), t } function o_(e, t) { const n = po._svgFactory.createElement("clipPath"); e.append(n); const r = "clip_".concat(t); n.setAttribute("id", r), n.setAttribute("clipPathUnits", "objectBoundingBox"); const i = po._svgFactory.createElement("use"); return n.append(i), i.setAttribute("href", "#".concat(t)), i.classList.add("clip"), r } po = i_; var l_ = Ro.AnnotationLayer, c_ = Ro.AnnotationMode, u_ = Ro.GlobalWorkerOptions, d_ = Ro.PDFDataRangeTransport, h_ = Ro.TextLayer, f_ = Ro.getDocument, p_ = Ro.version; const m_ = (0, t.createContext)(null); function g_(e) { let { children: t, type: n } = e; return (0, v.jsx)("div", { className: "react-pdf__message react-pdf__message--".concat(n), children: t }) } class v_ { constructor() { this.externalLinkEnabled = !0, this.externalLinkRel = void 0, this.externalLinkTarget = void 0, this.isInPresentationMode = !1, this.pdfDocument = void 0, this.pdfViewer = void 0 } setDocument(e) { this.pdfDocument = e } setViewer(e) { this.pdfViewer = e } setExternalLinkRel(e) { this.externalLinkRel = e } setExternalLinkTarget(e) { this.externalLinkTarget = e } setHistory() { } get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0 } get page() { return to(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber || 0 } set page(e) { to(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber = e } get rotation() { return 0 } set rotation(e) { } goToDestination(e) { return new Promise((t => { to(this.pdfDocument, "PDF document not loaded."), to(e, "Destination is not specified."), "string" === typeof e ? this.pdfDocument.getDestination(e).then(t) : Array.isArray(e) ? t(e) : e.then(t) })).then((e => { to(Array.isArray(e), '"'.concat(e, '" is not a valid destination array.')); const t = e[0]; new Promise((e => { to(this.pdfDocument, "PDF document not loaded."), t instanceof Object ? this.pdfDocument.getPageIndex(t).then((t => { e(t) })).catch((() => { to(!1, '"'.concat(t, '" is not a valid page reference.')) })) : "number" === typeof t ? e(t) : to(!1, '"'.concat(t, '" is not a valid destination reference.')) })).then((t => { const n = t + 1; to(this.pdfViewer, "PDF viewer is not initialized."), to(n >= 1 && n <= this.pagesCount, '"'.concat(n, '" is not a valid page number.')), this.pdfViewer.scrollPageIntoView({ dest: e, pageIndex: t, pageNumber: n }) })) })) } navigateTo(e) { this.goToDestination(e) } goToPage(e) { const t = e - 1; to(this.pdfViewer, "PDF viewer is not initialized."), to(e >= 1 && e <= this.pagesCount, '"'.concat(e, '" is not a valid page number.')), this.pdfViewer.scrollPageIntoView({ pageIndex: t, pageNumber: e }) } addLinkAttributes(e, t, n) { e.href = t, e.rel = this.externalLinkRel || "noopener noreferrer nofollow", e.target = n ? "_blank" : this.externalLinkTarget || "" } getDestinationHash() { return "#" } getAnchorUrl() { return "#" } setHash() { } executeNamedAction() { } cachePageRef() { } isPageVisible() { return !0 } isPageCached() { return !0 } executeSetOCGState() { } } const b_ = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }, y_ = "undefined" !== typeof document, w_ = y_ && "file:" === window.location.protocol; function x_(e) { return function (e) { return "undefined" !== typeof e }(e) && null !== e } function __(e) { return function (e) { return "string" === typeof e }(e) && /^data:/.test(e) } function k_(e) { to(__(e), "Invalid data URI."); const [t = "", n = ""] = e.split(","); return -1 !== t.split(";").indexOf("base64") ? atob(n) : unescape(n) } function S_() { return y_ && window.devicePixelRatio || 1 } const A_ = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes."; function E_() { mo(!w_, "Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ".concat(A_)) } function C_(e) { (null === e || void 0 === e ? void 0 : e.cancel) && e.cancel() } function M_(e, t) { return Object.defineProperty(e, "width", { get() { return this.view[2] * t }, configurable: !0 }), Object.defineProperty(e, "height", { get() { return this.view[3] * t }, configurable: !0 }), Object.defineProperty(e, "originalWidth", { get() { return this.view[2] }, configurable: !0 }), Object.defineProperty(e, "originalHeight", { get() { return this.view[3] }, configurable: !0 }), e } function T_(e, t) { switch (t.type) { case "RESOLVE": return { value: t.value, error: void 0 }; case "REJECT": return { value: !1, error: t.error }; case "RESET": return { value: void 0, error: void 0 }; default: return e } } function P_() { return (0, t.useReducer)(T_, { value: void 0, error: void 0 }) } var R_ = function (e, t, n, r) { return new (n || (n = Promise))((function (i, a) { function s(e) { try { l(r.next(e)) } catch ($A) { a($A) } } function o(e) { try { l(r.throw(e)) } catch ($A) { a($A) } } function l(e) { var t; e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, o) } l((r = r.apply(e, t || [])).next()) })) }, N_ = function (e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" === typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n }; const { Tm: L_ } = e, I_ = (e, t) => { switch (t) { case b_.NEED_PASSWORD: e(prompt("Enter the password to open this PDF file.")); break; case b_.INCORRECT_PASSWORD: e(prompt("Invalid password. Please try again.")); break } }; function D_(e) { return "object" === typeof e && null !== e && ("data" in e || "range" in e || "url" in e) } const O_ = (0, t.forwardRef)((function (e, n) { var { children: r, className: i, error: a = "Failed to load PDF file.", externalLinkRel: s, externalLinkTarget: o, file: l, inputRef: c, imageResourcesPath: u, loading: d = "Loading PDF\u2026", noData: h = "No PDF file specified.", onItemClick: f, onLoadError: p, onLoadProgress: m, onLoadSuccess: g, onPassword: b = I_, onSourceError: y, onSourceSuccess: w, options: x, renderMode: _, rotate: k } = e, S = N_(e, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]); const [A, E] = P_(), { value: C, error: M } = A, [T, P] = P_(), { value: R, error: N } = T, L = (0, t.useRef)(new v_), I = (0, t.useRef)([]), D = (0, t.useRef)(void 0), O = (0, t.useRef)(void 0); l && l !== D.current && D_(l) && (mo(!bo(l, D.current), 'File prop passed to <Document /> changed, but it\'s equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.'), D.current = l), x && x !== O.current && (mo(!bo(x, O.current), 'Options prop passed to <Document /> changed, but it\'s equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.'), O.current = x); const j = (0, t.useRef)({ scrollPageIntoView: e => { const { dest: t, pageNumber: n, pageIndex: r = n - 1 } = e; if (f) return void f({ dest: t, pageIndex: r, pageNumber: n }); const i = I.current[r]; i ? i.scrollIntoView() : mo(!1, "An internal link leading to page ".concat(n, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.")) } }); (0, t.useImperativeHandle)(n, (() => ({ linkService: L, pages: I, viewer: j })), []), (0, t.useEffect)((function () { E({ type: "RESET" }) }), [l, E]); const F = (0, t.useCallback)((() => R_(this, void 0, void 0, (function* () { if (!l) return null; if ("string" === typeof l) { if (__(l)) { return { data: k_(l) } } return E_(), { url: l } } if (l instanceof L_) return { range: l }; if (l instanceof ArrayBuffer) return { data: l }; if (y_ && function (e) { return to(y_, "isBlob can only be used in a browser environment"), e instanceof Blob }(l)) { const e = yield function (e) { return new Promise(((t, n) => { const r = new FileReader; r.onload = () => { if (!r.result) return n(new Error("Error while reading a file.")); t(r.result) }, r.onerror = e => { if (!e.target) return n(new Error("Error while reading a file.")); const { error: t } = e.target; if (!t) return n(new Error("Error while reading a file.")); switch (t.code) { case t.NOT_FOUND_ERR: return n(new Error("Error while reading a file: File not found.")); case t.SECURITY_ERR: return n(new Error("Error while reading a file: Security error.")); case t.ABORT_ERR: return n(new Error("Error while reading a file: Aborted.")); default: return n(new Error("Error while reading a file.")) } }, r.readAsArrayBuffer(e) })) }(l); return { data: e } } if (to("object" === typeof l, "Invalid parameter in file, need either Uint8Array, string or a parameter object"), to(D_(l), "Invalid parameter object: need either .data, .range or .url"), "url" in l && "string" === typeof l.url) { if (__(l.url)) { const { url: e } = l, t = N_(l, ["url"]), n = k_(e); return Object.assign({ data: n }, t) } E_() } return l }))), [l]); (0, t.useEffect)((() => { const e = Js(F()); return e.promise.then((e => { E({ type: "RESOLVE", value: e }) })).catch((e => { E({ type: "REJECT", error: e }) })), () => { C_(e) } }), [F, E]), (0, t.useEffect)((() => { "undefined" !== typeof C && (!1 !== C ? w && w() : M && (mo(!1, M.toString()), y && y(M))) }), [C]), (0, t.useEffect)((function () { P({ type: "RESET" }) }), [P, C]), (0, t.useEffect)((function () { if (!C) return; const e = Object.assign(Object.assign({}, C), x), t = f_(e); m && (t.onProgress = m), b && (t.onPassword = b); const n = t; return n.promise.then((e => { P({ type: "RESOLVE", value: e }) })).catch((e => { n.destroyed || P({ type: "REJECT", error: e }) })), () => { n.destroy() } }), [x, P, C]), (0, t.useEffect)((() => { "undefined" !== typeof R && (!1 !== R ? R && (g && g(R), I.current = new Array(R.numPages), L.current.setDocument(R)) : N && (mo(!1, N.toString()), p && p(N))) }), [R]), (0, t.useEffect)((function () { L.current.setViewer(j.current), L.current.setExternalLinkRel(s), L.current.setExternalLinkTarget(o) }), [s, o]); const z = (0, t.useCallback)(((e, t) => { I.current[e] = t }), []), W = (0, t.useCallback)((e => { delete I.current[e] }), []), B = (0, t.useMemo)((() => ({ imageResourcesPath: u, linkService: L.current, onItemClick: f, pdf: R, registerPage: z, renderMode: _, rotate: k, unregisterPage: W })), [u, f, R, z, _, k, W]), H = (0, t.useMemo)((() => $s(S, (() => R))), [S, R]); return (0, v.jsx)("div", Object.assign({ className: te("react-pdf__Document", i), ref: c, style: { "--scale-factor": "1" } }, H, { children: l ? void 0 === R || null === R ? (0, v.jsx)(g_, { type: "loading", children: "function" === typeof d ? d() : d }) : !1 === R ? (0, v.jsx)(g_, { type: "error", children: "function" === typeof a ? a() : a }) : (0, v.jsx)(m_.Provider, { value: B, children: r }) : (0, v.jsx)(g_, { type: "no-data", children: "function" === typeof h ? h() : h }) })) })), j_ = O_; function F_() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; var n = e.filter(Boolean); return n.length <= 1 ? n[0] || null : function (e) { n.forEach((function (t) { "function" === typeof t ? t(e) : t && (t.current = e) })) } } const z_ = (0, t.createContext)(null), W_ = { Document: null, DocumentFragment: null, Part: "group", Sect: "group", Div: "group", Aside: "note", NonStruct: "none", P: null, H: "heading", Title: null, FENote: "note", Sub: "group", Lbl: null, Span: null, Em: null, Strong: null, Link: "link", Annot: "note", Form: "form", Ruby: null, RB: null, RT: null, RP: null, Warichu: null, WT: null, WP: null, L: "list", LI: "listitem", LBody: null, Table: "table", TR: "row", TH: "columnheader", TD: "cell", THead: "columnheader", TBody: null, TFoot: null, Caption: null, Figure: "figure", Formula: null, Artifact: null }, B_ = /^H(\d+)$/; function H_(e) { return "children" in e } function U_(e) { return !!H_(e) && (1 === e.children.length && 0 in e.children && "id" in e.children[0]) } function V_(e) { const t = {}; if (H_(e)) { const { role: n } = e, r = n.match(B_); if (r) t.role = "heading", t["aria-level"] = Number(r[1]); else if (function (e) { return e in W_ }(n)) { const e = W_[n]; e && (t.role = e) } } return t } function q_(e) { const t = {}; if (H_(e)) { if (void 0 !== e.alt && (t["aria-label"] = e.alt), void 0 !== e.lang && (t.lang = e.lang), U_(e)) { const [n] = e.children; if (n) { const e = q_(n); return Object.assign(Object.assign({}, t), e) } } } else "id" in e && (t["aria-owns"] = e.id); return t } function G_(e) { return e ? Object.assign(Object.assign({}, V_(e)), q_(e)) : null } function X_(e) { let { className: n, node: r } = e; const i = (0, t.useMemo)((() => G_(r)), [r]), a = (0, t.useMemo)((() => H_(r) ? U_(r) ? null : r.children.map(((e, t) => (0, v.jsx)(X_, { node: e }, t))) : null), [r]); return (0, v.jsx)("span", Object.assign({ className: n }, i, { children: a })) } function Y_() { return (0, t.useContext)(z_) } function K_() { const e = Y_(); to(e, "Unable to find Page context."); const { onGetStructTreeError: n, onGetStructTreeSuccess: r } = e, [i, a] = P_(), { value: s, error: o } = i, { customTextRenderer: l, page: c } = e; return (0, t.useEffect)((function () { a({ type: "RESET" }) }), [a, c]), (0, t.useEffect)((function () { if (l) return; if (!c) return; const e = Js(c.getStructTree()), t = e; return e.promise.then((e => { a({ type: "RESOLVE", value: e }) })).catch((e => { a({ type: "REJECT", error: e }) })), () => C_(t) }), [l, c, a]), (0, t.useEffect)((() => { void 0 !== s && (!1 !== s ? s && r && r(s) : o && (mo(!1, o.toString()), n && n(o))) }), [s]), s ? (0, v.jsx)(X_, { className: "react-pdf__Page__structTree structTree", node: s }) : null } const Q_ = c_; function $_(e) { const n = Y_(); to(n, "Unable to find Page context."); const r = Object.assign(Object.assign({}, n), e), { _className: i, canvasBackground: a, devicePixelRatio: s = S_(), onRenderError: o, onRenderSuccess: l, page: c, renderForms: u, renderTextLayer: d, rotate: h, scale: f } = r, { canvasRef: p } = e; to(c, "Attempted to render page canvas, but no page was specified."); const m = (0, t.useRef)(null); function g(e) { (function (e) { return "RenderingCancelledException" === e.name })(e) || (mo(!1, e.toString()), o && o(e)) } const b = (0, t.useMemo)((() => c.getViewport({ scale: f * s, rotation: h })), [s, c, h, f]), y = (0, t.useMemo)((() => c.getViewport({ scale: f, rotation: h })), [c, h, f]); (0, t.useEffect)((function () { if (!c) return; c.cleanup(); const { current: e } = m; if (!e) return; e.width = b.width, e.height = b.height, e.style.width = "".concat(Math.floor(y.width), "px"), e.style.height = "".concat(Math.floor(y.height), "px"), e.style.visibility = "hidden"; const t = { annotationMode: u ? Q_.ENABLE_FORMS : Q_.ENABLE, canvasContext: e.getContext("2d", { alpha: !1 }), viewport: b }; a && (t.background = a); const n = c.render(t), r = n; return n.promise.then((() => { e.style.visibility = "", c && l && l(M_(c, f)) })).catch(g), () => C_(r) }), [a, c, u, b, y]); const w = (0, t.useCallback)((() => { const { current: e } = m; e && (e.width = 0, e.height = 0) }), []); return (0, t.useEffect)((() => w), [w]), (0, v.jsx)("canvas", { className: "".concat(i, "__canvas"), dir: "ltr", ref: F_(p, m), style: { display: "block", userSelect: "none" }, children: d ? (0, v.jsx)(K_, {}) : null }) } function J_() { const e = Y_(); to(e, "Unable to find Page context."); const { customTextRenderer: n, onGetTextError: r, onGetTextSuccess: i, onRenderTextLayerError: a, onRenderTextLayerSuccess: s, page: o, pageIndex: l, pageNumber: c, rotate: u, scale: d } = e; to(o, "Attempted to load page text content, but no page was specified."); const [h, f] = P_(), { value: p, error: m } = h, g = (0, t.useRef)(null), b = (0, t.useRef)(void 0); mo(1 === Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10), "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer"), (0, t.useEffect)((function () { f({ type: "RESET" }) }), [o, f]), (0, t.useEffect)((function () { if (!o) return; const e = Js(o.getTextContent()), t = e; return e.promise.then((e => { f({ type: "RESOLVE", value: e }) })).catch((e => { f({ type: "REJECT", error: e }) })), () => C_(t) }), [o, f]), (0, t.useEffect)((() => { void 0 !== p && (!1 !== p ? p && i && i(p) : m && (mo(!1, m.toString()), r && r(m))) }), [p]); const y = (0, t.useCallback)((() => { s && s() }), [s]), w = (0, t.useCallback)((e => { mo(!1, e.toString()), a && a(e) }), [a]); const x = (0, t.useMemo)((() => o.getViewport({ scale: d, rotation: u })), [o, u, d]); return (0, t.useLayoutEffect)((function () { if (!o || !p) return; const { current: e } = g; if (!e) return; e.innerHTML = ""; const t = o.streamTextContent({ includeMarkedContent: !0 }), r = new h_({ container: e, textContentSource: t, viewport: x }), i = r; return r.render().then((() => { const t = document.createElement("div"); t.className = "endOfContent", e.append(t), b.current = t; const r = e.querySelectorAll('[role="presentation"]'); if (n) { let e = 0; p.items.forEach(((t, i) => { if (!function (e) { return "str" in e }(t)) return; const a = r[e]; if (!a) return; const s = n(Object.assign({ pageIndex: l, pageNumber: c, itemIndex: i }, t)); a.innerHTML = s, e += t.str && t.hasEOL ? 2 : 1 })) } y() })).catch(w), () => C_(i) }), [n, w, y, o, l, c, p, x]), (0, v.jsx)("div", { className: te("react-pdf__Page__textContent", "textLayer"), onMouseUp: function () { const e = b.current; e && e.classList.remove("active") }, onMouseDown: function () { const e = b.current; e && e.classList.add("active") }, ref: g }) } function Z_() { return (0, t.useContext)(m_) } function ek() { const e = Z_(), n = Y_(); to(n, "Unable to find Page context."); const r = Object.assign(Object.assign({}, e), n), { imageResourcesPath: i, linkService: a, onGetAnnotationsError: s, onGetAnnotationsSuccess: o, onRenderAnnotationLayerError: l, onRenderAnnotationLayerSuccess: c, page: u, pdf: d, renderForms: h, rotate: f, scale: p = 1 } = r; to(d, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."), to(u, "Attempted to load page annotations, but no page was specified."), to(a, "Attempted to load page annotations, but no linkService was specified."); const [m, g] = P_(), { value: b, error: y } = m, w = (0, t.useRef)(null); mo(1 === Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10), "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations"), (0, t.useEffect)((function () { g({ type: "RESET" }) }), [g, u]), (0, t.useEffect)((function () { if (!u) return; const e = Js(u.getAnnotations()), t = e; return e.promise.then((e => { g({ type: "RESOLVE", value: e }) })).catch((e => { g({ type: "REJECT", error: e }) })), () => { C_(t) } }), [g, u]), (0, t.useEffect)((() => { void 0 !== b && (!1 !== b ? b && o && o(b) : y && (mo(!1, y.toString()), s && s(y))) }), [b]); const x = (0, t.useMemo)((() => u.getViewport({ scale: p, rotation: f })), [u, f, p]); return (0, t.useEffect)((function () { if (!d || !u || !a || !b) return; const { current: e } = w; if (!e) return; const t = x.clone({ dontFlip: !0 }), n = { accessibilityManager: null, annotationCanvasMap: null, annotationEditorUIManager: null, div: e, l10n: null, page: u, viewport: t }, r = { annotations: b, annotationStorage: d.annotationStorage, div: e, imageResourcesPath: i, linkService: a, page: u, renderForms: h, viewport: t }; e.innerHTML = ""; try { new l_(n).render(r), c && c() } catch (s) { !function (e) { mo(!1, "".concat(e)), l && l(e) }(s) } return () => { } }), [b, i, a, u, d, h, x]), (0, v.jsx)("div", { className: te("react-pdf__Page__annotations", "annotationLayer"), ref: w }) } var tk = function (e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" === typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n }; const nk = 1; function rk(e) { const n = Z_(), r = Object.assign(Object.assign({}, n), e), { _className: i = "react-pdf__Page", _enableRegisterUnregisterPage: a = !0, canvasBackground: s, canvasRef: o, children: l, className: c, customRenderer: u, customTextRenderer: d, devicePixelRatio: h, error: f = "Failed to load the page.", height: p, inputRef: m, loading: g = "Loading page\u2026", noData: b = "No page specified.", onGetAnnotationsError: y, onGetAnnotationsSuccess: w, onGetStructTreeError: x, onGetStructTreeSuccess: _, onGetTextError: k, onGetTextSuccess: S, onLoadError: A, onLoadSuccess: E, onRenderAnnotationLayerError: C, onRenderAnnotationLayerSuccess: M, onRenderError: T, onRenderSuccess: P, onRenderTextLayerError: R, onRenderTextLayerSuccess: N, pageIndex: L, pageNumber: I, pdf: D, registerPage: O, renderAnnotationLayer: j = !0, renderForms: F = !1, renderMode: z = "canvas", renderTextLayer: W = !0, rotate: B, scale: H = nk, unregisterPage: U, width: V } = r, q = tk(r, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]), [G, X] = P_(), { value: Y, error: K } = G, Q = (0, t.useRef)(null); to(D, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."); const $ = x_(I) ? I - 1 : null !== L && void 0 !== L ? L : null, J = null !== I && void 0 !== I ? I : x_(L) ? L + 1 : null, Z = null !== B && void 0 !== B ? B : Y ? Y.rotate : null, ee = (0, t.useMemo)((() => { if (!Y) return null; let e = 1; const t = null !== H && void 0 !== H ? H : nk; if (V || p) { const t = Y.getViewport({ scale: 1, rotation: Z }); V ? e = V / t.width : p && (e = p / t.height) } return t * e }), [p, Y, Z, H, V]); (0, t.useEffect)((function () { return () => { x_($) && a && U && U($) } }), [a, D, $, U]), (0, t.useEffect)((function () { X({ type: "RESET" }) }), [X, D, $]), (0, t.useEffect)((function () { if (!D || !J) return; const e = Js(D.getPage(J)), t = e; return e.promise.then((e => { X({ type: "RESOLVE", value: e }) })).catch((e => { X({ type: "REJECT", error: e }) })), () => C_(t) }), [X, D, J]), (0, t.useEffect)((() => { void 0 !== Y && (!1 !== Y ? function () { if (E) { if (!Y || !ee) return; E(M_(Y, ee)) } if (a && O) { if (!x_($) || !Q.current) return; O($, Q.current) } }() : K && (mo(!1, K.toString()), A && A(K))) }), [Y, ee]); const ne = (0, t.useMemo)((() => Y && x_($) && J && x_(Z) && x_(ee) ? { _className: i, canvasBackground: s, customTextRenderer: d, devicePixelRatio: h, onGetAnnotationsError: y, onGetAnnotationsSuccess: w, onGetStructTreeError: x, onGetStructTreeSuccess: _, onGetTextError: k, onGetTextSuccess: S, onRenderAnnotationLayerError: C, onRenderAnnotationLayerSuccess: M, onRenderError: T, onRenderSuccess: P, onRenderTextLayerError: R, onRenderTextLayerSuccess: N, page: Y, pageIndex: $, pageNumber: J, renderForms: F, renderTextLayer: W, rotate: Z, scale: ee } : null), [i, s, d, h, y, w, x, _, k, S, C, M, T, P, R, N, Y, $, J, F, W, Z, ee]), re = (0, t.useMemo)((() => $s(q, (() => Y ? ee ? M_(Y, ee) : void 0 : Y))), [q, Y, ee]), ie = "".concat($, "@").concat(ee, "/").concat(Z); function ae() { switch (z) { case "custom": return to(u, 'renderMode was set to "custom", but no customRenderer was passed.'), (0, v.jsx)(u, {}, "".concat(ie, "_custom")); case "none": return null; default: return (0, v.jsx)($_, { canvasRef: o }, "".concat(ie, "_canvas")) } } return (0, v.jsx)("div", Object.assign({ className: te(i, c), "data-page-number": J, ref: F_(m, Q), style: { "--scale-factor": "".concat(ee), backgroundColor: s || "white", position: "relative", minWidth: "min-content", minHeight: "min-content" } }, re, { children: J ? null === D || void 0 === Y || null === Y ? (0, v.jsx)(g_, { type: "loading", children: "function" === typeof g ? g() : g }) : !1 === D || !1 === Y ? (0, v.jsx)(g_, { type: "error", children: "function" === typeof f ? f() : f }) : (0, v.jsxs)(z_.Provider, { value: ne, children: [ae(), W ? (0, v.jsx)(J_, {}, "".concat(ie, "_text")) : null, j ? (0, v.jsx)(ek, {}, "".concat(ie, "_annotations")) : null, l] }) : (0, v.jsx)(g_, { type: "no-data", children: "function" === typeof b ? b() : b }) })) } const ik = e => { const t = G({ xs: "xs", sm: "sm", md: "md" }); return (0, v.jsxs)(pr.Root, { scrollAreaComponent: Kr.Autosize, size: "auto", centered: !0, className: " font-mono", opened: e.opened, onClose: e.close, children: [(0, v.jsx)(pr.Overlay, { className: "!backdrop-opacity-85 blur-sm" }), (0, v.jsxs)(pr.Content, { className: "!rounded-3xl", children: [(0, v.jsxs)(pr.Header, { className: "!bg-bgColor xs-mx:!p-2 !border-primaryColor xs-mx:!border  !border-2 xs-mx:!border-b-0 !border-b-0 !rounded-tl-3xl !rounded-tr-3xl", children: [(0, v.jsxs)(pr.Title, { "data-autofocus": !0, className: "!text-4xl xs-mx:!text-2xl text-white flex gap-3 items-center !font-bold", children: ["Resume", (0, v.jsx)(Ls, { label: "Download", className: "!text-bgColor", color: "#64FFDA", position: "right", offset: 5, children: (0, v.jsx)(Xs, { className: "!text-primaryColor", component: "a", href: "Resume.pdf", size: t, download: l.name, variant: "outline", color: "#64FFDA", children: (0, v.jsx)(Ys, { className: " xs-mx:!w-[16px] xs-mx:!h-" }) }) })] }), (0, v.jsx)(pr.CloseButton, { size: "md", iconSize: "30px", className: "!bg-bgColor !text-red-500" })] }), (0, v.jsx)(pr.Body, { className: "!bg-bgColor xs-mx:!p-2 !pt-2 !border-primaryColor  !border-2 xs-mx:!border xs-mx:!border-t-0 !border-t-0 !rounded-bl-3xl !rounded-br-3xl ", children: (0, v.jsx)(j_, { className: "w-full !rounded-2xl !overflow-hidden !min-w-40 !min-h-14", file: "Resume.pdf", children: (0, v.jsx)(rk, { className: "w-full !min-w-40 !min-h-14 md-mx:[&>.react-pdf\\_\\_Page\\_\\_canvas]:!w-full md-mx:[&>.react-pdf\\_\\_Page\\_\\_canvas]:!h-auto", pageNumber: 1, renderTextLayer: !1, renderAnnotationLayer: !1 }) }) })] })] }) }; function ak() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], n = arguments.length > 1 ? arguments[1] : void 0; const { onOpen: r, onClose: i } = n || {}, [a, s] = (0, t.useState)(e), o = (0, t.useCallback)((() => { s((e => e || (null === r || void 0 === r || r(), !0))) }), [r]), l = (0, t.useCallback)((() => { s((e => e ? (null === i || void 0 === i || i(), !1) : e)) }), [i]), c = (0, t.useCallback)((() => { a ? l() : o() }), [l, o, a]); return [a, { open: o, close: l, toggle: c }] } const sk = e => { let { className: n = "", quantity: r = 100, staticity: i = 50, ease: a = 50, size: s = .4, refresh: o = !1, color: l = "#ffffff", vx: c = 0, vy: u = 0 } = e; const d = (0, t.useRef)(null), h = (0, t.useRef)(null), f = (0, t.useRef)(null), p = (0, t.useRef)([]), m = function () { const [e, n] = (0, t.useState)({ x: 0, y: 0 }); return (0, t.useEffect)((() => { const e = e => { n({ x: e.clientX, y: e.clientY }) }; return window.addEventListener("mousemove", e), () => { window.removeEventListener("mousemove", e) } }), []), e }(), g = (0, t.useRef)({ x: 0, y: 0 }), b = (0, t.useRef)({ w: 0, h: 0 }), y = "undefined" !== typeof window ? window.devicePixelRatio : 1; (0, t.useEffect)((() => (d.current && (f.current = d.current.getContext("2d")), w(), M(), window.addEventListener("resize", w), () => { window.removeEventListener("resize", w) })), [l]), (0, t.useEffect)((() => { x() }), [m.x, m.y]), (0, t.useEffect)((() => { w() }), [o]); const w = () => { _(), C() }, x = () => { if (d.current) { const e = d.current.getBoundingClientRect(), { w: t, h: n } = b.current, r = m.x - e.left - t / 2, i = m.y - e.top - n / 2; r < t / 2 && r > -t / 2 && i < n / 2 && i > -n / 2 && (g.current.x = r, g.current.y = i) } }, _ = () => { h.current && d.current && f.current && (p.current.length = 0, b.current.w = h.current.offsetWidth, b.current.h = h.current.offsetHeight, d.current.width = b.current.w * y, d.current.height = b.current.h * y, d.current.style.width = "".concat(b.current.w, "px"), d.current.style.height = "".concat(b.current.h, "px"), f.current.scale(y, y)) }, k = () => ({ x: Math.floor(Math.random() * b.current.w), y: Math.floor(Math.random() * b.current.h), translateX: 0, translateY: 0, size: Math.floor(2 * Math.random()) + s, alpha: 0, targetAlpha: parseFloat((.6 * Math.random() + .1).toFixed(1)), dx: .1 * (Math.random() - .5), dy: .1 * (Math.random() - .5), magnetism: .1 + 4 * Math.random() }), S = function (e) { e = e.replace("#", ""); const t = parseInt(e, 16); return [t >> 16 & 255, t >> 8 & 255, 255 & t] }(l), A = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (f.current) { const { x: n, y: r, translateX: i, translateY: a, size: s, alpha: o } = e; f.current.translate(i, a), f.current.beginPath(), f.current.arc(n, r, s, 0, 2 * Math.PI), f.current.fillStyle = "rgba(".concat(S.join(", "), ", ").concat(o, ")"), f.current.fill(), f.current.setTransform(y, 0, 0, y, 0, 0), t || p.current.push(e) } }, E = () => { f.current && f.current.clearRect(0, 0, b.current.w, b.current.h) }, C = () => { E(); const e = r; for (let t = 0; t < e; t++) { const e = k(); A(e) } }, M = () => { E(), p.current.forEach(((e, t) => { const n = [e.x + e.translateX - e.size, b.current.w - e.x - e.translateX - e.size, e.y + e.translateY - e.size, b.current.h - e.y - e.translateY - e.size].reduce(((e, t) => Math.min(e, t))), r = parseFloat(((e, t, n, r, i) => { const a = (e - t) * (i - r) / (n - t) + r; return a > 0 ? a : 0 })(n, 0, 20, 0, 1).toFixed(2)); if (r > 1 ? (e.alpha += .02, e.alpha > e.targetAlpha && (e.alpha = e.targetAlpha)) : e.alpha = e.targetAlpha * r, e.x += e.dx + c, e.y += e.dy + u, e.translateX += (g.current.x / (i / e.magnetism) - e.translateX) / a, e.translateY += (g.current.y / (i / e.magnetism) - e.translateY) / a, A(e, !0), e.x < -e.size || e.x > b.current.w + e.size || e.y < -e.size || e.y > b.current.h + e.size) { p.current.splice(t, 1); const e = k(); A(e) } })), window.requestAnimationFrame(M) }; return (0, v.jsx)("div", { className: n, ref: h, "aria-hidden": "true", children: (0, v.jsx)("canvas", { ref: d, className: "h-full w-full" }) }) }, ok = "-"; function lk(e) { const t = function (e) { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }, i = function (e, t) { if (!t) return e; return e.map((e => { let [n, r] = e; return [n, r.map((e => "string" === typeof e ? t + e : "object" === typeof e ? Object.fromEntries(Object.entries(e).map((e => { let [n, r] = e; return [t + n, r] }))) : e))] })) }(Object.entries(e.classGroups), n); return i.forEach((e => { let [n, i] = e; dk(i, r, n, t) })), r }(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: function (e) { const n = e.split(ok); return "" === n[0] && 1 !== n.length && n.shift(), ck(n, t) || function (e) { if (uk.test(e)) { const t = uk.exec(e)[1], n = null === t || void 0 === t ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }(e) }, getConflictingClassGroupIds: function (e, t) { const i = n[e] || []; return t && r[e] ? [...i, ...r[e]] : i } } } function ck(e, t) { var n; if (0 === e.length) return t.classGroupId; const r = e[0], i = t.nextPart.get(r), a = i ? ck(e.slice(1), i) : void 0; if (a) return a; if (0 === t.validators.length) return; const s = e.join(ok); return null === (n = t.validators.find((e => { let { validator: t } = e; return t(s) }))) || void 0 === n ? void 0 : n.classGroupId } const uk = /^\[(.+)\]$/; function dk(e, t, n, r) { e.forEach((e => { if ("string" !== typeof e) { if ("function" === typeof e) return e.isThemeGetter ? void dk(e(r), t, n, r) : void t.validators.push({ validator: e, classGroupId: n }); Object.entries(e).forEach((e => { let [i, a] = e; dk(a, hk(t, i), n, r) })) } else { ("" === e ? t : hk(t, e)).classGroupId = n } })) } function hk(e, t) { let n = e; return t.split(ok).forEach((e => { n.nextPart.has(e) || n.nextPart.set(e, { nextPart: new Map, validators: [] }), n = n.nextPart.get(e) })), n } function fk(e) { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; function i(i, a) { n.set(i, a), t++, t > e && (t = 0, r = n, n = new Map) } return { get(e) { let t = n.get(e); return void 0 !== t ? t : void 0 !== (t = r.get(e)) ? (i(e, t), t) : void 0 }, set(e, t) { n.has(e) ? n.set(e, t) : i(e, t) } } } const pk = "!"; function mk(e) { const { separator: t, experimentalParseClassName: n } = e, r = 1 === t.length, i = t[0], a = t.length; function s(e) { const n = []; let s, o = 0, l = 0; for (let d = 0; d < e.length; d++) { let c = e[d]; if (0 === o) { if (c === i && (r || e.slice(d, d + a) === t)) { n.push(e.slice(l, d)), l = d + a; continue } if ("/" === c) { s = d; continue } } "[" === c ? o++ : "]" === c && o-- } const c = 0 === n.length ? e : e.substring(l), u = c.startsWith(pk); return { modifiers: n, hasImportantModifier: u, baseClassName: u ? c.substring(1) : c, maybePostfixModifierPosition: s && s > l ? s - l : void 0 } } return n ? function (e) { return n({ className: e, parseClassName: s }) } : s } const gk = /\s+/; function vk() { let e, t, n = 0, r = ""; for (; n < arguments.length;)(e = arguments[n++]) && (t = bk(e)) && (r && (r += " "), r += t); return r } function bk(e) { if ("string" === typeof e) return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = bk(e[r])) && (n && (n += " "), n += t); return n } function yk(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; let i, a, s, o = function (t) { const r = n.reduce(((e, t) => t(e)), e()); return i = function (e) { return { cache: fk(e.cacheSize), parseClassName: mk(e), ...lk(e) } }(r), a = i.cache.get, s = i.cache.set, o = l, l(t) }; function l(e) { const t = a(e); if (t) return t; const n = function (e, t) { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: i } = t, a = new Set; return e.trim().split(gk).map((e => { const { modifiers: t, hasImportantModifier: i, baseClassName: a, maybePostfixModifierPosition: s } = n(e); let o = Boolean(s), l = r(o ? a.substring(0, s) : a); if (!l) { if (!o) return { isTailwindClass: !1, originalClassName: e }; if (l = r(a), !l) return { isTailwindClass: !1, originalClassName: e }; o = !1 } const c = function (e) { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach((e => { "[" === e[0] ? (t.push(...n.sort(), e), n = []) : n.push(e) })), t.push(...n.sort()), t }(t).join(":"); return { isTailwindClass: !0, modifierId: i ? c + pk : c, classGroupId: l, originalClassName: e, hasPostfixModifier: o } })).reverse().filter((e => { if (!e.isTailwindClass) return !0; const { modifierId: t, classGroupId: n, hasPostfixModifier: r } = e, s = t + n; return !a.has(s) && (a.add(s), i(n, r).forEach((e => a.add(t + e))), !0) })).reverse().map((e => e.originalClassName)).join(" ") }(e, i); return s(e, n), n } return function () { return o(vk.apply(null, arguments)) } } function wk(e) { const t = t => t[e] || []; return t.isThemeGetter = !0, t } const xk = /^\[(?:([a-z-]+):)?(.+)\]$/i, _k = /^\d+\/\d+$/, kk = new Set(["px", "full", "screen"]), Sk = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Ak = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Ek = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Ck = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Mk = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/; function Tk(e) { return Rk(e) || kk.has(e) || _k.test(e) } function Pk(e) { return Vk(e, "length", qk) } function Rk(e) { return Boolean(e) && !Number.isNaN(Number(e)) } function Nk(e) { return Vk(e, "number", Rk) } function Lk(e) { return Boolean(e) && Number.isInteger(Number(e)) } function Ik(e) { return e.endsWith("%") && Rk(e.slice(0, -1)) } function Dk(e) { return xk.test(e) } function Ok(e) { return Sk.test(e) } const jk = new Set(["length", "size", "percentage"]); function Fk(e) { return Vk(e, jk, Gk) } function zk(e) { return Vk(e, "position", Gk) } const Wk = new Set(["image", "url"]); function Bk(e) { return Vk(e, Wk, Yk) } function Hk(e) { return Vk(e, "", Xk) } function Uk() { return !0 } function Vk(e, t, n) { const r = xk.exec(e); return !!r && (r[1] ? "string" === typeof t ? r[1] === t : t.has(r[1]) : n(r[2])) } function qk(e) { return Ak.test(e) && !Ek.test(e) } function Gk() { return !1 } function Xk(e) { return Ck.test(e) } function Yk(e) { return Mk.test(e) } Symbol.toStringTag; function Kk() { const e = wk("colors"), t = wk("spacing"), n = wk("blur"), r = wk("brightness"), i = wk("borderColor"), a = wk("borderRadius"), s = wk("borderSpacing"), o = wk("borderWidth"), l = wk("contrast"), c = wk("grayscale"), u = wk("hueRotate"), d = wk("invert"), h = wk("gap"), f = wk("gradientColorStops"), p = wk("gradientColorStopPositions"), m = wk("inset"), g = wk("margin"), v = wk("opacity"), b = wk("padding"), y = wk("saturate"), w = wk("scale"), x = wk("sepia"), _ = wk("skew"), k = wk("space"), S = wk("translate"), A = () => ["auto", Dk, t], E = () => [Dk, t], C = () => ["", Tk, Pk], M = () => ["auto", Rk, Dk], T = () => ["", "0", Dk], P = () => [Rk, Nk], R = () => [Rk, Dk]; return { cacheSize: 500, separator: ":", theme: { colors: [Uk], spacing: [Tk, Pk], blur: ["none", "", Ok, Dk], brightness: P(), borderColor: [e], borderRadius: ["none", "", "full", Ok, Dk], borderSpacing: E(), borderWidth: C(), contrast: P(), grayscale: T(), hueRotate: R(), invert: T(), gap: E(), gradientColorStops: [e], gradientColorStopPositions: [Ik, Pk], inset: A(), margin: A(), opacity: P(), padding: E(), saturate: P(), scale: P(), sepia: T(), skew: R(), space: E(), translate: E() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", Dk] }], container: ["container"], columns: [{ columns: [Ok] }], "break-after": [{ "break-after": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }], "break-before": [{ "break-before": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top", Dk] }], overflow: [{ overflow: ["auto", "hidden", "clip", "visible", "scroll"] }], "overflow-x": [{ "overflow-x": ["auto", "hidden", "clip", "visible", "scroll"] }], "overflow-y": [{ "overflow-y": ["auto", "hidden", "clip", "visible", "scroll"] }], overscroll: [{ overscroll: ["auto", "contain", "none"] }], "overscroll-x": [{ "overscroll-x": ["auto", "contain", "none"] }], "overscroll-y": [{ "overscroll-y": ["auto", "contain", "none"] }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [m] }], "inset-x": [{ "inset-x": [m] }], "inset-y": [{ "inset-y": [m] }], start: [{ start: [m] }], end: [{ end: [m] }], top: [{ top: [m] }], right: [{ right: [m] }], bottom: [{ bottom: [m] }], left: [{ left: [m] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Lk, Dk] }], basis: [{ basis: A() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", Dk] }], grow: [{ grow: T() }], shrink: [{ shrink: T() }], order: [{ order: ["first", "last", "none", Lk, Dk] }], "grid-cols": [{ "grid-cols": [Uk] }], "col-start-end": [{ col: ["auto", { span: ["full", Lk, Dk] }, Dk] }], "col-start": [{ "col-start": M() }], "col-end": [{ "col-end": M() }], "grid-rows": [{ "grid-rows": [Uk] }], "row-start-end": [{ row: ["auto", { span: [Lk, Dk] }, Dk] }], "row-start": [{ "row-start": M() }], "row-end": [{ "row-end": M() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Dk] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Dk] }], gap: [{ gap: [h] }], "gap-x": [{ "gap-x": [h] }], "gap-y": [{ "gap-y": [h] }], "justify-content": [{ justify: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch"] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch", "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [b] }], px: [{ px: [b] }], py: [{ py: [b] }], ps: [{ ps: [b] }], pe: [{ pe: [b] }], pt: [{ pt: [b] }], pr: [{ pr: [b] }], pb: [{ pb: [b] }], pl: [{ pl: [b] }], m: [{ m: [g] }], mx: [{ mx: [g] }], my: [{ my: [g] }], ms: [{ ms: [g] }], me: [{ me: [g] }], mt: [{ mt: [g] }], mr: [{ mr: [g] }], mb: [{ mb: [g] }], ml: [{ ml: [g] }], "space-x": [{ "space-x": [k] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [k] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Dk, t] }], "min-w": [{ "min-w": [Dk, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [Dk, t, "none", "full", "min", "max", "fit", "prose", { screen: [Ok] }, Ok] }], h: [{ h: [Dk, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [Dk, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [Dk, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [Dk, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", Ok, Pk] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Nk] }], "font-family": [{ font: [Uk] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Dk] }], "line-clamp": [{ "line-clamp": ["none", Rk, Nk] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Tk, Dk] }], "list-image": [{ "list-image": ["none", Dk] }], "list-style-type": [{ list: ["none", "disc", "decimal", Dk] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [v] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [v] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: ["solid", "dashed", "dotted", "double", "none", "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", Tk, Pk] }], "underline-offset": [{ "underline-offset": ["auto", Tk, Dk] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: E() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Dk] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Dk] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [v] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top", zk] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Fk] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Bk] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [p] }], "gradient-via-pos": [{ via: [p] }], "gradient-to-pos": [{ to: [p] }], "gradient-from": [{ from: [f] }], "gradient-via": [{ via: [f] }], "gradient-to": [{ to: [f] }], rounded: [{ rounded: [a] }], "rounded-s": [{ "rounded-s": [a] }], "rounded-e": [{ "rounded-e": [a] }], "rounded-t": [{ "rounded-t": [a] }], "rounded-r": [{ "rounded-r": [a] }], "rounded-b": [{ "rounded-b": [a] }], "rounded-l": [{ "rounded-l": [a] }], "rounded-ss": [{ "rounded-ss": [a] }], "rounded-se": [{ "rounded-se": [a] }], "rounded-ee": [{ "rounded-ee": [a] }], "rounded-es": [{ "rounded-es": [a] }], "rounded-tl": [{ "rounded-tl": [a] }], "rounded-tr": [{ "rounded-tr": [a] }], "rounded-br": [{ "rounded-br": [a] }], "rounded-bl": [{ "rounded-bl": [a] }], "border-w": [{ border: [o] }], "border-w-x": [{ "border-x": [o] }], "border-w-y": [{ "border-y": [o] }], "border-w-s": [{ "border-s": [o] }], "border-w-e": [{ "border-e": [o] }], "border-w-t": [{ "border-t": [o] }], "border-w-r": [{ "border-r": [o] }], "border-w-b": [{ "border-b": [o] }], "border-w-l": [{ "border-l": [o] }], "border-opacity": [{ "border-opacity": [v] }], "border-style": [{ border: ["solid", "dashed", "dotted", "double", "none", "hidden"] }], "divide-x": [{ "divide-x": [o] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [o] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [v] }], "divide-style": [{ divide: ["solid", "dashed", "dotted", "double", "none"] }], "border-color": [{ border: [i] }], "border-color-x": [{ "border-x": [i] }], "border-color-y": [{ "border-y": [i] }], "border-color-t": [{ "border-t": [i] }], "border-color-r": [{ "border-r": [i] }], "border-color-b": [{ "border-b": [i] }], "border-color-l": [{ "border-l": [i] }], "divide-color": [{ divide: [i] }], "outline-style": [{ outline: ["", "solid", "dashed", "dotted", "double", "none"] }], "outline-offset": [{ "outline-offset": [Tk, Dk] }], "outline-w": [{ outline: [Tk, Pk] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: C() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [v] }], "ring-offset-w": [{ "ring-offset": [Tk, Pk] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", Ok, Hk] }], "shadow-color": [{ shadow: [Uk] }], opacity: [{ opacity: [v] }], "mix-blend": [{ "mix-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"] }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", Ok, Dk] }], grayscale: [{ grayscale: [c] }], "hue-rotate": [{ "hue-rotate": [u] }], invert: [{ invert: [d] }], saturate: [{ saturate: [y] }], sepia: [{ sepia: [x] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [c] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [u] }], "backdrop-invert": [{ "backdrop-invert": [d] }], "backdrop-opacity": [{ "backdrop-opacity": [v] }], "backdrop-saturate": [{ "backdrop-saturate": [y] }], "backdrop-sepia": [{ "backdrop-sepia": [x] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [s] }], "border-spacing-x": [{ "border-spacing-x": [s] }], "border-spacing-y": [{ "border-spacing-y": [s] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Dk] }], duration: [{ duration: R() }], ease: [{ ease: ["linear", "in", "out", "in-out", Dk] }], delay: [{ delay: R() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Dk] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [w] }], "scale-x": [{ "scale-x": [w] }], "scale-y": [{ "scale-y": [w] }], rotate: [{ rotate: [Lk, Dk] }], "translate-x": [{ "translate-x": [S] }], "translate-y": [{ "translate-y": [S] }], "skew-x": [{ "skew-x": [_] }], "skew-y": [{ "skew-y": [_] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Dk] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Dk] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": E() }], "scroll-mx": [{ "scroll-mx": E() }], "scroll-my": [{ "scroll-my": E() }], "scroll-ms": [{ "scroll-ms": E() }], "scroll-me": [{ "scroll-me": E() }], "scroll-mt": [{ "scroll-mt": E() }], "scroll-mr": [{ "scroll-mr": E() }], "scroll-mb": [{ "scroll-mb": E() }], "scroll-ml": [{ "scroll-ml": E() }], "scroll-p": [{ "scroll-p": E() }], "scroll-px": [{ "scroll-px": E() }], "scroll-py": [{ "scroll-py": E() }], "scroll-ps": [{ "scroll-ps": E() }], "scroll-pe": [{ "scroll-pe": E() }], "scroll-pt": [{ "scroll-pt": E() }], "scroll-pr": [{ "scroll-pr": E() }], "scroll-pb": [{ "scroll-pb": E() }], "scroll-pl": [{ "scroll-pl": E() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Dk] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [Tk, Pk, Nk] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } } const Qk = yk(Kk); function $k() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return Qk(ee(t)) } const Jk = e => { let { className: n, children: r, borderSize: i = 4, borderRadius: a = 9999, neonColors: s = { firstColor: "#ff00aa", secondColor: "#00FFF1" }, ...o } = e; const l = (0, t.useRef)(null), [c, u] = (0, t.useState)({ width: 0, height: 0 }); return (0, t.useEffect)((() => { const e = () => { if (l.current) { const { offsetWidth: e, offsetHeight: t } = l.current; u({ width: e, height: t }) } }; return e(), window.addEventListener("resize", e), () => { window.removeEventListener("resize", e) } }), []), (0, t.useEffect)((() => { if (l.current) { const { offsetWidth: e, offsetHeight: t } = l.current; u({ width: e, height: t }) } }), [r]), (0, v.jsx)("div", { ref: l, style: { "--border-size": "".concat(i, "px"), "--border-radius": "".concat(a, "px"), "--neon-first-color": s.firstColor, "--neon-second-color": s.secondColor, "--card-width": "".concat(c.width, "px"), "--card-height": "".concat(c.height, "px"), "--card-content-radius": "".concat(a - i, "px"), "--pseudo-element-background-image": "linear-gradient(0deg, ".concat(s.firstColor, ", ").concat(s.secondColor, ")"), "--pseudo-element-width": "".concat(c.width + 2 * i, "px"), "--pseudo-element-height": "".concat(c.height + 2 * i, "px"), "--after-blur": "".concat(c.width / 9, "px") }, className: $k("relative z-10 h-full w-full rounded-[var(--border-radius)]", n), ...o, children: (0, v.jsx)("div", { className: $k("relative h-full min-h-[inherit] w-full rounded-[var(--card-content-radius)] bg-gray-100", "before:absolute before:-left-[var(--border-size)] before:-top-[var(--border-size)] before:-z-10 before:block", "before:h-[var(--pseudo-element-height)] before:w-[var(--pseudo-element-width)] before:rounded-[var(--border-radius)] before:content-['']", "before:bg-[linear-gradient(0deg,var(--neon-first-color),var(--neon-second-color))] before:bg-[length:100%_200%]", "before:animate-backgroundPositionSpin", "after:absolute after:-left-[var(--border-size)] after:-top-[var(--border-size)] after:-z-10 after:block", "after:h-[var(--pseudo-element-height)] after:w-[var(--pseudo-element-width)] after:rounded-[var(--border-radius)] after:blur-[var(--after-blur)] after:content-['']", "after:bg-[linear-gradient(0deg,var(--neon-first-color),var(--neon-second-color))] after:bg-[length:100%_200%] after:overflow-visible after:opacity-80", "after:animate-backgroundPositionSpin", "dark:bg-neutral-900"), children: r }) }) }, Zk = () => { const [e, { open: t, close: n }] = ak(!1); G({ xs: "xs", sm: "sm", md: "md", lg: "lg" }); return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsxs)("div", { "data-aos": "zoom-out-up", "data-aos-duration": "800", className: "mt-28 flex relative overflow-hidden justify-around items-center font-mono px-10 py-10 sm-mx:px-4 xs-mx:px-2 xs-mx:py-4 h-fit lg-mx:justify-between bs-mx:flex-wrap bs-mx:flex-col-reverse bs-mx:!overflow-visible bs-mx:gap-6 md-mx:px-6", id: "About", children: [(0, v.jsx)(sk, { className: "absolute -z-20 inset-0", quantity: 1e3, ease: 80, vx: .1, vy: .1, color: "#64FFDA", refresh: !0 }), (0, v.jsxs)("div", { className: "bs:ml-10 bs:w-3/5 flex flex-col lg-mx:gap-3  bs-mx:items-center", children: [(0, v.jsx)("div", { className: "text-primaryColor text-3xl lg-mx:text-2xl xs-mx:text-xl xsm-mx:text-lg", children: "Hi, I am" }), (0, v.jsx)("div", { className: "text-white text-[4.25rem] font-extrabold lg-mx:text-5xl sm-mx:text-4xl xs-mx:text-3xl xsm-mx:text-[27px]", children: l.name }), (0, v.jsxs)("div", { className: "text-white text-4xl flex font-semibold lg-mx:text-[27px] sm-mx:text-2xl xs-mx:text-xl xsm-mx:text-lg", children: ["I'm a\xa0", (0, v.jsxs)("span", { className: "text-primaryColor", children: [(0, v.jsx)(m(), { options: { strings: l.stack, autoStart: !0, loop: !0 } }), " "] })] }), (0, v.jsx)("div", { className: "text-textColor text-xl w-[90%] text-justify my-8 lg-mx:my-0 font-semibold lg-mx:text-base sm-mx:text-sm xs-mx:text-xs", children: l.bio })] }), (0, v.jsx)("div", { className: "h-fit flex justify-center items-center rounded-full bs:mr-10 w-fit", children: (0, v.jsx)(Jk, { className: "w-[325px] h-[325px] lg-mx:w-64 lg-mx:h-64 xsm-mx:w-56 xsm-mx:h-56 items-center justify-center text-center", children: (0, v.jsx)("img", { className: "w-full  h-full rounded-full", src: "assets/profile.jpeg", alt: "profile" }) }) })] }), (0, v.jsx)(ik, { opened: e, close: n })] }) }; function eS(e) { let { color: t, theme: n, autoContrast: r } = e; if (!("boolean" === typeof r ? r : n.autoContrast)) return "var(--mantine-color-white)"; return M({ color: t || n.primaryColor, theme: n }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)" } function tS(e, t) { return eS({ color: e.colors[e.primaryColor][S(e, t)], theme: e, autoContrast: null }) } function nS(e, t) { return "boolean" === typeof e ? e : t.autoContrast } const [rS, iS] = Ae("Timeline component was not found in tree"); var aS = { root: "m_43657ece", itemTitle: "m_2ebe8099", item: "m_436178ff", itemBullet: "m_8affcee1", itemBody: "m_540e8f41" }; const sS = {}, oS = J(((e, t) => { const n = Q("TimelineItem", sS, e), { classNames: r, className: i, style: a, styles: s, vars: o, __active: l, __align: c, __lineActive: u, __vars: d, bullet: h, radius: f, color: p, lineVariant: m, children: g, title: b, mod: y, ...w } = n, x = iS(), _ = U(), k = { classNames: r, styles: s }; return (0, v.jsxs)(Se, { ...x.getStyles("item", { ...k, className: i, style: a }), mod: [{ "line-active": u, active: l }, y], ref: t, __vars: { "--tli-radius": f ? He(f) : void 0, "--tli-color": p ? T(p, _) : void 0, "--tli-border-style": m || void 0 }, ...w, children: [(0, v.jsx)(Se, { ...x.getStyles("itemBullet", k), mod: { "with-child": !!h, align: c, active: l }, children: h }), (0, v.jsxs)("div", { ...x.getStyles("itemBody", k), children: [b && (0, v.jsx)("div", { ...x.getStyles("itemTitle", k), children: b }), (0, v.jsx)("div", { ...x.getStyles("itemContent", k), children: g })] })] }) })); oS.classes = aS, oS.displayName = "@mantine/core/TimelineItem"; const lS = { active: -1, align: "left", reverseActive: !1 }, cS = (e, t) => { let { bulletSize: n, lineWidth: r, radius: i, color: a, autoContrast: s } = t; return { root: { "--tl-bullet-size": w(n), "--tl-line-width": w(r), "--tl-radius": void 0 === i ? void 0 : He(i), "--tl-color": a ? T(a, e) : void 0, "--tl-icon-color": nS(s, e) ? eS({ color: a, theme: e, autoContrast: s }) : void 0 } } }, uS = J(((e, n) => { const r = Q("Timeline", lS, e), { classNames: i, className: a, style: s, styles: o, unstyled: l, vars: c, children: u, active: d, color: h, radius: f, bulletSize: p, align: m, lineWidth: g, reverseActive: b, mod: y, autoContrast: w, ...x } = r, _ = rt({ name: "Timeline", classes: aS, props: r, className: a, style: s, classNames: i, styles: o, unstyled: l, vars: c, varsResolver: cS }), k = t.Children.toArray(u), S = k.map(((e, n) => { var r, i; return (0, t.cloneElement)(e, { unstyled: l, __align: m, __active: (null === (r = e.props) || void 0 === r ? void 0 : r.active) || (b ? d >= k.length - n - 1 : d >= n), __lineActive: (null === (i = e.props) || void 0 === i ? void 0 : i.lineActive) || (b ? d >= k.length - n - 1 : d - 1 >= n) }) })); return (0, v.jsx)(rS, { value: { getStyles: _ }, children: (0, v.jsx)(Se, { ..._("root"), mod: [{ align: m }, y], ref: n, ...x, children: S }) }) })); uS.classes = aS, uS.displayName = "@mantine/core/Timeline", uS.Item = oS; var dS = a("filled", "briefcase-filled", "IconBriefcaseFilled", [["path", { d: "M22 13.478v4.522a3 3 0 0 1 -3 3h-14a3 3 0 0 1 -3 -3v-4.522l.553 .277a20.999 20.999 0 0 0 18.897 -.002l.55 -.275zm-8 -11.478a3 3 0 0 1 3 3v1h2a3 3 0 0 1 3 3v2.242l-1.447 .724a19.002 19.002 0 0 1 -16.726 .186l-.647 -.32l-1.18 -.59v-2.242a3 3 0 0 1 3 -3h2v-1a3 3 0 0 1 3 -3h4zm-2 8a1 1 0 0 0 -1 1a1 1 0 1 0 2 .01c0 -.562 -.448 -1.01 -1 -1.01zm2 -6h-4a1 1 0 0 0 -1 1v1h6v-1a1 1 0 0 0 -1 -1z", key: "svg-0" }]]); const hS = e => { const t = G({ xs: 15, md: 20 }); return e.map(((e, n) => (0, v.jsx)(uS.Item, { "data-aos": "fade-up", "data-aos-duration": "800", className: "!pt-12 !mb-2 sm-mx:!p-1", bullet: (0, v.jsx)(dS, { className: "!text-bgColor", size: t }), children: (0, v.jsxs)("div", { className: "border shadow-[0_0_10px_0_#64FFDA50] hover:-translate-y-2 transition transform duration-300 ease-in-out flex flex-col gap-2 border-primaryColor p-4 rounded-2xl sm-mx:p-2", children: [(0, v.jsxs)("div", { className: "flex gap-2 items-center", children: [(0, v.jsx)("img", { className: "rounded-lg w-16 md-mx:w-14", src: "assets/company.png", alt: "Company" }), (0, v.jsxs)("div", { className: "flex flex-col", children: [(0, v.jsx)("div", { className: "text-white text-2xl font-semibold sm-mx:text-xl xs-mx:text-lg xsm-mx:text-base", children: e.role }), (0, v.jsxs)("div", { className: "text-lg font-semibold text-textColor md-mx:text-base sm-mx:text-sm xs-mx:text-xs", children: [e.company, " \u2022 ", e.date] })] })] }), (0, v.jsx)("div", { className: "text-textColor leading-6 text-justify md-mx:text-sm xs-mx:text-xs ", children: e.desc }), (0, v.jsxs)("div", { className: "text-lg font-medium text-textColor md-mx:text-base sm-mx:text-sm xs-mx:text-xs flex gap-1", children: [(0, v.jsx)("div", { className: "font-semibold text-white", children: "Skills:" }), (0, v.jsx)("div", { className: "flex gap-1 flex-wrap", children: e.skills.map(((e, t) => (0, v.jsxs)("div", { children: [" \u2022 ", e, " "] }, t))) })] })] }) }, n))) }, fS = () => { const e = G({ xs: 15, md: 20 }), t = G({ xs: 25, md: 30 }); return (0, v.jsxs)("div", { className: "px-16 mx-20 md-mx:px-6 sm-mx:px-2 lg-mx:mx-0 my-10 mb-28 font-mono", id: "Experience", children: [(0, v.jsxs)("h1", { className: "text-4xl sm-mx:text-3xl xs-mx:text-2xl  mb-10 font-bold text-center text-white", children: [(0, v.jsx)("span", { className: "text-primaryColor", children: "04.\xa0" }), "Experience"] }), (0, v.jsxs)(uS, { color: "#64FFDA", active: 5, bulletSize: t, lineWidth: 2, children: [hS(h), (0, v.jsx)(uS.Item, { bullet: (0, v.jsx)(dS, { className: "!text-bgColor", size: e }) })] })] }) }, pS = () => { const e = d.map(((e, t) => (0, v.jsx)("a", { href: "".concat(e.link), target: "_blank", className: "font-mono text-lg  hover:text-primaryColor hover:scale-105 transition transform duration-300 ease-in-out", children: (0, v.jsx)(e.icon, { stroke: 1.5, size: 25 }) }, t))); return (0, v.jsxs)("div", { className: "mt-20 mb-10 font-mono flex flex-col gap-2 items-center", children: [(0, v.jsx)("div", { className: "text-3xl md-mx:text-2xl text-primaryColor font-semibold", children: l.name }), (0, v.jsx)("div", { className: "md-mx:flex hidden text-textColor gap-8 sm-mx:gap-6", children: e }), (0, v.jsxs)("div", { className: "text-textColor text-xl md-mx:text-lg sm-mx:text-base xs-mx:text-sm xs-mx:flex flex-col items-center", children: ["Copyright \xa9 ", (new Date).getFullYear(), " ", l.name, " ", (0, v.jsx)("span", { className: "xs-mx:hidden", children: "|" }), " ", (0, v.jsx)("span", { children: "All Rights Reserved" })] })] }) }; var mS = a("outline", "hexagon-letter-a", "IconHexagonLetterA", [["path", { d: "M19.875 6.27a2.225 2.225 0 0 1 1.125 1.948v7.284c0 .809 -.443 1.555 -1.158 1.948l-6.75 4.27a2.269 2.269 0 0 1 -2.184 0l-6.75 -4.27a2.225 2.225 0 0 1 -1.158 -1.948v-7.285c0 -.809 .443 -1.554 1.158 -1.947l6.75 -3.98a2.33 2.33 0 0 1 2.25 0l6.75 3.98h-.033z", key: "svg-0" }], ["path", { d: "M10 16v-6a2 2 0 1 1 4 0v6", key: "svg-1" }], ["path", { d: "M10 13h4", key: "svg-2" }]]); const [gS, vS] = Ae("Drawer component was not found in tree"); var bS = { root: "m_f11b401e", header: "m_5a7c2c9", content: "m_b8a05bbd", inner: "m_31cd769a" }; const yS = {}, wS = J(((e, t) => { const n = Q("DrawerBody", yS, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = vS(); return (0, v.jsx)(Ie, { ref: t, ...c.getStyles("body", { classNames: r, style: a, styles: s, className: i }), ...l }) })); wS.classes = bS, wS.displayName = "@mantine/core/DrawerBody"; const xS = {}, _S = J(((e, t) => { const n = Q("DrawerCloseButton", xS, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = vS(); return (0, v.jsx)(ft, { ref: t, ...c.getStyles("close", { classNames: r, style: a, styles: s, className: i }), ...l }) })); _S.classes = bS, _S.displayName = "@mantine/core/DrawerCloseButton"; const kS = {}, SS = J(((e, t) => { const n = Q("DrawerContent", kS, e), { classNames: r, className: i, style: a, styles: s, vars: o, children: l, radius: c, ...u } = n, d = vS(), h = d.scrollAreaComponent || Xt; return (0, v.jsx)(Gt, { ...d.getStyles("content", { className: i, style: a, styles: s, classNames: r }), innerProps: d.getStyles("inner", { className: i, style: a, styles: s, classNames: r }), ref: t, ...u, radius: c || d.radius || 0, children: (0, v.jsx)(h, { style: { height: "calc(100vh - var(--drawer-offset) * 2)" }, children: l }) }) })); SS.classes = bS, SS.displayName = "@mantine/core/DrawerContent"; const AS = {}, ES = J(((e, t) => { const n = Q("DrawerHeader", AS, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = vS(); return (0, v.jsx)(Qt, { ref: t, ...c.getStyles("header", { classNames: r, style: a, styles: s, className: i }), ...l }) })); ES.classes = bS, ES.displayName = "@mantine/core/DrawerHeader"; const CS = {}, MS = J(((e, t) => { const n = Q("DrawerOverlay", CS, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = vS(); return (0, v.jsx)(an, { ref: t, ...c.getStyles("overlay", { classNames: r, style: a, styles: s, className: i }), ...l }) })); function TS(e) { switch (e) { case "top": return "flex-start"; case "bottom": return "flex-end"; default: return } } function PS(e) { if ("top" === e || "bottom" === e) return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)" } MS.classes = bS, MS.displayName = "@mantine/core/DrawerOverlay"; const RS = { top: "slide-down", bottom: "slide-up", left: "slide-right", right: "slide-left" }, NS = { top: "slide-down", bottom: "slide-up", right: "slide-right", left: "slide-left" }, LS = { closeOnClickOutside: !0, withinPortal: !0, lockScroll: !0, trapFocus: !0, returnFocus: !0, closeOnEscape: !0, keepMounted: !1, zIndex: Y("modal"), position: "left" }, IS = (e, t) => { let { position: n, size: r, offset: i } = t; return { root: { "--drawer-size": We(r, "drawer-size"), "--drawer-flex": PS(n), "--drawer-height": "left" === n || "right" === n ? void 0 : "var(--drawer-size)", "--drawer-align": TS(n), "--drawer-justify": "right" === n ? "flex-end" : void 0, "--drawer-offset": w(i) } } }, DS = J(((e, t) => { const n = Q("DrawerRoot", LS, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, scrollAreaComponent: c, position: u, transitionProps: d, radius: h, ...f } = n, { dir: p } = Ar(), m = rt({ name: "Drawer", classes: bS, props: n, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: l, varsResolver: IS }), g = ("rtl" === p ? NS : RS)[u]; return (0, v.jsx)(gS, { value: { scrollAreaComponent: c, getStyles: m, radius: h }, children: (0, v.jsx)(sr, { ref: t, ...m("root"), transitionProps: { transition: g, ...d }, unstyled: o, ...f }) }) })); DS.classes = bS, DS.displayName = "@mantine/core/DrawerRoot"; const OS = {}, jS = J(((e, t) => { const n = Q("DrawerTitle", OS, e), { classNames: r, className: i, style: a, styles: s, vars: o, ...l } = n, c = vS(); return (0, v.jsx)(ur, { ref: t, ...c.getStyles("title", { classNames: r, style: a, styles: s, className: i }), ...l }) })); jS.classes = bS, jS.displayName = "@mantine/core/DrawerTitle"; const FS = { closeOnClickOutside: !0, withinPortal: !0, lockScroll: !0, trapFocus: !0, returnFocus: !0, closeOnEscape: !0, keepMounted: !1, zIndex: Y("modal"), withOverlay: !0, withCloseButton: !0 }, zS = J(((e, t) => { const { title: n, withOverlay: r, overlayProps: i, withCloseButton: a, closeButtonProps: s, children: o, ...l } = Q("Drawer", FS, e), c = !!n || a; return (0, v.jsxs)(DS, { ref: t, ...l, children: [r && (0, v.jsx)(MS, { ...i }), (0, v.jsxs)(SS, { children: [c && (0, v.jsxs)(ES, { children: [n && (0, v.jsx)(jS, { children: n }), a && (0, v.jsx)(_S, { ...s })] }), (0, v.jsx)(wS, { children: o })] })] }) })); zS.classes = bS, zS.displayName = "@mantine/core/Drawer", zS.Root = DS, zS.Overlay = MS, zS.Content = SS, zS.Body = wS, zS.Header = ES, zS.Title = jS, zS.CloseButton = _S; var WS = { root: "m_fea6bf1a", burger: "m_d4fb9cad" }; const BS = {}, HS = (e, t) => { let { color: n, size: r, lineSize: i, transitionDuration: a, transitionTimingFunction: s } = t; return { root: { "--burger-color": n ? T(n, e) : void 0, "--burger-size": We(r, "burger-size"), "--burger-line-size": i ? w(i) : void 0, "--burger-transition-duration": void 0 === a ? void 0 : "".concat(a, "ms"), "--burger-transition-timing-function": s } } }, US = J(((e, t) => { const n = Q("Burger", BS, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, opened: c, children: u, transitionDuration: d, transitionTimingFunction: h, lineSize: f, ...p } = n, m = rt({ name: "Burger", classes: WS, props: n, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: l, varsResolver: HS }); return (0, v.jsxs)(ot, { ...m("root"), ref: t, ...p, children: [(0, v.jsx)(Se, { mod: ["reduce-motion", { opened: c }], ...m("burger") }), u] }) })); US.classes = WS, US.displayName = "@mantine/core/Burger"; const VS = () => { const [e, { toggle: t }] = ak(!1), n = G({ xs: "md", sm: "lg" }); return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsxs)(zS.Root, { className: "bs:hidden !-z-10", position: "right", opened: e, onClose: t, size: "50vw", children: [(0, v.jsx)(zS.Overlay, { className: "!-z-0 !backdrop-opacity-85 blur-sm" }), (0, v.jsx)(zS.Content, { className: "!-z-0", bg: "#112240", children: (0, v.jsx)(zS.Body, { className: "mt-20 xs:mt-24  flex flex-col gap-5", bg: "#112240", children: GS(!0, t) }) })] }), (0, v.jsx)(US, { className: "bs:!hidden !z-50 relative", size: n, color: "#64FFDA", opened: e, onClick: t })] }) }, qS = ["About", "Projects", "Skills", "Experience"], GS = (e, t) => { const n = () => { t && t() }; return qS.map(((t, r) => (0, v.jsxs)("a", { onClick: n, className: "".concat(e ? "flex flex-col items-center" : "", " text-textColor text-lg font-mono hover:text-primaryColor"), href: "#".concat(t), children: [(0, v.jsxs)("span", { className: "text-primaryColor", children: ["0", r + 1, ". "] }), t] }, r))) }, XS = () => { const e = g("(max-width: ".concat(x(476), ")")), [n, r] = (0, t.useState)(!0), [i, a] = (0, t.useState)(0), [s, o] = (0, t.useState)(!1), l = () => { window.scrollY > i && window.scrollY > 70 ? r(!1) : r(!0), window.scrollY > 70 ? o(!0) : o(!1), a(window.scrollY) }; return (0, t.useEffect)((() => (window.addEventListener("scroll", l), () => window.removeEventListener("scroll", l)))), (0, v.jsxs)("nav", { className: "flex ".concat(n ? "translate-y-0" : "-translate-y-28", " ").concat(s ? "shadow-[0px_10px_30px_-10px_#020c1b]" : "", " transition-transform duration-500 ease-in-out fixed w-full z-10 bg-bgColor h-28  px-10  justify-between items-center xs-mx:px-4 xs-mx:h-20 "), children: [(0, v.jsx)(mS, { className: "z-10", size: e ? 45 : 60, color: "#64FFDA", stroke: 1.25 }), (0, v.jsx)("div", { className: "bs:flex gap-8 hidden", children: GS(!1, null) }), (0, v.jsx)(VS, {})] }) }; var YS = a("outline", "hexagon", "IconHexagon", [["path", { d: "M19.875 6.27a2.225 2.225 0 0 1 1.125 1.948v7.284c0 .809 -.443 1.555 -1.158 1.948l-6.75 4.27a2.269 2.269 0 0 1 -2.184 0l-6.75 -4.27a2.225 2.225 0 0 1 -1.158 -1.948v-7.285c0 -.809 .443 -1.554 1.158 -1.947l6.75 -3.98a2.33 2.33 0 0 1 2.25 0l6.75 3.98h-.033z", key: "svg-0" }]]), KS = ["light", "dark"], QS = "(prefers-color-scheme: dark)", $S = t.createContext(void 0), JS = { setTheme: e => { }, themes: [] }, ZS = () => { var e; return null != (e = t.useContext($S)) ? e : JS }, eA = (t.memo((e => { let { forcedTheme: n, storageKey: r, attribute: i, enableSystem: a, enableColorScheme: s, defaultTheme: o, value: l, attrs: c, nonce: u } = e, d = "system" === o, h = "class" === i ? "var d=document.documentElement,c=d.classList;".concat("c.remove(".concat(c.map((e => "'".concat(e, "'"))).join(","), ")"), ";") : "var d=document.documentElement,n='".concat(i, "',s='setAttribute';"), f = s ? KS.includes(o) && o ? "if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'".concat(o, "'") : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", p = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r = l ? l[e] : e, a = t ? e + "|| ''" : "'".concat(r, "'"), o = ""; return s && n && !t && KS.includes(e) && (o += "d.style.colorScheme = '".concat(e, "';")), "class" === i ? o += t || r ? "c.add(".concat(a, ")") : "null" : r && (o += "d[s](n,".concat(a, ")")), o }, m = n ? "!function(){".concat(h).concat(p(n), "}()") : a ? "!function(){try{".concat(h, "var e=localStorage.getItem('").concat(r, "');if('system'===e||(!e&&").concat(d, ")){var t='").concat(QS, "',m=window.matchMedia(t);if(m.media!==t||m.matches){").concat(p("dark"), "}else{").concat(p("light"), "}}else if(e){").concat(l ? "var x=".concat(JSON.stringify(l), ";") : "").concat(p(l ? "x[e]" : "e", !0), "}").concat(d ? "" : "else{" + p(o, !1, !1) + "}").concat(f, "}catch(e){}}()") : "!function(){try{".concat(h, "var e=localStorage.getItem('").concat(r, "');if(e){").concat(l ? "var x=".concat(JSON.stringify(l), ";") : "").concat(p(l ? "x[e]" : "e", !0), "}else{").concat(p(o, !1, !1), ";}").concat(f, "}catch(t){}}();"); return t.createElement("script", { nonce: u, dangerouslySetInnerHTML: { __html: m } }) })), __webpack_require__(360)); const tA = { containerProps: { style: { display: "flex", justifyContent: "center", alignItems: "center", width: "100%", paddingTop: 40 } }, options: { reverse: !0, depth: 1, wheelZoom: !1, imageScale: 2, activeCursor: "default", tooltip: "native", initial: [.1, -.1], clickToFront: 500, tooltipDelay: 0, outlineColour: "#0000", maxSpeed: .07, minSpeed: .05 } }, nA = (e, t) => { const n = "light" === t ? "#f3f2ef" : "#080510", r = "light" === t ? "#6e6e73" : "#ffffff", i = "dark" === t ? 2 : 1.2; return (0, eA.ci)({ icon: e, bgHex: n, fallbackHex: r, minContrastRatio: i, size: 50, aProps: { href: void 0, target: void 0, rel: void 0, onClick: e => e.preventDefault() } }) }; function rA(e) { let { iconSlugs: n } = e; const [r, i] = (0, t.useState)(null), { theme: a } = ZS(); (0, t.useEffect)((() => { (0, eA.fB)({ slugs: n }).then(i) }), [n]); const s = (0, t.useMemo)((() => r ? Object.values(r.simpleIcons).map((e => nA(e, a || "light"))) : null), [r, a]); return (0, v.jsxs)(eA.Es, { ...tA, children: ["// @ts-ignore", (0, v.jsx)(v.Fragment, { children: s })] }) } function iA() { return (0, v.jsxs)("div", { className: "relative flex h-full w-full animate-[ping_1.5s_ease-in-out_1_4.5s] items-center justify-center", children: [(0, v.jsx)(rA, { iconSlugs: f }), (0, v.jsx)(YS, { className: "absolute -z-10 animate-[spin_5s_linear_infinite]", size: 120, color: "#64FFDA", stroke: 1.25 }), (0, v.jsx)("div", { className: " absolute font-mono text-primaryColor font-semibold text-6xl -z-10", children: "AC" })] }) } const aA = () => (0, v.jsxs)("div", { className: "flex md-mx:hidden text-textColor items-center gap-10 fixed bottom-32 -right-48 rotate-90", children: [(0, v.jsx)("div", { className: "flex", "data-aos-duration": "800", "data-aos": "fade-down-left", children: (0, v.jsx)("a", { href: "mailto:aasmideveloper@gmail.com", className: "font-mono tracking-wide hover:text-primaryColor hover:-translate-x-1 transition transform duration-300 ease-in-out", children: "aasmideveloper@gmail.com" }) }), (0, v.jsx)("hr", { className: "border w-40 rounded-full  bg-textColor border-textColor" })] }), [sA, oA] = Ae("Card component was not found in tree"); var lA = { root: "m_e615b15f", section: "m_599a2148" }; const cA = {}, uA = it(((e, t) => { const n = Q("CardSection", cA, e), { classNames: r, className: i, style: a, styles: s, vars: o, withBorder: l, inheritPadding: c, mod: u, ...d } = n, h = oA(); return (0, v.jsx)(Se, { ref: t, mod: [{ "with-border": l, "inherit-padding": c }, u], ...h.getStyles("section", { className: i, style: a, styles: s, classNames: r }), ...d }) })); uA.classes = lA, uA.displayName = "@mantine/core/CardSection"; const dA = {}, hA = (e, t) => { let { padding: n } = t; return { root: { "--card-padding": Be(n) } } }, fA = it(((e, n) => { const r = Q("Card", dA, e), { classNames: i, className: a, style: s, styles: o, unstyled: l, vars: c, children: u, padding: d, ...h } = r, f = rt({ name: "Card", props: r, classes: lA, className: a, style: s, classNames: i, styles: o, unstyled: l, vars: c, varsResolver: hA }), p = t.Children.toArray(u), m = p.map(((e, n) => "object" === typeof e && e && "type" in e && e.type === uA ? (0, t.cloneElement)(e, { "data-first-section": 0 === n || void 0, "data-last-section": n === p.length - 1 || void 0 }) : e)); return (0, v.jsx)(sA, { value: { getStyles: f }, children: (0, v.jsx)(Ot, { ref: n, unstyled: l, ...f("root"), ...h, children: m }) }) })); fA.classes = lA, fA.displayName = "@mantine/core/Card", fA.Section = uA; var pA = { root: "m_9e117634" }; const mA = {}, gA = (e, t) => { let { radius: n, fit: r } = t; return { root: { "--image-radius": void 0 === n ? void 0 : He(n), "--image-object-fit": r } } }, vA = it(((e, n) => { const r = Q("Image", mA, e), { classNames: i, className: a, style: s, styles: o, unstyled: l, vars: c, onError: u, src: d, radius: h, fit: f, fallbackSrc: p, mod: m, ...g } = r, [b, y] = (0, t.useState)(!d); (0, t.useEffect)((() => y(!d)), [d]); const w = rt({ name: "Image", classes: pA, props: r, className: a, style: s, classNames: i, styles: o, unstyled: l, vars: c, varsResolver: gA }); return b && p ? (0, v.jsx)(Se, { component: "img", ref: n, src: p, ...w("root"), onError: u, mod: ["fallback", m], ...g }) : (0, v.jsx)(Se, { component: "img", ref: n, ...w("root"), src: d, onError: e => { null === u || void 0 === u || u(e), y(!0) }, mod: m, ...g }) })); vA.classes = pA, vA.displayName = "@mantine/core/Image"; var bA = { root: "m_4081bf90" }; const yA = { preventGrowOverflow: !0, gap: "md", align: "center", justify: "flex-start", wrap: "wrap" }, wA = (e, t, n) => { let { grow: r, preventGrowOverflow: i, gap: a, align: s, justify: o, wrap: l } = t, { childWidth: c } = n; return { root: { "--group-child-width": r && i ? c : void 0, "--group-gap": Be(a), "--group-align": s, "--group-justify": o, "--group-wrap": l } } }, xA = J(((e, n) => { const r = Q("Group", yA, e), { classNames: i, className: a, style: s, styles: o, unstyled: l, children: c, gap: u, align: d, justify: h, wrap: f, grow: p, preventGrowOverflow: m, vars: g, variant: b, __size: y, mod: w, ...x } = r, _ = function (e) { return t.Children.toArray(e).filter(Boolean) }(c), k = _.length, S = Be(null !== u && void 0 !== u ? u : "md"), A = rt({ name: "Group", props: r, stylesCtx: { childWidth: "calc(".concat(100 / k, "% - (").concat(S, " - ").concat(S, " / ").concat(k, "))") }, className: a, style: s, classes: bA, classNames: i, styles: o, unstyled: l, vars: g, varsResolver: wA }); return (0, v.jsx)(Se, { ...A("root"), ref: n, variant: b, mod: [{ grow: p }, w], size: y, ...x, children: _ }) })); xA.classes = bA, xA.displayName = "@mantine/core/Group"; var _A = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" }; const kA = {}, SA = (e, t) => { let { radius: n, color: r, gradient: i, variant: a, size: s, autoContrast: o } = t; const l = e.variantColorResolver({ color: r || e.primaryColor, theme: e, gradient: i, variant: a || "filled", autoContrast: o }); return { root: { "--badge-height": We(s, "badge-height"), "--badge-padding-x": We(s, "badge-padding-x"), "--badge-fz": We(s, "badge-fz"), "--badge-radius": void 0 === n ? void 0 : He(n), "--badge-bg": r || a ? l.background : void 0, "--badge-color": r || a ? l.color : void 0, "--badge-bd": r || a ? l.border : void 0, "--badge-dot-color": "dot" === a ? T(r, e) : void 0 } } }, AA = it(((e, t) => { const n = Q("Badge", kA, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, radius: c, color: u, gradient: d, leftSection: h, rightSection: f, children: p, variant: m, fullWidth: g, autoContrast: b, circle: y, mod: w, ...x } = n, _ = rt({ name: "Badge", props: n, classes: _A, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: l, varsResolver: SA }); return (0, v.jsxs)(Se, { variant: m, mod: [{ block: g, circle: y }, w], ..._("root", { variant: m }), ref: t, ...x, children: [h && (0, v.jsx)("span", { ..._("section"), "data-position": "left", children: h }), (0, v.jsx)("span", { ..._("label"), children: p }), f && (0, v.jsx)("span", { ..._("section"), "data-position": "right", children: f })] }) })); AA.classes = _A, AA.displayName = "@mantine/core/Badge"; var EA = { root: "m_b6d8b162" }; function CA(e) { return "start" === e ? "start" : "end" === e || e ? "end" : void 0 } const MA = { inherit: !1 }, TA = (e, t) => { let { variant: n, lineClamp: r, gradient: i, size: a, color: s } = t; return { root: { "--text-fz": Ue(a), "--text-lh": Ve(a), "--text-gradient": "gradient" === n ? P(i, e) : void 0, "--text-line-clamp": "number" === typeof r ? r.toString() : void 0, "--text-color": s ? T(s, e) : void 0 } } }, PA = it(((e, t) => { const n = Q("Text", MA, e), { lineClamp: r, truncate: i, inline: a, inherit: s, gradient: o, span: l, __staticSelector: c, vars: u, className: d, style: h, classNames: f, styles: p, unstyled: m, variant: g, mod: b, size: y, ...w } = n, x = rt({ name: ["Text", c], props: n, classes: EA, className: d, style: h, classNames: f, styles: p, unstyled: m, vars: u, varsResolver: TA }); return (0, v.jsx)(Se, { ...x("root", { focusable: !0 }), ref: t, component: l ? "span" : "p", variant: g, mod: [{ "data-truncate": CA(i), "data-line-clamp": "number" === typeof r, "data-inline": a, "data-inherit": s }, b], size: y, ...w }) })); PA.classes = EA, PA.displayName = "@mantine/core/Text"; var RA = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844" }; const NA = { orientation: "horizontal" }, LA = (e, t) => { let { borderWidth: n } = t; return { group: { "--button-border-width": w(n) } } }, IA = J(((e, t) => { const n = Q("ButtonGroup", NA, e), { className: r, style: i, classNames: a, styles: s, unstyled: o, orientation: l, vars: c, borderWidth: u, variant: d, mod: h, ...f } = Q("ButtonGroup", NA, e), p = rt({ name: "ButtonGroup", props: n, classes: RA, className: r, style: i, classNames: a, styles: s, unstyled: o, vars: c, varsResolver: LA, rootSelector: "group" }); return (0, v.jsx)(Se, { ...p("group"), ref: t, variant: d, mod: [{ "data-orientation": l }, h], role: "group", ...f }) })); IA.classes = RA, IA.displayName = "@mantine/core/ButtonGroup"; const DA = { in: { opacity: 1, transform: "translate(-50%, calc(-50% + ".concat(w(1), "))") }, out: { opacity: 0, transform: "translate(-50%, -200%)" }, common: { transformOrigin: "center" }, transitionProperty: "transform, opacity" }, OA = {}, jA = (e, t) => { let { radius: n, color: r, gradient: i, variant: a, size: s, justify: o, autoContrast: l } = t; const c = e.variantColorResolver({ color: r || e.primaryColor, theme: e, gradient: i, variant: a || "filled", autoContrast: l }); return { root: { "--button-justify": o, "--button-height": We(s, "button-height"), "--button-padding-x": We(s, "button-padding-x"), "--button-fz": null !== s && void 0 !== s && s.includes("compact") ? Ue(s.replace("compact-", "")) : Ue(s), "--button-radius": void 0 === n ? void 0 : He(n), "--button-bg": r || a ? c.background : void 0, "--button-hover": r || a ? c.hover : void 0, "--button-color": c.color, "--button-bd": r || a ? c.border : void 0, "--button-hover-color": r || a ? c.hoverColor : void 0 } } }, FA = it(((e, t) => { const n = Q("Button", OA, e), { style: r, vars: i, className: a, color: s, disabled: o, children: l, leftSection: c, rightSection: u, fullWidth: d, variant: h, radius: f, loading: p, loaderProps: m, gradient: g, classNames: b, styles: y, unstyled: w, "data-disabled": x, autoContrast: _, mod: k, ...S } = n, A = rt({ name: "Button", props: n, classes: RA, className: a, style: r, classNames: b, styles: y, unstyled: w, vars: i, varsResolver: jA }), E = !!c, C = !!u; return (0, v.jsxs)(ot, { ref: t, ...A("root", { active: !o && !p && !x }), unstyled: w, variant: h, disabled: o || p, mod: [{ disabled: o || x, loading: p, block: d, "with-left-section": E, "with-right-section": C }, k], ...S, children: [(0, v.jsx)(qt, { mounted: !!p, transition: DA, duration: 150, children: e => (0, v.jsx)(Se, { component: "span", ...A("loader", { style: e }), "aria-hidden": !0, children: (0, v.jsx)(Ws, { color: "var(--button-color)", size: "calc(var(--button-height) / 1.8)", ...m }) }) }), (0, v.jsxs)("span", { ...A("inner"), children: [c && (0, v.jsx)(Se, { component: "span", ...A("section"), mod: { position: "left" }, children: c }), (0, v.jsx)(Se, { component: "span", mod: { loading: p }, ...A("label"), children: l }), u && (0, v.jsx)(Se, { component: "span", ...A("section"), mod: { position: "right" }, children: u })] })] }) })); function zA() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "top-end"; const t = { "--indicator-top": void 0, "--indicator-bottom": void 0, "--indicator-left": void 0, "--indicator-right": void 0, "--indicator-translate-x": void 0, "--indicator-translate-y": void 0 }, n = w(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0), [r, i] = e.split("-"); return "top" === r && (t["--indicator-top"] = n, t["--indicator-translate-y"] = "-50%"), "middle" === r && (t["--indicator-top"] = "50%", t["--indicator-translate-y"] = "-50%"), "bottom" === r && (t["--indicator-bottom"] = n, t["--indicator-translate-y"] = "50%"), "start" === i && (t["--indicator-left"] = n, t["--indicator-translate-x"] = "-50%"), "center" === i && (t["--indicator-left"] = "50%", t["--indicator-translate-x"] = "-50%"), "end" === i && (t["--indicator-right"] = n, t["--indicator-translate-x"] = "50%"), t } FA.classes = RA, FA.displayName = "@mantine/core/Button", FA.Group = IA; var WA = { root: "m_e5262200", indicator: "m_760d1fb1", processing: "m_885901b1" }; const BA = { position: "top-end", offset: 0, inline: !1, withBorder: !1, disabled: !1, processing: !1 }, HA = (e, t) => { let { color: n, position: r, offset: i, size: a, radius: s, zIndex: o, autoContrast: l } = t; return { root: { "--indicator-color": n ? T(n, e) : void 0, "--indicator-text-color": nS(l, e) ? eS({ color: n, theme: e, autoContrast: l }) : void 0, "--indicator-size": w(a), "--indicator-radius": void 0 === s ? void 0 : He(s), "--indicator-z-index": null === o || void 0 === o ? void 0 : o.toString(), ...zA(r, i) } } }, UA = J(((e, t) => { const n = Q("Indicator", BA, e), { classNames: r, className: i, style: a, styles: s, unstyled: o, vars: l, children: c, position: u, offset: d, inline: h, label: f, radius: p, color: m, withBorder: g, disabled: b, processing: y, zIndex: w, autoContrast: x, mod: _, ...k } = n, S = rt({ name: "Indicator", classes: WA, props: n, className: i, style: a, classNames: r, styles: s, unstyled: o, vars: l, varsResolver: HA }); return (0, v.jsxs)(Se, { ref: t, ...S("root"), mod: [{ inline: h }, _], ...k, children: [!b && (0, v.jsx)(v.Fragment, { children: (0, v.jsx)(Se, { mod: { "with-label": !!f, "with-border": g, processing: y }, ...S("indicator"), children: f }) }), c] }) })); UA.classes = WA, UA.displayName = "@mantine/core/Indicator"; const VA = e => { const t = G({ xs: "xs", md: "sm", lg: "md", bs: "lg" }), n = G({ xs: "md", sm: "md", md: "lg", bs: "xl" }); G({ xs: "xs", sm: "sm", md: "md", lg: "lg" }); return (0, v.jsxs)(pr.Root, { scrollAreaComponent: Kr.Autosize, size: "auto", centered: !0, className: " font-mono", opened: e.opened, onClose: e.close, children: [(0, v.jsx)(pr.Overlay, { className: "!backdrop-opacity-85 blur-sm" }), (0, v.jsxs)(pr.Content, { className: "!rounded-3xl", children: [(0, v.jsxs)(pr.Header, { className: "!bg-bgColor xs-mx:!p-2  !border-primaryColor  !border-2 !border-b-0 !rounded-tl-3xl !rounded-tr-3xl", children: [(0, v.jsxs)(pr.Title, { "data-autofocus": !0, className: "!text-4xl sm-mx:!text-3xl xs-mx:!text-2xl xsm-mx:!text-xl text-white flex gap-3 xs-mx:gap-1 items-center !font-bold", children: [e.title, !0 === e.live && (0, v.jsx)(AA, { className: "flex items-center gap-1", size: t, variant: "outline", color: "red", rightSection: (0, v.jsx)(UA, { color: "red", position: "middle-end", size: 10, processing: !0 }), children: "Live" })] }), (0, v.jsx)(pr.CloseButton, { size: "md", iconSize: "30px", className: "!bg-bgColor !text-red-500" })] }), (0, v.jsxs)(pr.Body, { className: "!bg-bgColor xs-mx:!p-2 !pt-2 !border-primaryColor  !border-2 !border-t-0 !rounded-bl-3xl !rounded-br-3xl", children: [(0, v.jsx)(vA, { className: "!rounded-xl !shadow-[0_0_5px_0_#64FFDA]", src: e.image, alt: e.image }), (0, v.jsx)("div", { className: "flex flex-wrap gap-3 xs-mx:gap-2 my-3", children: e.technologies.map(((e, t) => (0, v.jsx)(AA, { size: n, variant: "light", color: "#64FFDA", children: e }, t))) }), (0, v.jsx)(PA, { className: "!text-justify !text-lg sm-mx:!text-base xs-mx:!text-xs", c: "dimmed", children: e.desc })] })] })] }) }, qA = e => { const [t, { open: n, close: r }] = ak(!1), i = G({ xsm: "sm", md: "md", lg: "lg" }); G({ xs: "xs", sm: "sm", md: "md" }); return (0, v.jsxs)("div", { className: "w-[32%] lg-mx:w-[46%] md-mx:w-[48%] sm-mx:w-[90%] xs-mx:w-full", "data-aos": "fade-up", "data-aos-duration": "800", children: [(0, v.jsxs)(fA, { onClick: n, className: "!bg-bgColor cursor-pointer transition-transform duration-300 ease-in-out hover:!scale-[1.02] mb-5 hover:!shadow-[0_0_10px_1px_#64FFDA80] xs-mx:!shadow-[0_0_10px_1px_#64FFDA80] !border-primaryColor border-2", shadow: "lg", padding: "sm", radius: "lg", withBorder: !0, children: [(0, v.jsx)(fA.Section, { className: "p-3", children: (0, v.jsx)(vA, { className: "!rounded-xl !shadow-[0_0_5px_0_#64FFDA]", src: e.image, alt: e.image }) }), (0, v.jsx)(xA, { justify: "space-between", mt: "xs", mb: "xs", children: (0, v.jsx)("div", { className: "!text-2xl gap-2 !font-bold !text-white flex items-center sm-mx:!text-xl", children: e.title }) }), (0, v.jsx)(xA, { mb: "sm", className: "!gap-2", children: e.technologies.map(((e, t) => t < 3 && (0, v.jsx)(AA, { size: i, variant: "light", color: "#64FFDA", children: e }, t))) }), (0, v.jsx)(PA, { className: "!text-justify !text-sm xs-mx:!text-xs", lineClamp: 5, size: "sm", c: "dimmed", children: e.desc }), (0, v.jsx)(FA, { onClick: n, className: "", color: "#64FFDA", variant: "outline", mt: "md", radius: "md", children: "Show More" })] }), (0, v.jsx)(VA, { opened: t, close: r, title: e.title, desc: e.desc, technologies: e.technologies })] }) }, GA = () => (0, v.jsxs)("div", { className: "px-16  my-10 font-mono md-mx:px-6", id: "Projects", children: [(0, v.jsxs)("h1", { className: "text-4xl sm-mx:text-3xl xs-mx:text-2xl text-center mb-10 font-bold text-white", children: [(0, v.jsx)("span", { className: "text-primaryColor", children: "02.\xa0" }), "Projects"] }), (0, v.jsx)("div", { className: "flex flex-wrap justify-around md-mx:justify-between sm-mx:justify-center gap-4 md-mx:gap-2", children: c.map(((e, t) => (0, v.jsx)(qA, { title: e.title, desc: e.desc, technologies: e.technologies }, t))) })] }), XA = e => { return (0, v.jsxs)("div", { "data-aos": "fade-up", "data-aos-duration": "800", "data-aos-easing": "ease-in-sine", className: "w-[47%] shadow-[0_0_10px_0_#64FFDA50] rounded-3xl  mb-3 border border-primaryColor p-5 bs-mx:p-3 sm-mx:w-full ", children: [(0, v.jsx)("div", { className: "text-3xl mb-4 text-white text-center sm-mx:text-2xl xs-mx:text-xal font-bold ", children: e.title }), (0, v.jsx)("div", { className: "flex gap-3 bs-mx:gap-2 justify-center flex-wrap", children: (t = e.skills, t.map(((e, t) => (0, v.jsx)("div", { className: "flex gap-2 border border-textColor rounded-2xl items-center py-2 px-3 bs-mx:py-0 bs-mx:px-1.5 bs-mx:gap-1 mb-1", children: (0, v.jsx)("div", { className: "text-textColor text-xl font-medium sm-mx:text-lg xs-mx:text-sm ", children: e }) }, t)))) })] }); var t }, YA = () => (0, v.jsxs)("div", { className: "px-16 md-mx:px-6 my-10 font-mono", id: "Skills", children: [(0, v.jsxs)("h1", { className: "text-4xl sm-mx:text-3xl xs-mx:text-2xl mb-10 font-bold text-center text-white", children: [(0, v.jsx)("span", { className: "text-primaryColor", children: "03.\xa0" }), "Skills"] }), (0, v.jsx)("div", { className: "flex flex-wrap justify-around md-mx:justify-between sm-mx:justify-center gap-4 md-mx:gap-2", children: u.map(((e, t) => (0, v.jsx)(XA, { title: e.title, skills: e.skills }, t))) })] }), KA = () => { const e = d.map(((e, t) => (0, v.jsx)("a", { href: "".concat(e.link), target: "_blank", className: "font-mono text-lg  hover:text-primaryColor hover:-translate-x-1 transition transform duration-300 ease-in-out", children: (0, v.jsxs)("div", { "data-aos": "fade-up-left", "data-aos-duration": "800", children: [" ", (0, v.jsx)(e.icon, { stroke: 1.5, className: "-rotate-90", size: 25 })] }) }, t))); return (0, v.jsxs)("div", { className: "flex md-mx:hidden text-textColor items-center gap-8 fixed bottom-32 -left-48 rotate-90 ", children: [e, (0, v.jsx)("hr", { className: "border w-40 rounded-full  bg-textColor border-textColor" })] }) }; function QA(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })) } let $A = { data: "" }, JA = e => "object" == typeof window ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || $A, ZA = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, eE = /\/\*[^]*?\*\/|  +/g, tE = /\n+/g, nE = (e, t) => { let n = "", r = "", i = ""; for (let a in e) { let s = e[a]; "@" == a[0] ? "i" == a[1] ? n = a + " " + s + ";" : r += "f" == a[1] ? nE(s, a) : a + "{" + nE(s, "k" == a[1] ? "" : t) + "}" : "object" == typeof s ? r += nE(s, t ? t.replace(/([^,])+/g, (e => a.replace(/(^:.*)|([^,])+/g, (t => /&/.test(t) ? t.replace(/&/g, e) : e ? e + " " + t : t)))) : a) : null != s && (a = /^--/.test(a) ? a : a.replace(/[A-Z]/g, "-$&").toLowerCase(), i += nE.p ? nE.p(a, s) : a + ":" + s + ";") } return n + (t && i ? t + "{" + i + "}" : i) + r }, rE = {}, iE = e => { if ("object" == typeof e) { let t = ""; for (let n in e) t += n + iE(e[n]); return t } return e }, aE = (e, t, n, r, i) => { let a = iE(e), s = rE[a] || (rE[a] = (e => { let t = 0, n = 11; for (; t < e.length;)n = 101 * n + e.charCodeAt(t++) >>> 0; return "go" + n })(a)); if (!rE[s]) { let t = a !== e ? e : (e => { let t, n, r = [{}]; for (; t = ZA.exec(e.replace(eE, ""));)t[4] ? r.shift() : t[3] ? (n = t[3].replace(tE, " ").trim(), r.unshift(r[0][n] = r[0][n] || {})) : r[0][t[1]] = t[2].replace(tE, " ").trim(); return r[0] })(e); rE[s] = nE(i ? { ["@keyframes " + s]: t } : t, n ? "" : "." + s) } let o = n && rE.g ? rE.g : null; return n && (rE.g = rE[s]), ((e, t, n, r) => { r ? t.data = t.data.replace(r, e) : -1 === t.data.indexOf(e) && (t.data = n ? e + t.data : t.data + e) })(rE[s], t, r, o), s }, sE = (e, t, n) => e.reduce(((e, r, i) => { let a = t[i]; if (a && a.call) { let e = a(n), t = e && e.props && e.props.className || /^go/.test(e) && e; a = t ? "." + t : e && "object" == typeof e ? e.props ? "" : nE(e, "") : !1 === e ? "" : e } return e + r + (null == a ? "" : a) }), ""); function oE(e) { let t = this || {}, n = e.call ? e(t.p) : e; return aE(n.unshift ? n.raw ? sE(n, [].slice.call(arguments, 1), t.p) : n.reduce(((e, n) => Object.assign(e, n && n.call ? n(t.p) : n)), {}) : n, JA(t.target), t.g, t.o, t.k) } oE.bind({ g: 1 }); let lE, cE, uE, dE = oE.bind({ k: 1 }); function hE(e, t) { let n = this || {}; return function () { let r = arguments; function i(a, s) { let o = Object.assign({}, a), l = o.className || i.className; n.p = Object.assign({ theme: cE && cE() }, o), n.o = / *go\d+/.test(l), o.className = oE.apply(n, r) + (l ? " " + l : ""), t && (o.ref = s); let c = e; return e[0] && (c = o.as || e, delete o.as), uE && c[0] && uE(o), lE(c, o) } return t ? t(i) : i } } var fE, pE, mE, gE, vE, bE, yE, wE, xE, _E, kE, SE, AE, EE, CE, ME, TE = (e, t) => (e => "function" == typeof e)(e) ? e(t) : e, PE = (() => { let e = 0; return () => (++e).toString() })(), RE = (() => { let e; return () => { if (void 0 === e && typeof window < "u") { let t = matchMedia("(prefers-reduced-motion: reduce)"); e = !t || t.matches } return e } })(), NE = new Map, LE = e => { if (NE.has(e)) return; let t = setTimeout((() => { NE.delete(e), jE({ type: 4, toastId: e }) }), 1e3); NE.set(e, t) }, IE = (e, t) => { switch (t.type) { case 0: return { ...e, toasts: [t.toast, ...e.toasts].slice(0, 20) }; case 1: return t.toast.id && (e => { let t = NE.get(e); t && clearTimeout(t) })(t.toast.id), { ...e, toasts: e.toasts.map((e => e.id === t.toast.id ? { ...e, ...t.toast } : e)) }; case 2: let { toast: n } = t; return e.toasts.find((e => e.id === n.id)) ? IE(e, { type: 1, toast: n }) : IE(e, { type: 0, toast: n }); case 3: let { toastId: r } = t; return r ? LE(r) : e.toasts.forEach((e => { LE(e.id) })), { ...e, toasts: e.toasts.map((e => e.id === r || void 0 === r ? { ...e, visible: !1 } : e)) }; case 4: return void 0 === t.toastId ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((e => e.id !== t.toastId)) }; case 5: return { ...e, pausedAt: t.time }; case 6: let i = t.time - (e.pausedAt || 0); return { ...e, pausedAt: void 0, toasts: e.toasts.map((e => ({ ...e, pauseDuration: e.pauseDuration + i }))) } } }, DE = [], OE = { toasts: [], pausedAt: void 0 }, jE = e => { OE = IE(OE, e), DE.forEach((e => { e(OE) })) }, FE = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, zE = e => (t, n) => { let r = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "blank", n = arguments.length > 2 ? arguments[2] : void 0; return { createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (null == n ? void 0 : n.id) || PE() } }(t, e, n); return jE({ type: 2, toast: r }), r.id }, WE = (e, t) => zE("blank")(e, t); WE.error = zE("error"), WE.success = zE("success"), WE.loading = zE("loading"), WE.custom = zE("custom"), WE.dismiss = e => { jE({ type: 3, toastId: e }) }, WE.remove = e => jE({ type: 4, toastId: e }), WE.promise = (e, t, n) => { let r = WE.loading(t.loading, { ...n, ...null == n ? void 0 : n.loading }); return e.then((e => (WE.success(TE(t.success, e), { id: r, ...n, ...null == n ? void 0 : n.success }), e))).catch((e => { WE.error(TE(t.error, e), { id: r, ...n, ...null == n ? void 0 : n.error }) })), e }; var BE = (e, t) => { jE({ type: 1, toast: { id: e, height: t } }) }, HE = () => { jE({ type: 5, time: Date.now() }) }, UE = e => { let { toasts: n, pausedAt: r } = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, [n, r] = (0, t.useState)(OE); (0, t.useEffect)((() => (DE.push(r), () => { let e = DE.indexOf(r); e > -1 && DE.splice(e, 1) })), [n]); let i = n.toasts.map((t => { var n, r; return { ...e, ...e[t.type], ...t, duration: t.duration || (null == (n = e[t.type]) ? void 0 : n.duration) || (null == e ? void 0 : e.duration) || FE[t.type], style: { ...e.style, ...null == (r = e[t.type]) ? void 0 : r.style, ...t.style } } })); return { ...n, toasts: i } }(e); (0, t.useEffect)((() => { if (r) return; let e = Date.now(), t = n.map((t => { if (t.duration === 1 / 0) return; let n = (t.duration || 0) + t.pauseDuration - (e - t.createdAt); if (!(n < 0)) return setTimeout((() => WE.dismiss(t.id)), n); t.visible && WE.dismiss(t.id) })); return () => { t.forEach((e => e && clearTimeout(e))) } }), [n, r]); let i = (0, t.useCallback)((() => { r && jE({ type: 6, time: Date.now() }) }), [r]), a = (0, t.useCallback)(((e, t) => { let { reverseOrder: r = !1, gutter: i = 8, defaultPosition: a } = t || {}, s = n.filter((t => (t.position || a) === (e.position || a) && t.height)), o = s.findIndex((t => t.id === e.id)), l = s.filter(((e, t) => t < o && e.visible)).length; return s.filter((e => e.visible)).slice(...r ? [l + 1] : [0, l]).reduce(((e, t) => e + (t.height || 0) + i), 0) }), [n]); return { toasts: n, handlers: { updateHeight: BE, startPause: HE, endPause: i, calculateOffset: a } } }, VE = dE(fE || (fE = QA(["\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n transform: scale(1) rotate(45deg);\n  opacity: 1;\n}"]))), qE = dE(pE || (pE = QA(["\nfrom {\n  transform: scale(0);\n  opacity: 0;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}"]))), GE = dE(mE || (mE = QA(["\nfrom {\n  transform: scale(0) rotate(90deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(90deg);\n\topacity: 1;\n}"]))), XE = hE("div")(gE || (gE = QA(["\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ", ";\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ", " 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n\n  &:after,\n  &:before {\n    content: '';\n    animation: ", " 0.15s ease-out forwards;\n    animation-delay: 150ms;\n    position: absolute;\n    border-radius: 3px;\n    opacity: 0;\n    background: ", ";\n    bottom: 9px;\n    left: 4px;\n    height: 2px;\n    width: 12px;\n  }\n\n  &:before {\n    animation: ", " 0.15s ease-out forwards;\n    animation-delay: 180ms;\n    transform: rotate(90deg);\n  }\n"])), (e => e.primary || "#ff4b4b"), VE, qE, (e => e.secondary || "#fff"), GE), YE = dE(vE || (vE = QA(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"]))), KE = hE("div")(bE || (bE = QA(["\n  width: 12px;\n  height: 12px;\n  box-sizing: border-box;\n  border: 2px solid;\n  border-radius: 100%;\n  border-color: ", ";\n  border-right-color: ", ";\n  animation: ", " 1s linear infinite;\n"])), (e => e.secondary || "#e0e0e0"), (e => e.primary || "#616161"), YE), QE = dE(yE || (yE = QA(["\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(45deg);\n\topacity: 1;\n}"]))), $E = dE(wE || (wE = QA(["\n0% {\n\theight: 0;\n\twidth: 0;\n\topacity: 0;\n}\n40% {\n  height: 0;\n\twidth: 6px;\n\topacity: 1;\n}\n100% {\n  opacity: 1;\n  height: 10px;\n}"]))), JE = hE("div")(xE || (xE = QA(["\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ", ";\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ", " 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n  &:after {\n    content: '';\n    box-sizing: border-box;\n    animation: ", " 0.2s ease-out forwards;\n    opacity: 0;\n    animation-delay: 200ms;\n    position: absolute;\n    border-right: 2px solid;\n    border-bottom: 2px solid;\n    border-color: ", ";\n    bottom: 6px;\n    left: 6px;\n    height: 10px;\n    width: 6px;\n  }\n"])), (e => e.primary || "#61d345"), QE, $E, (e => e.secondary || "#fff")), ZE = hE("div")(_E || (_E = QA(["\n  position: absolute;\n"]))), eC = hE("div")(kE || (kE = QA(["\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 20px;\n  min-height: 20px;\n"]))), tC = dE(SE || (SE = QA(["\nfrom {\n  transform: scale(0.6);\n  opacity: 0.4;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}"]))), nC = hE("div")(AE || (AE = QA(["\n  position: relative;\n  transform: scale(0.6);\n  opacity: 0.4;\n  min-width: 20px;\n  animation: ", " 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n"])), tC), rC = e => { let { toast: n } = e, { icon: r, type: i, iconTheme: a } = n; return void 0 !== r ? "string" == typeof r ? t.createElement(nC, null, r) : r : "blank" === i ? null : t.createElement(eC, null, t.createElement(KE, { ...a }), "loading" !== i && t.createElement(ZE, null, "error" === i ? t.createElement(XE, { ...a }) : t.createElement(JE, { ...a }))) }, iC = e => "\n0% {transform: translate3d(0,".concat(-200 * e, "%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n"), aC = e => "\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,".concat(-150 * e, "%,-1px) scale(.6); opacity:0;}\n"), sC = hE("div")(EE || (EE = QA(["\n  display: flex;\n  align-items: center;\n  background: #fff;\n  color: #363636;\n  line-height: 1.3;\n  will-change: transform;\n  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);\n  max-width: 350px;\n  pointer-events: auto;\n  padding: 8px 10px;\n  border-radius: 8px;\n"]))), oC = hE("div")(CE || (CE = QA(["\n  display: flex;\n  justify-content: center;\n  margin: 4px 10px;\n  color: inherit;\n  flex: 1 1 auto;\n  white-space: pre-line;\n"]))), lC = t.memo((e => { let { toast: n, position: r, style: i, children: a } = e, s = n.height ? ((e, t) => { let n = e.includes("top") ? 1 : -1, [r, i] = RE() ? ["0%{opacity:0;} 100%{opacity:1;}", "0%{opacity:1;} 100%{opacity:0;}"] : [iC(n), aC(n)]; return { animation: t ? "".concat(dE(r), " 0.35s cubic-bezier(.21,1.02,.73,1) forwards") : "".concat(dE(i), " 0.4s forwards cubic-bezier(.06,.71,.55,1)") } })(n.position || r || "top-center", n.visible) : { opacity: 0 }, o = t.createElement(rC, { toast: n }), l = t.createElement(oC, { ...n.ariaProps }, TE(n.message, n)); return t.createElement(sC, { className: n.className, style: { ...s, ...i, ...n.style } }, "function" == typeof a ? a({ icon: o, message: l }) : t.createElement(t.Fragment, null, o, l)) })); !function (e, t, n, r) { nE.p = t, lE = e, cE = n, uE = r }(t.createElement); var cC = e => { let { id: n, className: r, style: i, onHeightUpdate: a, children: s } = e, o = t.useCallback((e => { if (e) { let t = () => { let t = e.getBoundingClientRect().height; a(n, t) }; t(), new MutationObserver(t).observe(e, { subtree: !0, childList: !0, characterData: !0 }) } }), [n, a]); return t.createElement("div", { ref: o, className: r, style: i }, s) }, uC = oE(ME || (ME = QA(["\n  z-index: 9999;\n  > * {\n    pointer-events: auto;\n  }\n"]))), dC = e => { let { reverseOrder: n, position: r = "top-center", toastOptions: i, gutter: a, children: s, containerStyle: o, containerClassName: l } = e, { toasts: c, handlers: u } = UE(i); return t.createElement("div", { style: { position: "fixed", zIndex: 9999, top: 16, left: 16, right: 16, bottom: 16, pointerEvents: "none", ...o }, className: l, onMouseEnter: u.startPause, onMouseLeave: u.endPause }, c.map((e => { let i = e.position || r, o = ((e, t) => { let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, i = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {}; return { left: 0, right: 0, display: "flex", position: "absolute", transition: RE() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: "translateY(".concat(t * (n ? 1 : -1), "px)"), ...r, ...i } })(i, u.calculateOffset(e, { reverseOrder: n, gutter: a, defaultPosition: r })); return t.createElement(cC, { id: e.id, key: e.id, onHeightUpdate: u.updateHeight, className: e.visible ? uC : "", style: o }, "custom" === e.type ? TE(e.message, e) : s ? s(e) : t.createElement(lC, { toast: e, position: i })) }))) }; const hC = () => { const [e, n] = (0, t.useState)(!0); return (0, t.useEffect)((() => { setTimeout((() => { n(!1) }), 5e3) }), []), (0, v.jsx)("div", { className: " focus-visible:[&_button]:!outline-none min-h-[100dvh] ".concat(e ? "flex" : "", " items-center overflow-hidden justify-center"), children: !0 !== e ? (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(dC, {}), (0, v.jsx)(XS, {}), (0, v.jsx)(Zk, {}), (0, v.jsx)(GA, {}), (0, v.jsx)(YA, {}), (0, v.jsx)(fS, {}), (0, v.jsx)(pS, {}), (0, v.jsx)(aA, {}), (0, v.jsx)(KA, {})] }) : (0, v.jsx)(iA, {}) }) }; function fC(e) { return "auto" === e || "dark" === e || "light" === e } function pC() { let e, { key: t = "mantine-color-scheme-value" } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return { get: e => { if ("undefined" === typeof window) return e; try { const n = window.localStorage.getItem(t); return fC(n) ? n : e } catch { return e } }, set: e => { try { window.localStorage.setItem(t, e) } catch (n) { console.warn("[@mantine/core] Local storage color scheme manager was unable to save color scheme.", n) } }, subscribe: n => { e = e => { e.storageArea === window.localStorage && e.key === t && fC(e.newValue) && n(e.newValue) }, window.addEventListener("storage", e) }, unsubscribe: () => { window.removeEventListener("storage", e) }, clear: () => { window.localStorage.removeItem(t) } } } function mC() { const e = U(), t = ie(), n = ae(e.breakpoints).reduce(((t, n) => { const r = e.breakpoints[n].includes("px"), i = function (e) { const t = function (e) { var t; return "string" === typeof e && e.includes("var(--mantine-scale)") ? null === (t = e.match(/^calc\((.*?)\)$/)) || void 0 === t ? void 0 : t[1].split("*")[0].trim() : e }(e); return "number" === typeof t ? t : "string" === typeof t ? t.includes("calc") || t.includes("var") ? t : t.includes("px") ? Number(t.replace("px", "")) : t.includes("rem") ? 16 * Number(t.replace("rem", "")) : t.includes("em") ? 16 * Number(t.replace("em", "")) : Number(t) : NaN }(e.breakpoints[n]), a = r ? "".concat(i - .1, "px") : x(i - .1), s = r ? "".concat(i, "px") : x(i); return "".concat(t, "@media (max-width: ").concat(a, ") {.mantine-visible-from-").concat(n, " {display: none !important;}}@media (min-width: ").concat(s, ") {.mantine-hidden-from-").concat(n, " {display: none !important;}}") }), ""); return (0, v.jsx)("style", { "data-mantine-styles": "classes", nonce: null === t || void 0 === t ? void 0 : t(), dangerouslySetInnerHTML: { __html: n } }) } function gC(e) { return Object.entries(e).map((e => { let [t, n] = e; return "".concat(t, ": ").concat(n, ";") })).join("") } function vC(e, t) { return (Array.isArray(e) ? e : [e]).reduce(((e, t) => "".concat(t, "{").concat(e, "}")), t) } function bC(e) { let { theme: t, color: n, colorScheme: r, name: i = n, withColorValues: a = !0 } = e; if (!t.colors[n]) return {}; if ("light" === r) { const e = S(t, "light"), r = { ["--mantine-color-".concat(i, "-text")]: "var(--mantine-color-".concat(i, "-filled)"), ["--mantine-color-".concat(i, "-filled")]: "var(--mantine-color-".concat(i, "-").concat(e, ")"), ["--mantine-color-".concat(i, "-filled-hover")]: "var(--mantine-color-".concat(i, "-").concat(9 === e ? 8 : e + 1, ")"), ["--mantine-color-".concat(i, "-light")]: N(t.colors[n][e], .1), ["--mantine-color-".concat(i, "-light-hover")]: N(t.colors[n][e], .12), ["--mantine-color-".concat(i, "-light-color")]: "var(--mantine-color-".concat(i, "-").concat(e, ")"), ["--mantine-color-".concat(i, "-outline")]: "var(--mantine-color-".concat(i, "-").concat(e, ")"), ["--mantine-color-".concat(i, "-outline-hover")]: N(t.colors[n][e], .05) }; return a ? { ["--mantine-color-".concat(i, "-0")]: t.colors[n][0], ["--mantine-color-".concat(i, "-1")]: t.colors[n][1], ["--mantine-color-".concat(i, "-2")]: t.colors[n][2], ["--mantine-color-".concat(i, "-3")]: t.colors[n][3], ["--mantine-color-".concat(i, "-4")]: t.colors[n][4], ["--mantine-color-".concat(i, "-5")]: t.colors[n][5], ["--mantine-color-".concat(i, "-6")]: t.colors[n][6], ["--mantine-color-".concat(i, "-7")]: t.colors[n][7], ["--mantine-color-".concat(i, "-8")]: t.colors[n][8], ["--mantine-color-".concat(i, "-9")]: t.colors[n][9], ...r } : r } const s = S(t, "dark"), o = { ["--mantine-color-".concat(i, "-text")]: "var(--mantine-color-".concat(i, "-4)"), ["--mantine-color-".concat(i, "-filled")]: "var(--mantine-color-".concat(i, "-").concat(s, ")"), ["--mantine-color-".concat(i, "-filled-hover")]: "var(--mantine-color-".concat(i, "-").concat(9 === s ? 8 : s + 1, ")"), ["--mantine-color-".concat(i, "-light")]: N(t.colors[n][Math.max(0, s - 2)], .15), ["--mantine-color-".concat(i, "-light-hover")]: N(t.colors[n][Math.max(0, s - 2)], .2), ["--mantine-color-".concat(i, "-light-color")]: "var(--mantine-color-".concat(i, "-").concat(Math.max(s - 5, 0), ")"), ["--mantine-color-".concat(i, "-outline")]: "var(--mantine-color-".concat(i, "-").concat(Math.max(s - 4, 0), ")"), ["--mantine-color-".concat(i, "-outline-hover")]: N(t.colors[n][Math.max(s - 4, 0)], .05) }; return a ? { ["--mantine-color-".concat(i, "-0")]: t.colors[n][0], ["--mantine-color-".concat(i, "-1")]: t.colors[n][1], ["--mantine-color-".concat(i, "-2")]: t.colors[n][2], ["--mantine-color-".concat(i, "-3")]: t.colors[n][3], ["--mantine-color-".concat(i, "-4")]: t.colors[n][4], ["--mantine-color-".concat(i, "-5")]: t.colors[n][5], ["--mantine-color-".concat(i, "-6")]: t.colors[n][6], ["--mantine-color-".concat(i, "-7")]: t.colors[n][7], ["--mantine-color-".concat(i, "-8")]: t.colors[n][8], ["--mantine-color-".concat(i, "-9")]: t.colors[n][9], ...o } : o } function yC(e, t, n) { ae(t).forEach((r => Object.assign(e, { ["--mantine-".concat(n, "-").concat(r)]: t[r] }))) } const wC = e => { const t = S(e, "light"), n = e.defaultRadius in e.radius ? e.radius[e.defaultRadius] : w(e.defaultRadius), r = { variables: { "--mantine-scale": e.scale.toString(), "--mantine-cursor-type": e.cursorType, "--mantine-color-scheme": "light dark", "--mantine-webkit-font-smoothing": e.fontSmoothing ? "antialiased" : "unset", "--mantine-moz-font-smoothing": e.fontSmoothing ? "grayscale" : "unset", "--mantine-color-white": e.white, "--mantine-color-black": e.black, "--mantine-line-height": e.lineHeights.md, "--mantine-font-family": e.fontFamily, "--mantine-font-family-monospace": e.fontFamilyMonospace, "--mantine-font-family-headings": e.headings.fontFamily, "--mantine-heading-font-weight": e.headings.fontWeight, "--mantine-heading-text-wrap": e.headings.textWrap, "--mantine-radius-default": n, "--mantine-primary-color-filled": "var(--mantine-color-".concat(e.primaryColor, "-filled)"), "--mantine-primary-color-filled-hover": "var(--mantine-color-".concat(e.primaryColor, "-filled-hover)"), "--mantine-primary-color-light": "var(--mantine-color-".concat(e.primaryColor, "-light)"), "--mantine-primary-color-light-hover": "var(--mantine-color-".concat(e.primaryColor, "-light-hover)"), "--mantine-primary-color-light-color": "var(--mantine-color-".concat(e.primaryColor, "-light-color)") }, light: { "--mantine-primary-color-contrast": tS(e, "light"), "--mantine-color-bright": "var(--mantine-color-black)", "--mantine-color-text": e.black, "--mantine-color-body": e.white, "--mantine-color-error": "var(--mantine-color-red-6)", "--mantine-color-placeholder": "var(--mantine-color-gray-5)", "--mantine-color-anchor": "var(--mantine-color-".concat(e.primaryColor, "-").concat(t, ")"), "--mantine-color-default": "var(--mantine-color-white)", "--mantine-color-default-hover": "var(--mantine-color-gray-0)", "--mantine-color-default-color": "var(--mantine-color-black)", "--mantine-color-default-border": "var(--mantine-color-gray-4)", "--mantine-color-dimmed": "var(--mantine-color-gray-6)" }, dark: { "--mantine-primary-color-contrast": tS(e, "dark"), "--mantine-color-bright": "var(--mantine-color-white)", "--mantine-color-text": "var(--mantine-color-dark-0)", "--mantine-color-body": "var(--mantine-color-dark-7)", "--mantine-color-error": "var(--mantine-color-red-8)", "--mantine-color-placeholder": "var(--mantine-color-dark-3)", "--mantine-color-anchor": "var(--mantine-color-".concat(e.primaryColor, "-4)"), "--mantine-color-default": "var(--mantine-color-dark-6)", "--mantine-color-default-hover": "var(--mantine-color-dark-5)", "--mantine-color-default-color": "var(--mantine-color-white)", "--mantine-color-default-border": "var(--mantine-color-dark-4)", "--mantine-color-dimmed": "var(--mantine-color-dark-2)" } }; yC(r.variables, e.breakpoints, "breakpoint"), yC(r.variables, e.spacing, "spacing"), yC(r.variables, e.fontSizes, "font-size"), yC(r.variables, e.lineHeights, "line-height"), yC(r.variables, e.shadows, "shadow"), yC(r.variables, e.radius, "radius"), e.colors[e.primaryColor].forEach(((t, n) => { r.variables["--mantine-primary-color-".concat(n)] = "var(--mantine-color-".concat(e.primaryColor, "-").concat(n, ")") })), ae(e.colors).forEach((t => { const n = e.colors[t]; if (function (e) { return !!e && "object" === typeof e && "mantine-virtual-color" in e }(n)) return Object.assign(r.light, bC({ theme: e, name: n.name, color: n.light, colorScheme: "light", withColorValues: !0 })), void Object.assign(r.dark, bC({ theme: e, name: n.name, color: n.dark, colorScheme: "dark", withColorValues: !0 })); n.forEach(((e, n) => { r.variables["--mantine-color-".concat(t, "-").concat(n)] = e })), Object.assign(r.light, bC({ theme: e, color: t, colorScheme: "light", withColorValues: !1 })), Object.assign(r.dark, bC({ theme: e, color: t, colorScheme: "dark", withColorValues: !1 })) })); const i = e.headings.sizes; return ae(i).forEach((t => { r.variables["--mantine-".concat(t, "-font-size")] = i[t].fontSize, r.variables["--mantine-".concat(t, "-line-height")] = i[t].lineHeight, r.variables["--mantine-".concat(t, "-font-weight")] = i[t].fontWeight || e.headings.fontWeight })), r }; const xC = wC(I); function _C(e) { let { cssVariablesSelector: t, deduplicateCssVariables: n } = e; const r = U(), i = ie(), a = function (e) { let { theme: t, generator: n } = e; const r = wC(t), i = null === n || void 0 === n ? void 0 : n(t); return i ? O(r, i) : r }({ theme: r, generator: re().cssVariablesResolver }), s = ":root" === t && n, o = function (e, t) { const n = gC(e.variables), r = n ? vC(t, n) : "", i = gC(e.dark), a = gC(e.light), s = i ? vC("".concat(t, ":host" === t ? '([data-mantine-color-scheme="dark"])' : '[data-mantine-color-scheme="dark"]'), i) : "", o = a ? vC("".concat(t, ":host" === t ? '([data-mantine-color-scheme="light"])' : '[data-mantine-color-scheme="light"]'), a) : ""; return "".concat(r).concat(s).concat(o) }(s ? function (e) { const t = { variables: {}, light: {}, dark: {} }; return ae(e.variables).forEach((n => { xC.variables[n] !== e.variables[n] && (t.variables[n] = e.variables[n]) })), ae(e.light).forEach((n => { xC.light[n] !== e.light[n] && (t.light[n] = e.light[n]) })), ae(e.dark).forEach((n => { xC.dark[n] !== e.dark[n] && (t.dark[n] = e.dark[n]) })), t }(a) : a, t); return o ? (0, v.jsx)("style", { "data-mantine-styles": !0, nonce: null === i || void 0 === i ? void 0 : i(), dangerouslySetInnerHTML: { __html: "".concat(o).concat(s ? "" : (l = t, "\n  ".concat(l, '[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }\n  ').concat(l, '[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }\n'))) } }) : null; var l } function kC(e, t) { var n; const r = "auto" !== e ? e : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"; null === (n = t()) || void 0 === n || n.setAttribute("data-mantine-color-scheme", r) } function SC(e) { let { theme: n, children: r, getStyleNonce: i, withStaticClasses: a = !0, withGlobalClasses: s = !0, deduplicateCssVariables: o = !0, withCssVariables: l = !0, cssVariablesSelector: c = ":root", classNamesPrefix: u = "mantine", colorSchemeManager: d = pC(), defaultColorScheme: h = "light", getRootElement: f = () => document.documentElement, cssVariablesResolver: p, forceColorScheme: m, stylesTransform: g } = e; const { colorScheme: b, setColorScheme: y, clearColorScheme: w } = function (e) { let { manager: n, defaultColorScheme: r, getRootElement: i, forceColorScheme: a } = e; const s = (0, t.useRef)(), [o, l] = (0, t.useState)((() => n.get(r))), c = a || o, u = (0, t.useCallback)((e => { a || (kC(e, i), l(e), n.set(e)) }), [n.set, c, a]), d = (0, t.useCallback)((() => { l(r), kC(r, i), n.clear() }), [n.clear, r]); return (0, t.useEffect)((() => (n.subscribe(u), n.unsubscribe)), [n.subscribe, n.unsubscribe]), Zn((() => { kC(n.get(r), i) }), []), (0, t.useEffect)((() => { var e; if (a) return kC(a, i), () => { }; void 0 === a && kC(o, i), s.current = window.matchMedia("(prefers-color-scheme: dark)"); const t = e => { "auto" === o && kC(e.matches ? "dark" : "light", i) }; return null === (e = s.current) || void 0 === e || e.addEventListener("change", t), () => { var e; return null === (e = s.current) || void 0 === e ? void 0 : e.removeEventListener("change", t) } }), [o, a]), { colorScheme: c, setColorScheme: u, clearColorScheme: d } }({ defaultColorScheme: h, forceColorScheme: m, manager: d, getRootElement: f }); return function (e) { let { respectReducedMotion: t, getRootElement: n } = e; Zn((() => { var e; t && (null === (e = n()) || void 0 === e || e.setAttribute("data-respect-reduced-motion", "true")) }), [t]) }({ respectReducedMotion: (null === n || void 0 === n ? void 0 : n.respectReducedMotion) || !1, getRootElement: f }), (0, v.jsx)(ne.Provider, { value: { colorScheme: b, setColorScheme: y, clearColorScheme: w, getRootElement: f, classNamesPrefix: u, getStyleNonce: i, cssVariablesResolver: p, cssVariablesSelector: c, withStaticClasses: a, stylesTransform: g }, children: (0, v.jsxs)(V, { theme: n, children: [l && (0, v.jsx)(_C, { cssVariablesSelector: c, deduplicateCssVariables: o }), s && (0, v.jsx)(mC, {}), r] }) }) } _C.displayName = "@mantine/CssVariables", function () { const e = console.error; console.error = function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; n.length > 1 && "string" === typeof n[0] && n[0].toLowerCase().includes("extra attributes from the server") && "string" === typeof n[1] && n[1].toLowerCase().includes("data-mantine-color-scheme") || e(...n) } }(), SC.displayName = "@mantine/core/MantineProvider"; var AC = __webpack_require__(115), EC = __webpack_require__.n(AC); u_.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@".concat(p_, "/build/pdf.worker.min.mjs"); const CC = function () { (0, t.useEffect)((() => { EC().init(), EC().refresh() }), []); const e = { breakpoints: { xs: "320px", sm: "476px", md: "640px", bs: "768px", lg: "900px", xl: "1024", "2xl": "1280" } }; return (0, v.jsx)(SC, { theme: e, children: (0, v.jsx)(hC, {}) }) }, MC = e => { e && e instanceof Function && __webpack_require__.e(453).then(__webpack_require__.bind(__webpack_require__, 453)).then((t => { let { getCLS: n, getFID: r, getFCP: i, getLCP: a, getTTFB: s } = t; n(e), r(e), i(e), a(e), s(e) })) }; r.createRoot(document.getElementById("root")).render((0, v.jsx)(t.StrictMode, { children: (0, v.jsx)(CC, {}) })), MC() })() })();
//# sourceMappingURL=main.9ae18fe7.js.map